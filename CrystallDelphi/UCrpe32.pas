(*
-----------------------------------------------------------
  Name:               $File: //depot/Reporting/Mainline/sdk/VCL/Delphi/UCrpe32.pas $
 Version:            $Revision: #21 $
 Last Modified Date: $Date: 2005/01/14 $

 Copyright (c) 1995-2003 Crystal Decisions, Inc.
 895 Emerson St., Palo Alto, California, USA 94301.

 All rights reserved.

 This file contains confidential, proprietary information, trade secrets and copyrighted expressions
 that are the property of Crystal Decisions, Inc., 895 Emerson St., Palo Alto, California, USA 94301.

 Any disclosure, reproduction, sale or license of all or any part of the information or expression
 contained in this file is prohibited by California law and the United States copyright law, and may
 be subject to criminal penalties.

 If you are not an employee of Crystal Decisions or otherwise authorized in writing by Crystal Decisions
 to possess this file, please contact Crystal Decisions immediately at the address listed above.
-----------------------------------------------------------

Crystal Reports VCL Component - Main Unit
=========================================
Version  : 11
Purpose  : This is the main unit file of the Crystal Reports
           Delphi VCL Component.
Supports : Delphi 7
*)

unit UCrpe32;

{$I UCRPEDEF.INC}

interface

uses
  Windows, Classes, Controls, SysUtils, Graphics, Forms, Registry,
  CRDynamic, UCrpeUtl, UCrpeClasses;

{Might need this flag to compile for C++ Builder}
// {$ObjExportAll On}

const
{------------------------------------------------------------------------------}
{ AboutBox Constants                                                           }
{------------------------------------------------------------------------------}
  TCRPE_LANGUAGE = 'Delphi / C++Builder';
  TCRPE_VERSION  = '11.0.0.0';
   {Crystal Decisions Address}
  TCRPE_COMPANY_NAME     = 'Business Objects Inc.';
  TCRPE_COMPANY_ADDRESS1 = '840 Cambie Street';
  TCRPE_COMPANY_ADDRESS2 = 'Vancouver, B.C., Canada  V6B 4J2';
  TCRPE_COPYRIGHT        = 'Copyright (c)2001-2005 ';
   {Crystal Decisions Contact}
  TCRPE_CR_PHONE    = '1-604-669-8379 ';
  TCRPE_CR_EMAIL    = 'http://support.businessobjects.com';
  TCRPE_CR_WEBSITE  = 'http://www.businessobjects.com';
   {Developer Contact}
  TCRPE_VCL_EMAIL   = 'crystalvcl@businessobjects.com';
  TCRPE_VCL_WEBSITE = 'http://www.businessobjects.com/products/crystalreports/vcl';

  PECursorTypes : array[0..19] of Smallint =
   (PE_TC_DEFAULT_CURSOR, PE_TC_ARROW_CURSOR, PE_TC_CROSS_CURSOR,
    PE_TC_IBEAM_CURSOR, PE_TC_UPARROW_CURSOR, PE_TC_SIZEALL_CURSOR,
    PE_TC_SIZENWSE_CURSOR, PE_TC_SIZENESW_CURSOR, PE_TC_SIZEWE_CURSOR,
    PE_TC_SIZENS_CURSOR, PE_TC_NO_CURSOR, PE_TC_WAIT_CURSOR,
    PE_TC_APPSTARTING_CURSOR, PE_TC_HELP_CURSOR, PE_TC_MAGNIFY_CURSOR,
    {CR8+} PE_TC_BACKGROUND_PROCESS_CURSOR, PE_TC_GRAB_HAND_CURSOR,
    PE_TC_ZOOM_IN_CURSOR, PE_TC_REPORT_SECTION_CURSOR, PE_TC_HAND_CURSOR);

 {Error Constants}
  {General}
   ECRPE_LOAD_DLL              = '100:Error loading library: CRPE32.DLL';
   ECRPE_FREE_DLL              = '101:Error freeing library: CRPE32.DLL';
   ECRPE_NOT_LOADED            = '102:CRPE32.DLL is not loaded';
   ECRPE_VERSION               = '103:Incompatible CRPE version: requires version 11.x';
   ECRPE_VERSION_INFO          = '104:Failed to obtain Version Information from CRPE32.DLL';
   ECRPE_LOAD_DLL_FUNCTION     = '105:Failed to load function from CRPE32.DLL';
   ECRPE_ALLOCATE_MEMORY       = '110:Could not Allocate Memory for Internal Variables';
   ECRPE_NO_NAME               = '112:No ReportName assigned';
   ECRPE_REPORT_NOT_FOUND      = '114:Report not found';
   ECRPE_SUBSCRIPT             = '116:Subscript out of range';
   ECRPE_NOT_FOUND             = '120:Lookup item not found';
   ECRPE_FAILED_GETTING_ERROR  = '130:Failed to Retrieve Error Message from Print Engine';
   ECRPE_UNDEFINED             = '140:Undefined Print Engine Error';
   {ByName Functions}
   ECRPE_FORMULA_BY_NAME       = '200:Formula Name could not be found';
   ECRPE_PARAM_BY_NAME         = '202:Parameter Name could not be found';
   ECRPE_RUNNINGTOTAL_BY_NAME  = '204:RunningTotal Name could not be found';
   ECRPE_SQLEXPRESSION_BY_NAME = '206:SQLExpression Name could not be found';
   ECRPE_SUBREPORT_BY_NAME     = '208:Subreport Name could not be found';
   ECRPE_TABLE_BY_NAME         = '210:Table Name could not be found';
   ECRPE_SECTIONFORMAT_BY_NAME = '211:Section Name could not be found';
   ECRPE_AREAFORMAT_BY_NAME    = '212:Area Name could not be found';
   {LogOn}
   ECRPE_SERVERNAME           = '251:Invalid ServerName';
   {SQL Params}
   ECRPE_GET_AS_DATE          = '280:Value could not be converted to Date';
   ECRPE_GET_AS_DATETIME      = '282:Value could not be converted to DateTime';
   ECRPE_GET_AS_TIME          = '284:Value could not be converted to Time';
   {Parameter Fields}
   ECRPE_PARAMETER_NUMBER     = '292:Invalid Number Value';
   ECRPE_PARAMETER_CURRENCY   = '293:Invalid Currency Value';
   ECRPE_PARAMETER_BOOLEAN    = '294:Invalid Boolean Value (Proper format: True/False)';
   ECRPE_PARAMETER_DATE       = '296:Invalid Date Value (Proper format: YYYY,MM,DD)';
   ECRPE_PARAMETER_STRING     = '297:Invalid String Value';
   ECRPE_PARAMETER_DATETIME   = '298:Invalid DateTime Value (Proper format: YYYY,MM,DD HH:MM:SS)';
   ECRPE_PARAMETER_TIME       = '299:Invalid Time Value (Proper format: HH:MM:SS)';
   ECRPE_STR2VALUEINFO        = '305:Error converting string to ValueInfo';
   {Tables}
   ECRPE_ALIAS_NAME           = '322:Invalid BDE Alias Name';
   {Sections}
   ECRPE_SECTION_CODE         = '360:Invalid Section Code or String';
   ECRPE_GET_SECTIONS         = '372:Error retrieving Report Sections';

type
  {AboutBox}
  TCrAboutBox = string;
  {General}
  TCrState  = (crsSetup, crsInit);
  TCrErrorResult = (errIgnore, errAbort, errRaise);
  TCrBoolean = (cFalse, cTrue, cDefault);
  TCrReportName = string; {255}
  TCrDesignControls = string;

  {Output}
  TCrOutput = (toWindow, toPrinter, toExport);

  {Error}
  TCrError = (errVCL, errEngine);
  TCrErrorOption = (errNoOption, errFormula, errPaging, errCancelDialog,
    errFormatFormulaName, errLinkedParameter, errMinMaxParameter, errCRPEBugs);

  {Status}
  TCrStatus = (crsNotOpen, crsJobNotStarted, crsJobInProgress,
    crsJobCompleted, crsJobFailed, crsJobCancelled, crsExceededTimeLimit,
    crsUnknown);

  {Events}
  TCrpeCancelEvent = procedure(Sender: TObject; var Cancel: Boolean) of object;
  TCrpeJobNumEvent = procedure(Sender: TObject; const JobNum: Word) of object;
  TCrpePrinterEvent = procedure(Sender: TObject; var PDMode: PDevMode; var Cancel: Boolean) of object;
  TCrpeVersionEvent = procedure(Sender: TObject;
    var Major, Minor, Release, Build : integer) of object;
  TCrpeErrorEvent = procedure(Sender: TObject; const ErrorNum: Smallint;
     const ErrorString: string; var IgnoreError: TCrErrorResult) of object;

  {ReportOptions}
  TCrDateTimeType = (ToString, ToDate, ToDateTime);
  TCrPromptMode = (pmNone, pmNormal, pmAlways);


  {Table}
  TCrTableType = (ttUnknown, ttStandard, ttSQL, ttStoredProcedure);

  {Printer}
  TCrPreserveRptSet = (prOrientation, prPaperSize, prPaperSource);
  TCrPreserveRptSettings = set of TCrPreserveRptSet;
  TCrOrientation = (orDefault, orPortrait, orLandscape);

  {Export}
  TCrExportAppName = string;
  TCrExportFileName = string; {255}
  TCrExportDestination = (toFile, toEmailViaMapi, toEmailViaVIM,
   toMSExchange, toLotusNotes, toApplication);

  TCrExportType = (AdobeAcrobatPDF, CrystalReportRPT, EditableWord, HTML32,
    HTML40, MSExcel, MSWord, ODBCTable, Records, ReportDefinition,
    RichText, SeparatedValues, TabSeparatedText, TextFormat, XML1);

  {SortFields}
  TCrSortDirection = (sdDescending, sdAscending);

  {Groups}
  TCrGroupCondition = (AnyChange, dateDaily, dateWeekly, dateBiWeekly,
    dateSemiMonthly, dateMonthly, dateQuarterly, dateSemiAnnually,
    dateAnnually, boolToYes, boolToNo, boolEveryYes, boolEveryNo,
    boolNextIsYes, boolNextIsNo, timeBySecond, timeByMinute,
    timeByHour, timeByAMPM);
  TCrGroupDirection = (gdDescending, gdAscending, gdOriginal,
    gdSpecified);
  // TCrGroupType = (gtOther, gtDate, gtBoolean, gtTime);
  {gtDateTime added for CR 9.x}
  TCrGroupType = (gtOther, gtDate, gtBoolean, gtTime , gtDateTime);

  TCrTopNSortType = (tnUnsorted, tnSortAll, tnTopN, tnBottomN);

  {SectionFont}
  TCrFontScope = (fsFields, fsText, fsBoth);
  TCrFontFamily = (ffDefault, ffRoman, ffSwiss, ffModern,
     ffScript,ffDecorative);
  TCrFontCharSet = (fcAnsi, fcDefault, fcSymbol, fcShiftJis,
    fcHangeul, fcChineseBig5, fcOEM);
  TCrFontWeight = (fwDefault, fwThin, fwExtraLight, fwLight, fwNormal,
    fwMedium, fwSemiBold, fwBold, fwExtraBold, fwHeavy);

  {ParamFields}
  TCrParamFieldType = (pfNumber, pfCurrency, pfBoolean, pfDate,
    pfString, pfDateTime, pfTime, pfInteger, pfColor, pfChar,
    pfLong, pfStringHandle, pfNoValue);
  TCrParamInfoValueType = (vtRange, vtDiscrete, vtDiscreteAndRange);
  TCrRangeBounds = (IncludeStartAndEnd, IncludeStartOnly,
    IncludeEndOnly, ExcludeStartAndEnd);
  TCrParamFieldSource = (psReport, psStoredProc, psQuery);
  TCrPickListSortMethod = (psmNoSort, psmAlphaNumericAscending,
    psmAlphaNumericDescending, psmNumericAscending, psmNumericDescending);



  {Ole Objects}
  TCrOleObjectType = (ootLinked, ootEmbedded, ootStatic);
  TCrOleUpdateType = (AutoUpdate, ManualUpdate);

  {SummaryInfo/SummaryFields}
  TCrSummaryType = (stSum, stAverage, stSampleVariance, stSampleStdDev,
    stMaximum, stMinimum, stCount, stPopVariance, stPopStdDev,
    stDistinctCount, stCorrelation, stCoVariance, stWeightedAvg,
    stMedian, stPercentile, stNthLargest, stNthSmallest, stMode,
    stNthMostFrequent, stPercentage);

  {RunningTotals}
  TCrRunningTotalCondition = (rtcNoCondition, rtcOnChangeField,
    rtcOnChangeGroup, rtcOnFormula);

  {CrossTabs}
  TCrCrossTabGroupPlacement = (gpRow, gpCol);

  {Maps}
  TCrMapLayout = (mlDetail, mlGroup, mlCrossTab, mlOlap);
  TCrMapType = (mttRanged, mttBarChart, mttPieChart, mttGraduated,
    mttDotDensity, mttIndividualValue);
  TCrMapDistributionMethod = (mdmEqualCount, mdmEqualRanges,
    mdmNaturalBreak, mdmStdDev);
  TCrMapLegend = (mlFull, mlCompact, mlNone);
  TCrMapLegendTitle = (mltAuto, mltSpecific);
  TCrMapOrientation = (moRowsOnly, moColsOnly, moMixedRowCol,
    moMixedColRow); {CrossTab & Olap maps only}

  {FormulaSyntax}
  TCrFormulaSyntax = (fsCrystal, fsBasic);

  {ReportStyle}
  TCrReportStyle = (rsStandard, rsLeadingBreak, rsTrailingBreak,
    rsTable, rsDropTable, rsExecutiveLeadingBreak, rsExecutiveTrailingBreak,
    rsShading, rsRedBlueBorder, rsMaroonTealBox);

  {WindowParent}
  TCrWinControl = TWinControl;
  {WindowZoom}
  TCrZoomPreview = (pwNormal, pwPageWidth, pwWholePage, pwDefault);
  TCrZoomMagnification = -1..400;  {-1 is default;
   0,1,2 are ZoomPreview constants; 3..24 are not valid, 25..400 are valid}
  {WindowStyle}
  TCrFormBorderStyle = bsNone..bsDialog;
  {WindowCursor}
  TCrWindowCursor = (wcDefault, wcArrow, wcCross, wcIBeam, wcUpArrow,
   wcSizeAll, wcSizeNWSE, wcSizeNESW, wcSizeWE, wcSizeNS, wcNo,
   wcWait, wcAppStart, wcHelp, wcMagnify, {CR8+} wcBackgroundProcess,
   wcGrabHand, wcZoomIn, wcReportSection, wcHand);

  {Graphs}
  TCrGraphType = (
    {Bar: 0..5}
    barSideBySide, barStacked, barPercent, bar3DSideBySide, bar3DStacked,
    bar3DPercent,
    {Line: 6..11}
    lineRegular, lineStacked, linePercent, lineWithMarkers,
    lineStackedWithMarkers, linePercentWithMarkers,
    {Area: 12..17}
    areaAbsolute, areaStacked, areaPercent, area3DAbsolute, area3DStacked,
    area3DPercent,
    {Pie: 18..21}
    pieRegular, pie3DRegular, pieMultiple, pieMultiProp,
    {Doughnut: 22..24}
    doughnutRegular, doughnutMultiple, doughnutMultiProp,
    {3D Riser: 25..28}
    ThreeDRegular, ThreeDPyramid, ThreeDOctagon, ThreeDCutCorners,
    {3D Surface: 29..31}
    ThreeDSurfaceRegular, ThreeDSurfaceWithSides, ThreeDSurfaceHoneyComb,
    {XYScatter: 32..35}
    XYScatter, XYScatterDualAxis, XYScatterLabeled, XYScatterDualAxisLabeled,
    {Radar: 36..38}
    radarRegular, radarStacked, radarDualAxis,
    {Bubble: 39,40}
    bubbleRegular, bubbleDualAxis,
    {StockHiLo: 41..46}
    stockHiLo, stockHiLoDualAxis, stockHiLoOpen, stockHiLoOpenDualAxis,
    stockHiLoOpenClose, stockHiLoOpenCloseDualAxis,
    {User Defined: 47}
    userDefinedGraph,
    {Unknown: 48..59}
    unknownBar, unknownLine, unknownArea, unknownPie, unknownDoughnut,
    unknown3DRiser, unknown3DSurface, unknownXYScatter, unknownRadar,
    unknownBubble, unknownStockHiLo, unknownGraphType);
  TCrGraphDirection = (Rows, Cols, RowCol, ColRow, Unknown);
  TCrGraphGridLines = (gglNone, gglMinor, gglMajor, gglMajorAndMinor);
  TCrGraphDVType = (gdvAutomatic, gdvManual);
  TCrGraphBarDirection = (bdHorizontal, bdVertical);
  TCrGraphColor  = (gcColor, gcMonochrome);
  TCrGraphLegend = (glNone, glUpperRight, glBottomCenter,
   glTopCenter, glRight, glLeft, glCustom);
  TCrGraphLegendLayout = (gllPercentage, gllAmount, gllCustom);
  TCrGraphPieSize = (gpsMinimum, gpsSmall, gpsAverage, gpsLarge, gpsMaximum);
  TCrGraphPieSlice = (gslNone, gslSmall, gslLarge);
  TCrGraphBarSize = (gbsMinimum, gbsSmall, gbsAverage, gbsLarge, gbsMaximum);
  TCrGraphMarkerSize = (gmsSmall, gmsMediumSmall, gmsMedium, gmsMediumLarge, gmsLarge);
  TCrGraphMarkerShape = (gshRectangle, gshCircle, gshDiamond, gshTriangle);
  TCrGraphDataPoints = (gdpNone, gdpShowLabel, gdpShowValue, gdpShowLabelValue);
  TCrGraphNumberFormat = (gnfNoDecimal, gnfOneDecimal, gnfTwoDecimal,
    gnfUnknownType, gnfCurrencyTwoDecimal, gnfPercentNoDecimal,
    gnfPercentOneDecimal, gnfPercentTwoDecimal,gnfOther);

  TCrGraphViewingAngle = (gvaStandard, gvaTall, gvaTop, gvaDistorted,
   gvaShort, gvaGroupEye, gvaGroupEmphasis, gvaFewSeries, gvaFewGroups,
   gvaDistortedStd, gvaThickGroups, gvaShorter, gvaThickSeries, gvaThickStd,
   gvaBirdsEye, gvaMax);

  {Mapping}
  TCrFieldMappingType = (fmAuto, fmPrompt, fmEvent);

  TCrFieldInfo = record
    TableName  : string;
    FieldName  : string;
    TableIndex : integer;
    FieldIndex : integer;
    FieldType  : TCrFieldValueType;
    FieldLength : integer;
  end;

{------------------------------------------------------------------------------}
{ Window Event Types                                                           }
{------------------------------------------------------------------------------}
  TCrStartEventDestination = (seNoWhere, seToWindow, seToPrinter,
    seToExport, seFromQuery);
  TCrStopEventJobStatus = (seUndefined, seNotStarted, seInProgress,
    seCompleted, seFailed, seCancelled, seHalted);
  TCrDrillDownType = (ddOnGroup, ddOnGroupTree, ddOnGraph,
    ddOnMap, ddOnSubreport);
  TCrpeGeneralPrintWindowEvent = procedure(WindowHandle: HWnd;
    var Cancel: Boolean) of object;
  TCrpeZoomLevelChangingEvent = procedure(WindowHandle: HWnd;
    ZoomLevel: Word; var Cancel: Boolean) of object;
  TCrpeCloseButtonClickedEvent = procedure(WindowHandle: HWnd;
    ViewIndex: Word; var Cancel: Boolean) of object;
  TCrpeSearchButtonClickedEvent = procedure(WindowHandle: HWnd;
    SearchString: string; var Cancel: Boolean) of object;
  TCrpeGroupTreeButtonClickedEvent = procedure(WindowHandle: HWnd;
    Visible: Boolean; var Cancel: Boolean) of object;
  TCrpeReadingRecordsEvent = procedure(Cancelled: Boolean;
    RecordsRead: LongInt; RecordsSelected: LongInt; Done: Boolean;
    var Cancel: Boolean) of object;
  TCrpeStartEvent = procedure(Destination: TCrStartEventDestination;
    var Cancel: Boolean) of object;
  TCrpeStopEvent = procedure(Destination:  TCrStartEventDestination;
    JobStatus: TCrStopEventJobStatus; var Cancel: Boolean) of object;
  TCrpeShowGroupEvent = procedure(WindowHandle: HWnd; NGroupLevel: Word;
    GroupList: TStringList; var Cancel: Boolean) of object;
  TCrpeDrillOnGroupEvent = procedure(WindowHandle: HWnd; NGroupLevel: Word;
    DrillType: TCrDrillDownType; GroupList: TStringList; var Cancel: Boolean) of object;
  TCrpeDrillOnDetailEvent = procedure(WindowHandle: HWnd; NSelectedField: Smallint;
    NFields: Smallint; FieldNames: TStringList; FieldValues: TStringList;
    var Cancel: Boolean) of object;
  TCrpeOnDrillHyperLinkEvent = procedure(WindowHandle: HWnd; HyperLinkText: string;
    var Cancel: Boolean) of object;
  TCrpeOnLaunchSeagateAnalysisEvent = procedure(WindowHandle: HWnd; FilePath: string;
    var Cancel: Boolean) of object;

{------------------------------------------------------------------------------}
{ Class ECrpeError                                                             }
{------------------------------------------------------------------------------}
   ECrpeError = class(Exception)
     ErrorNo : Integer;
     constructor Create(const nNo: Integer; const sMsg: string);
   end;

{------------------------------------------------------------------------------}
{ Class TCrFieldMappingInfo                                                    }
{------------------------------------------------------------------------------}
  TCrFieldMappingInfo = class(TPersistent)
  private
    FTableName : string;
    FFieldName : string;
    FFieldType : TCrFieldValueType;
    FMapTo     : integer;
  public
    property TableName : string
        read FTableName
       write FTableName;
    property FieldName : string
        read FFieldName
       write FFieldName;
    property FieldType : TCrFieldValueType
        read FFieldType
       write FFieldType;
    property MapTo : integer
        read FMapTo
       write FMapTo;
  end;
  TCrpeFieldMappingEvent = procedure(var ReportFields: TList;
    var DatabaseFields: TList; var Cancel: Boolean) of object;

{------------------------------------------------------------------------------}
{ Mouse Click Event Types                                                      }
{------------------------------------------------------------------------------}
  TCrMouseClickAction = (mbNotSupported, mbDown, mbUp, mbDoubleClick);
  TCrMouseClickType = (mcNone, mcLeft, mcRight, mcMiddle);

  TCrMouseInfo = record
    Action     : TCrMouseClickAction;
    Button     : TCrMouseClickType;
    ShiftKey   : Boolean;
    ControlKey : Boolean;
    x,y        : integer;
  end;

  TCrpeMouseClickEvent = procedure(WindowHandle: HWnd;
    MouseInfo: TCrMouseInfo; FieldValue: string;
    FieldType: TCrParamFieldType; Section: string;
    ObjectHandle: Hwnd; var Cancel: Boolean) of object;

{------------------------------------------------------------------------------}
{ Sub-Class forward definitions                                                }
{------------------------------------------------------------------------------}
  TCrpeAreaFormat = class;
  TCrpeAreaFormatItem = class;
  TCrpeConnect = class;
  TCrpeExportOptions = class;
  TCrpeFormulas = class;
  TCrpeFormulasItem = class;
  TCrpeGraphs = class;
  TCrpeGroups = class;
  TCrpeGroupSelection = class;
  TCrpeGroupSortFields = class;
  TCrpeLogOnInfo = class;
  TCrpeLogOnServer = class;
  TCrpeMargins = class;
  TCrpePages = class;
  TCrpeParamFields = class;
  TCrpeParamFieldsItem = class;
  TCrpePrintDate = class;
  TCrpePrinter = class;
  TCrpePrintOptions = class;
  TCrpeRecords = class;
  TCrpeGlobalOptions = class;
  TCrpeReportOptions = class;
  TCrpeSectionFont = class;
  TCrpeSectionFormat = class;
  TCrpeSectionFormatItem = class;
  TCrpeSectionSize = class;
  TCrpeSelection = class;
  TCrpeSessionInfo = class;
  TCrpeSortFields = class;
  TCrpeSQL = class;
  TCrpeSQLExpressions = class;
  TCrpeSQLExpressionsItem = class;
  TCrpeSubreports = class;
  TCrpeSubreportsItem = class;
  TCrpeSummaryInfo = class;
  TCrpeTables = class;
  TCrpeTablesItem = class;
  TCrpeVersion = class;
  TCrpeWindowButtonBar = class;
  TCrpeWindowCursor = class;
  TCrpeWindowSize = class;
  TCrpeWindowStyle = class;
  TCrpeWindowZoom = class;
  {Objects}
  TCrpeLines = class;
  TCrpeBoxes = class;
  TCrpePictures = class;
  TCrpeDatabaseFields = class;
  TCrpeSummaryFields = class;
  TCrpeSpecialFields = class;
  TCrpeGroupNameFields = class;
  TCrpeRunningTotals = class;
  TCrpeRunningTotalsItem = class;
  TCrpeTextObjects = class;
  TCrpeOleObjects = class;
  TCrpeCrossTabs = class;
  TCrpeMaps = class;
  TCrpeOLAPCubes = class;


{******************************************************************************}
{ TCrpe Class                                                                  }
{------------------------------------------------------------------------------}
{ The Delphi component to encapsulate the interface to the Print Engine.       }
{******************************************************************************}
  TCrpe = class(TComponentX)
  private
    FCrpeEngine       : TCrpeEngine; {Class for Print Engine functions}
    FPrintJob         : Smallint;
    FPrintJobs        : TStrings;
    {General}
    hDLL              : THandle; {Handle for CRPE32.DLL}
    FAbout            : TCrAboutBox;
    FTempPath         : string;
    FCrpeState        : TCrState;
    FDesignControls   : TCrDesignControls;
    FEngineOpened     : Boolean;
    FLoadEngineOnUse  : Boolean;
    FIgnoreKnownProblems : Boolean;  {Bypass known CRPE bugs by ignoring errors}
    FOutput           : TCrOutput;
    FProgressDialog   : Boolean;
    FReportName       : TCrReportName;
    FReportTitle      : string;
    FDetailCopies     : Smallint;
    FFormulaSyntax    : TCrFormulaSyntax;
    FReportStyle      : TCrReportStyle;
    {Error}
    FLastErrorNumber  : Smallint;
    FLastErrorString  : string;
    {Events}
    FOnJobOpened       : TCrpeJobNumEvent;
    FOnExecuteBegin    : TCrpeCancelEvent;
    FOnExecuteDoneSend : TCrpeCancelEvent;
    FOnCreate          : TNotifyEvent;
    FOnDestroy         : TNotifyEvent;
    FOnExecuteEnd      : TNotifyEvent;
    FOnWindowClose     : TNotifyEvent;
    FOnPrintEnded      : TNotifyEvent;
    FOnPrinterSend     : TCrpePrinterEvent;
    FOnGetVersion      : TCrpeVersionEvent;
    FOnError           : TCrpeErrorEvent;
    FOnFieldMapping    : TCrpeFieldMappingEvent;
    {WindowEvents}
    FWindowEvents            : Boolean;
    FwOnCloseWindow          : TCrpeGeneralPrintWindowEvent;
    FwOnPrintBtnClick        : TCrpeGeneralPrintWindowEvent;
    FwOnExportBtnClick       : TCrpeGeneralPrintWindowEvent;
    FwOnFirstPageBtnClick    : TCrpeGeneralPrintWindowEvent;
    FwOnPreviousPageBtnClick : TCrpeGeneralPrintWindowEvent;
    FwOnNextPageBtnClick     : TCrpeGeneralPrintWindowEvent;
    FwOnLastPageBtnClick     : TCrpeGeneralPrintWindowEvent;
    FwOnCancelBtnClick       : TCrpeGeneralPrintWindowEvent;
    FwOnActivateWindow       : TCrpeGeneralPrintWindowEvent;
    FwOnDeActivateWindow     : TCrpeGeneralPrintWindowEvent;
    FwOnPrintSetupBtnClick   : TCrpeGeneralPrintWindowEvent;
    FwOnRefreshBtnClick      : TCrpeGeneralPrintWindowEvent;
    FwOnZoomLevelChange      : TCrpeZoomLevelChangingEvent;
    FwOnCloseBtnClick        : TCrpeCloseButtonClickedEvent;
    FwOnSearchBtnClick       : TCrpeSearchButtonClickedEvent;
    FwOnGroupTreeBtnClick    : TCrpeGroupTreeButtonClickedEvent;
    FwOnReadingRecords       : TCrpeReadingRecordsEvent;
    FwOnStartEvent           : TCrpeStartEvent;
    FwOnStopEvent            : TCrpeStopEvent;
    FwOnShowGroup            : TCrpeShowGroupEvent;
    FwOnDrillGroup           : TCrpeDrillOnGroupEvent;
    FwOnDrillDetail          : TCrpeDrillOnDetailEvent;
    FwOnMouseClick           : TCrpeMouseClickEvent;
    FwOnDrillHyperLink       : TCrpeOnDrillHyperLinkEvent;
    FwOnLaunchSeagateAnalysis : TCrpeOnLaunchSeagateAnalysisEvent;
    FExportOptions     : TCrpeExportOptions;
    FVersion           : TCrpeVersion;
    FPrintDate         : TCrpePrintDate;
    FSubreports        : TCrpeSubreports;
    FLogOnServer       : TCrpeLogOnServer;
    FRecords           : TCrpeRecords;
    FPages             : TCrpePages;
    {Printer}
    FPrinter           : TCrpePrinter;
    FPrintOptions      : TCrpePrintOptions;
    FSummaryInfo       : TCrpeSummaryInfo;
    FReportOptions     : TCrpeReportOptions;
    FGlobalOptions     : TCrpeGlobalOptions;
    {Window Handles}
    FParentFormHandle  : hWnd;
    FDialogParent      : TCrWinControl;
    FWindowParent      : TCrWinControl;
    {Window classes}
    FWindowButtonBar   : TCrpeWindowButtonBar;
    FWindowCursor      : TCrpeWindowCursor;
    FWindowSize        : TCrpeWindowSize;
    FWindowState       : TWindowState;
    FWindowStyle       : TCrpeWindowStyle;
    FWindowZoom        : TCrpeWindowZoom;
    FMargins           : TCrpeMargins;
    {SQL}
    FSQL               : TCrpeSQL;
    FSQLExpressions    : TCrpeSQLExpressions;
    FConnect           : TCrpeConnect;
    FLogOnInfo         : TCrpeLogonInfo;
    {Formulas}
    FFormulas          : TCrpeFormulas;
    FSelection         : TCrpeSelection;
    FGroupSelection    : TCrpeGroupSelection;
    {Group/Sort}
    FSortFields        : TCrpeSortFields;
    FGroupSortFields   : TCrpeGroupSortFields;
    FGroups            : TCrpeGroups;
    FTables            : TCrpeTables;
    FSessionInfo       : TCrpeSessionInfo;
    {Section/Area Format}
    FSectionFormat     : TCrpeSectionFormat;
    FAreaFormat        : TCrpeAreaFormat;
    FSectionFont       : TCrpeSectionFont;
    FSectionSize       : TCrpeSectionSize;
    FParamFields       : TCrpeParamFields;
    FGraphs            : TCrpeGraphs;
    {Objects}
    FLines             : TCrpeLines;
    FBoxes             : TCrpeBoxes;
    FPictures          : TCrpePictures;
    FTextObjects       : TCrpeTextObjects;
    FOleObjects        : TCrpeOleObjects;
    FCrossTabs         : TCrpeCrossTabs;
    FMaps              : TCrpeMaps;
    FOLAPCubes         : TCrpeOLAPCubes;
    {Field Objects}
    FDatabaseFields    : TCrpeDatabaseFields;
    FSummaryFields     : TCrpeSummaryFields;
    FSpecialFields     : TCrpeSpecialFields;
    FGroupNameFields   : TCrpeGroupNameFields;
    FRunningTotals     : TCrpeRunningTotals;
  protected
    {General}
    procedure SetTempPath (TempPath: string);
    function  GetDetailCopies: Smallint;
    procedure SetDetailCopies(const Value: Smallint);
    procedure SetProgressDialog(const Value: Boolean);
    procedure SetReportName(NewName: string);
    function  GetReportTitle: string;
    procedure SetReportTitle(const Value: string);
    function  GetFormulaSyntax : TCrFormulaSyntax;
    procedure SetFormulaSyntax(const Value: TCrFormulaSyntax);
    function  GetReportStyle : TCrReportStyle;
    procedure SetReportStyle(const Value: TCrReportStyle);
    {Engine}
    procedure Loaded; override;
    procedure GetCRPEVersion;
    function  OpenPrintEngine : Boolean;
    procedure ClosePrintEngine;
    function  OpenPrintJob : Boolean;
    procedure ClosePrintJob;
    {Window}
    function  GetWindowParent : TCrWinControl;
    procedure SetWindowParent (const Value: TCrWinControl);
    function  GetDialogParent : TCrWinControl;
    procedure SetDialogParent (const Value : TCrWinControl);
    function  PreviewWindowStyle : integer;
    function  GetWindowState : TWindowState;
    procedure SetWindowState (const Value : TWindowState);
    {Section}
    function  GetSectionCodes(JobNum: Smallint; var slNCodes: TStringList;
      var slSCodes: TStringList; bArea: Boolean): Boolean;
    {Object functions}
    function  GetFieldTypeFromName (FieldName: string): TCrFieldValueType;
  {These properties appear on the Object Inspector}
  published
    {General}
    property About : TCrAboutBox
        read FAbout
       write FAbout;
    property DesignControls : TCrDesignControls
        read FDesignControls
       write FDesignControls;
    property Version : TCrpeVersion
        read FVersion
       write FVersion;
    property ReportName : TCrReportName
        read FReportName
       write SetReportName;
    property TempPath : string
        read FTempPath
       write SetTempPath;
    property Output : TCrOutput
        read FOutput
       write FOutput
     default toWindow;
    property ReportTitle : string
        read GetReportTitle
       write SetReportTitle;
    property DetailCopies : Smallint
        read GetDetailCopies
       write SetDetailCopies
     default 1;
    property Margins : TCrpeMargins
        read FMargins
       write FMargins;
    property ProgressDialog : Boolean
        read FProgressDialog
       write SetProgressDialog
     default True;
    property LoadEngineOnUse : Boolean
        read FLoadEngineOnUse
       write FLoadEngineOnUse
     default False;
    property FormulaSyntax : TCrFormulaSyntax
        read GetFormulaSyntax
       write SetFormulaSyntax
     default fsCrystal;
    property ReportStyle : TCrReportStyle
        read GetReportStyle
       write SetReportStyle
     default rsStandard;

    {Events}
    property OnCreate : TNotifyEvent
        read FOnCreate
       write FOnCreate;
    property OnDestroy : TNotifyEvent
        read FOnDestroy
       write FOnDestroy;
    property OnExecuteBegin : TCrpeCancelEvent
        read FOnExecuteBegin
       write FOnExecuteBegin;
    property OnJobOpened : TCrpeJobNumEvent
        read FOnJobOpened
       write FOnJobOpened;
    property OnExecuteDoneSend : TCrpeCancelEvent
        read FOnExecuteDoneSend
       write FOnExecuteDoneSend;
    property OnExecuteEnd : TNotifyEvent
        read FOnExecuteEnd
       write FOnExecuteEnd;
    property OnWindowClose : TNotifyEvent
        read FOnWindowClose
       write FOnWindowClose;
    property OnPrintEnded: TNotifyEvent
        read FOnPrintEnded
       write FOnPrintEnded;
    property OnPrinterSend: TCrpePrinterEvent
        read FOnPrinterSend
       write FOnPrinterSend;
    property OnGetVersion: TCrpeVersionEvent
        read FOnGetVersion
       write FOnGetVersion;
    property OnError: TCrpeErrorEvent
        read FOnError
       write FOnError;

    {WindowEvents}
    property WindowEvents: Boolean
        read FWindowEvents
       write FWindowEvents
     default False;
    property wOnCloseWindow : TCrpeGeneralPrintWindowEvent
        read FwOnCloseWindow
       write FwOnCloseWindow;
    property wOnPrintBtnClick : TCrpeGeneralPrintWindowEvent
        read FwOnPrintBtnClick
       write FwOnPrintBtnClick;
    property wOnExportBtnClick : TCrpeGeneralPrintWindowEvent
        read FwOnExportBtnClick
       write FwOnExportBtnClick;
    property wOnFirstPageBtnClick : TCrpeGeneralPrintWindowEvent
        read FwOnFirstPageBtnClick
       write FwOnFirstPageBtnClick;
    property wOnPreviousPageBtnClick : TCrpeGeneralPrintWindowEvent
        read FwOnPreviousPageBtnClick
       write FwOnPreviousPageBtnClick;
    property wOnNextPageBtnClick : TCrpeGeneralPrintWindowEvent
        read FwOnNextPageBtnClick
       write FwOnNextPageBtnClick;
    property wOnLastPageBtnClick : TCrpeGeneralPrintWindowEvent
        read FwOnLastPageBtnClick
       write FwOnLastPageBtnClick;
    property wOnCancelBtnClick : TCrpeGeneralPrintWindowEvent
        read FwOnCancelBtnClick
       write FwOnCancelBtnClick;
    property wOnActivateWindow : TCrpeGeneralPrintWindowEvent
        read FwOnActivateWindow
       write FwOnActivateWindow;
    property wOnDeActivateWindow : TCrpeGeneralPrintWindowEvent
        read FwOnDeActivateWindow
       write FwOnDeActivateWindow;
    property wOnPrintSetupBtnClick : TCrpeGeneralPrintWindowEvent
        read FwOnPrintSetupBtnClick
       write FwOnPrintSetupBtnClick;
    property wOnRefreshBtnClick : TCrpeGeneralPrintWindowEvent
        read FwOnRefreshBtnClick
       write FwOnRefreshBtnClick;
    property wOnZoomLevelChange : TCrpeZoomLevelChangingEvent
        read FwOnZoomLevelChange
       write FwOnZoomLevelChange;
    property wOnCloseBtnClick : TCrpeCloseButtonClickedEvent
        read FwOnCloseBtnClick
       write FwOnCloseBtnClick;
    property wOnSearchBtnClick : TCrpeSearchButtonClickedEvent
        read FwOnSearchBtnClick
       write FwOnSearchBtnClick;
    property wOnGroupTreeBtnClick : TCrpeGroupTreeButtonClickedEvent
        read FwOnGroupTreeBtnClick
       write FwOnGroupTreeBtnClick;
    property wOnReadingRecords : TCrpeReadingRecordsEvent
        read FwOnReadingRecords
       write FwOnReadingRecords;
    property wOnStartEvent : TCrpeStartEvent
        read FwOnStartEvent
       write FwOnStartEvent;
    property wOnStopEvent : TCrpeStopEvent
        read FwOnStopEvent
       write FwOnStopEvent;
    property wOnShowGroup : TCrpeShowGroupEvent
        read FwOnShowGroup
       write FwOnShowGroup;
    property wOnDrillGroup : TCrpeDrillOnGroupEvent
        read FwOnDrillGroup
       write FwOnDrillGroup;
    property wOnDrillDetail : TCrpeDrillOnDetailEvent
        read FwOnDrillDetail
       write FwOnDrillDetail;
    property OnFieldMapping : TCrpeFieldMappingEvent
        read FOnFieldMapping
       write FOnFieldMapping;
    property wOnMouseClick : TCrpeMouseClickEvent
        read FwOnMouseClick
       write FwOnMouseClick;
    property wOnDrillHyperLink : TCrpeOnDrillHyperLinkEvent
        read FwOnDrillHyperLink
       write FwOnDrillHyperLink;
    property wOnLaunchSeagateAnalysis : TCrpeOnLaunchSeagateAnalysisEvent
        read FwOnLaunchSeagateAnalysis
       write FwOnLaunchSeagateAnalysis;
    {PrintDate}
    property PrintDate : TCrpePrintDate
        read FPrintDate
       write FPrintDate;
    {Subreports}
    property Subreports : TCrpeSubreports
        read FSubreports
       write FSubreports;
    {Tables}
    property Tables : TCrpeTables
        read FTables
       write FTables;
    {Sorting}
    property SortFields : TCrpeSortFields
        read FSortFields
       write FSortFields;
    property GroupSortFields : TCrpeGroupSortFields
        read FGroupSortFields
       write FGroupSortFields;
    property Groups : TCrpeGroups
        read FGroups
       write FGroups;
    {Formulas}
    property ParamFields : TCrpeParamFields
        read FParamFields
       write FParamFields;
    property Formulas : TCrpeFormulas
        read FFormulas
       write FFormulas;
    property GroupSelection : TCrpeGroupSelection
        read FGroupSelection
       write FGroupSelection;
    property Selection : TCrpeSelection
        read FSelection
       write FSelection;
    {Sections}
    property SectionFormat : TCrpeSectionFormat
        read FSectionFormat
       write FSectionFormat;
    property AreaFormat : TCrpeAreaFormat
        read FAreaFormat
       write FAreaFormat;
    property SectionFont : TCrpeSectionFont
        read FSectionFont
       write FSectionFont;
    property SectionSize : TCrpeSectionSize
        read FSectionSize
       write FSectionSize;
    {SQL}
    property Connect : TCrpeConnect
        read FConnect
       write FConnect;
    property SQL : TCrpeSQL
        read FSQL
       write FSQL;
    property SQLExpressions : TCrpeSQLExpressions
        read FSQLExpressions
       write FSQLExpressions;
    property LogOnInfo : TCrpeLogonInfo
        read FLogOnInfo
       write FLogOnInfo;
    property LogOnServer : TCrpeLogOnServer
        read FLogOnServer
       write FLogOnServer;
    {MSAccess SessionInfo}
    property SessionInfo : TCrpeSessionInfo
        read FSessionInfo
       write FSessionInfo;
    {Export}
    property ExportOptions : TCrpeExportOptions
        read FExportOptions
       write FExportOptions;
    {Printer}
    property Printer : TCrpePrinter
        read FPrinter
       write FPrinter;
    property PrintOptions : TCrpePrintOptions
        read FPrintOptions
       write FPrintOptions;
    {Lines}
    property Lines : TCrpeLines
        read FLines
       write FLines;
    {Boxes}
    property Boxes : TCrpeBoxes
        read FBoxes
       write FBoxes;
    {Pictures}
    property Pictures : TCrpePictures
        read FPictures
       write FPictures;
    {Text Objects}
    property TextObjects : TCrpeTextObjects
        read FTextObjects
       write FTextObjects;
    {Ole Objects}
    property OleObjects : TCrpeOleObjects
        read FOleObjects
       write FOleObjects;
    {CrossTabs}
    property CrossTabs : TCrpeCrossTabs
        read FCrossTabs
       write FCrossTabs;
    {Maps}
    property Maps : TCrpeMaps
        read FMaps
       write FMaps;
    {OLAPCubes}
    property OLAPCubes : TCrpeOLAPCubes
        read FOLAPCubes
       write FOLAPCubes;
    {Field Objects}
    property DatabaseFields : TCrpeDatabaseFields
        read FDatabaseFields
       write FDatabaseFields;
    property SummaryFields : TCrpeSummaryFields
        read FSummaryFields
       write FSummaryFields;
    property SpecialFields : TCrpeSpecialFields
        read FSpecialFields
       write FSpecialFields;
    property GroupNameFields : TCrpeGroupNameFields
        read FGroupNameFields
       write FGroupNameFields;
    property RunningTotals : TCrpeRunningTotals
        read FRunningTotals
       write FRunningTotals;
    {WindowZoom}
    property WindowZoom : TCrpeWindowZoom
        read FWindowZoom
       write FWindowZoom;
    {Window Style}
    property WindowStyle : TCrpeWindowStyle
        read FWindowStyle
       write FWindowStyle;
    {Window State}
    property WindowState : TWindowState
        read GetWindowState
       write SetWindowState
     default wsNormal;
    {Window Size}
    property WindowSize : TCrpeWindowSize
        read FWindowSize
       write FWindowSize;
    {Window Buttons}
    property WindowButtonBar : TCrpeWindowButtonBar
        read FWindowButtonBar
       write FWindowButtonBar;
    {Window Cursor}
    property WindowCursor : TCrpeWindowCursor
        read FWindowCursor
       write FWindowCursor;
    {Window Parent}
    property WindowParent: TCrWinControl
        read GetWindowParent
       write SetWindowParent;
    {DialogParent}
    property DialogParent: TCrWinControl
        read GetDialogParent
       write SetDialogParent;
    {Graphs}
    property Graphs : TCrpeGraphs
        read FGraphs
       write FGraphs;
    {SummaryInfo}
    property SummaryInfo : TCrpeSummaryInfo
        read FSummaryInfo
       write FSummaryInfo;
    {ReportOptions}
    property ReportOptions : TCrpeReportOptions
        read FReportOptions
       write FReportOptions;
    {GlobalOptions}
    property GlobalOptions : TCrpeGlobalOptions
        read FGlobalOptions
       write FGlobalOptions;
  {These properties are runtime only; ie. not on the Object Inspector}
  public
    property IgnoreKnownProblems : Boolean
        read FIgnoreKnownProblems
       write FIgnoreKnownProblems
     default True;
    {CRPE function calls class}
    property CrpeEngine: TCrpeEngine
        read FCrpeEngine;
    {Error}
    property LastErrorNumber: Smallint
        read FLastErrorNumber
       write FLastErrorNumber
     default 0;
    property LastErrorString: string
        read FLastErrorString
       write FLastErrorString;
    {Pages}
    property Pages : TCrpePages
        read FPages
       write FPages;
    {Records}
    property Records : TCrpeRecords
        read FRecords
       write FRecords;
   function  PrintJobs (ReportNumber: integer): Smallint;
   function  SectionCodeToStringEx (SectionCode: Smallint; bArea: Boolean): string;
   {Objects}
   function  GetNObjects (ObjectType: TCrObjectType;
      ObjectFieldType: TCrFieldObjectType): Integer;
   function  GetObjectHandle (SubObjectN: Smallint; ObjectType: TCrObjectType;
      FieldObjectType: TCrFieldObjectType): DWord;
   function  GetFieldObjectHandle (FieldName: string;
      FieldObjectType: TCrFieldObjectType; var Index: integer): DWord;
    {Errors}
   function  BuildErrorString (Source: TCrpePersistent): string;
   function  GetErrorMsg (nJob: Word; Option: TCrErrorOption;
      ErrType: TCrError; ErrConst: string; ErrString: string): TCrErrorResult;
   function  StatusIsGo (nIndex: integer): Boolean;
   {Formulas}
   function  ConvertFormulaName (FName: TCrFormatFormulaName): Smallint;
   {SQL}
   function  LogOnPrivateInfo(DllName: string; PrivateInfo: pointer): Boolean;
   {ByName functions}
   function  FormulaByName (FormulaName: string): TCrpeFormulasItem;
   function  ParamByName (ParamFieldName: string; ReportName: string): TCrpeParamFieldsItem;
   function  RunningTotalByName (RunningTotalName: string): TCrpeRunningTotalsItem;
   function  SQLExpressionByName (ExpressionName: string): TCrpeSQLExpressionsItem;
   function  SubreportByName (SubreportName: string): TCrpeSubreportsItem;
   function  TableByName (AliasName: string): TCrpeTablesItem;
   function  SectionFormatByName (SectionName: string): TCrpeSectionFormatItem;
   function  AreaFormatByName (AreaName: string): TCrpeAreaFormatItem;
   {Window}
   function  Focused : Boolean;
   procedure SetFocus;
   function  ReportWindowHandle: HWnd;
   procedure CloseWindow;
   procedure PrintWindow;
   procedure ExportWindow (bMail: Boolean);
   procedure HideWindow;
   procedure ShowWindow;
   procedure Search (SearchText: string);
   {Utility}
   function  FieldNameToFieldInfo (FieldName: string): TCrFieldInfo;
   function  FieldInfoToFieldName (FieldInfo: TCrFieldInfo): string;
   {Send procedures}
   function  SendOutput : Boolean;
   {Status}
   function  Status : TCrStatus;
   function  IsJobFinished  : Boolean;
   function  CanCloseEngine : Boolean;
   function  PrintEnded : Boolean;
   {Engine}
   function  LoadEngine : Boolean;
   function  OpenEngine : Boolean;
   procedure CloseEngine;
   procedure UnloadEngine;
   function  EngineOpen : Boolean;
   {PrintJob}
   function  OpenJob : Boolean;
   function  JobIsOpen : Boolean;
   procedure CloseJob;
   procedure CancelJob;
   procedure Refresh;
   function  JobNumber : Smallint;
   {Run Report}
   function  Execute : Boolean;
   function  Show : Boolean;
   function  Print : Boolean;
   function  Export : Boolean;
   {General}
   function  CrpeHandle : THandle;
   function  Save (filePath: string): Boolean;
   function  SaveAs (filePath: string): Boolean;
   function  HasSavedData : Boolean;
   function  DiscardSavedData : Boolean;
   procedure Clear;
   {Constructor/Destructor}
   constructor Create (AOwner: TComponent); override;
   destructor Destroy; override;
  end; { Class TCrpe Declaration }



TCrpeCrossTabSummaries = class;
TCrpeGraphsItem = class;
TCrpeMapSummaryFields = class;
TCrpeTabStops = class;
TCrpeParagraphs = class;
TCrpeEmbeddedFields = class;

  TCrpePersistentX = class(TCrpePersistent)
  private
  protected
  published
  public
    function Cr: TCrpe;
  end;

  TCrpeItemX = class(TCrpeItem)
  private
  protected
  published
  public
    function Cr: TCrpe;
  end;

  TCrpeContainerX = class(TCrpeContainer)
  private
  protected
  published
  public
    function Cr: TCrpe;
  end;

  TCrpeObjectItemAX = class(TCrpeObjectItemA)
  private
  protected
  published
  public
    function Cr: TCrpe;
  end;

  TCrpeObjectContainerAX = class(TCrpeObjectContainerA)
  private
  protected
  published
  public
    function Cr: TCrpe;
  end;

  TCrpeObjectItemBX = class(TCrpeObjectItemB)
  private
  protected
  published
  public
    function Cr: TCrpe;
  end;

  TCrpeObjectContainerBX = class(TCrpeObjectContainerB)
  private
  protected
  published
  public
    function Cr: TCrpe;
  end;

  TCrpeFieldObjectItemX = class(TCrpeFieldObjectItem)
  private
  protected
  published
  public
    function Cr: TCrpe;
  end;

  TCrpeFieldObjectContainerX = class(TCrpeFieldObjectContainer)
  private
  protected
  published
  public
    function Cr: TCrpe;
  end;

{------------------------------------------------------------------------------}
{ Class TCrpeAreaFormatFormulas                                                }
{------------------------------------------------------------------------------}
   TCrpeAreaFormatFormulas = class(TCrpePersistentX)
   private
     FSuppress            : TStrings;
     FHide                : TStrings;
     FNewPageBefore       : TStrings;
     FNewPageAfter        : TStrings;
     FKeepTogether        : TStrings;
     FResetPageNAfter     : TStrings;
     FPrintAtBottomOfPage : TStrings;
     xFormula             : TStrings;
   protected
     function  GetSuppress : TStrings;
     procedure SetSuppress (const Value: TStrings);
     function  GetHide : TStrings;
     procedure SetHide (const Value: TStrings);
     function  GetNewPageBefore : TStrings;
     procedure SetNewPageBefore (const Value: TStrings);
     function  GetNewPageAfter : TStrings;
     procedure SetNewPageAfter (const Value: TStrings);
     function  GetKeepTogether : TStrings;
     procedure SetKeepTogether (const Value: TStrings);
     function  GetResetPageNAfter : TStrings;
     procedure SetResetPageNAfter (const Value: TStrings);
     function  GetPrintAtBottomOfPage : TStrings;
     procedure SetPrintAtBottomOfPage (const Value: TStrings);
     {OnChange StringList methods}
     procedure OnChangeSuppress (Sender: TObject);
     procedure OnChangeHide (Sender: TObject);
     procedure OnChangeNewPageBefore (Sender: TObject);
     procedure OnChangeNewPageAfter (Sender: TObject);
     procedure OnChangeKeepTogether (Sender: TObject);
     procedure OnChangeResetPageNAfter (Sender: TObject);
     procedure OnChangePrintAtBottomOfPage (Sender: TObject);
   published
     property Hide : TStrings
         read GetHide
        write SetHide;
     property NewPageBefore : TStrings
         read GetNewPageBefore
        write SetNewPageBefore;
     property NewPageAfter : TStrings
         read GetNewPageAfter
        write SetNewPageAfter;
     property KeepTogether : TStrings
         read GetKeepTogether
        write SetKeepTogether;
     property ResetPageNAfter : TStrings
         read GetResetPageNAfter
        write SetResetPageNAfter;
     property PrintAtBottomOfPage : TStrings
         read GetPrintAtBottomOfPage
        write SetPrintAtBottomOfPage;
     property Suppress : TStrings
         read GetSuppress
        write SetSuppress;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeAreaFormatFormulas }


{------------------------------------------------------------------------------}
{ Class TCrpeAreaFormatItem                                                    }
{------------------------------------------------------------------------------}
  TCrpeAreaFormatItem = class(TCrpeItemX)
  private
    FArea                 : string;
    FHide                 : Boolean;
    FNewPageBefore        : Boolean;
    FNewPageAfter         : Boolean;
    FKeepTogether         : Boolean;
    FResetPageNAfter      : Boolean;
    FPrintAtBottomOfPage  : Boolean;
    FSuppress             : Boolean;
    FFormulas             : TCrpeAreaFormatFormulas;
    FNSections            : Smallint;
    FReserveMinimumPageFooter : Boolean;
  protected
    procedure SetArea (const Value: string);
    procedure SetHide (const Value: Boolean);
    procedure SetNewPageBefore (const Value: Boolean);
    procedure SetNewPageAfter (const Value: Boolean);
    procedure SetKeepTogether (const Value: Boolean);
    procedure SetResetPageNAfter (const Value: Boolean);
    procedure SetPrintAtBottomOfPage (const Value: Boolean);
    procedure SetSuppress (const Value: Boolean);
    procedure SetNSections (const Value: Smallint);
    procedure SetReserveMinimumPageFooter (const Value: Boolean);
  published
    property Area : string
        read FArea
       write SetArea;
    property Hide : Boolean
        read FHide
       write SetHide
     default False;
    property NewPageBefore : Boolean
        read FNewPageBefore
       write SetNewPageBefore
     default False;
    property NewPageAfter : Boolean
        read FNewPageAfter
       write SetNewPageAfter
     default False;
    property KeepTogether : Boolean
        read FKeepTogether
       write SetKeepTogether
     default False;
    property ResetPageNAfter : Boolean
        read FResetPageNAfter
       write SetResetPageNAfter
     default False;
    property PrintAtBottomOfPage : Boolean
        read FPrintAtBottomOfPage
       write SetPrintAtBottomOfPage
     default False;
    property Suppress : Boolean
        read FSuppress
       write SetSuppress
     default False;
    property Formulas : TCrpeAreaFormatFormulas
        read FFormulas
       write FFormulas;
    property NSections : Smallint
        read FNSections
       write SetNSections;
    property ReserveMinimumPageFooter : Boolean
        read FReserveMinimumPageFooter
       write SetReserveMinimumPageFooter
     default False;
  public
    function  AreaAsCode : Smallint;
    function  AreaType : string;
    procedure Assign(Source: TPersistent); override;
    procedure Clear;
    constructor Create;
    destructor  Destroy; override;
  end; { Class TCrpeAreaFormatItem }

{------------------------------------------------------------------------------}
{ Class TCrpeAreaFormat                                                        }
{------------------------------------------------------------------------------}
  TCrpeAreaFormat = class(TCrpeContainerX)
  private
    FArea  : string;
    FAreas : TStrings;
    FItem  : TCrpeAreaFormatItem;
  protected
    procedure SetArea (const Value: TCrLookupString);
    function  GetAreaAsCode: Smallint;
    procedure SetAreaAsCode (const nArea: Smallint);
    procedure SetIndex (nIndex: integer);
    function  GetItem(nIndex: integer) : TCrpeAreaFormatItem;
  published
    property Number : TCrLookupNumber
        read FIndex
       write SetIndex
     default -1;
    property Area : TCrLookupString
        read FArea
       write SetArea;
    property AreaAsCode : Smallint
        read GetAreaAsCode
       write SetAreaAsCode
     default 0;
    property Item : TCrpeAreaFormatItem
        read FItem
       write FItem;
  public
    property ItemIndex : integer
        read FIndex
       write SetIndex;
    property Items[nIndex: integer]: TCrpeAreaFormatItem
        read GetItem; default;
    function  Names : TStrings; {read only - list of Area Names}
    function  AreaType : string;
    function  Count: integer; override;
{    procedure Assign(Source: TPersistent); override;}
    procedure Clear;
    function  IndexOf (AreaName: string): integer;
    function  ByName (AreaName: string): TCrpeAreaFormatItem;
    constructor Create;
    destructor  Destroy; override;
  end; { Class TCrpeAreaFormat }

{------------------------------------------------------------------------------}
{ Class TCrpeBoxesItem                                                         }
{------------------------------------------------------------------------------}
   TCrpeBoxesItem = class(TCrpeItemX)
   private
      FTop          : LongInt;
      FBottom       : LongInt;
      FLeft         : LongInt;
      FRight        : LongInt;
      FSectionStart : string;
      FSectionEnd   : string;
      FBorderStyle  : TCrLineStyle;
      FBorderWidth  : LongInt;
      FBorderColor  : TColor;
      FDropShadow   : Boolean;
      FFillColor    : TColor;
      FCloseBorder  : Boolean; {Close Border on Page Break}
      FExtend       : Boolean; {extend to bottom of section when printing}
      FSuppress     : Boolean;
      FCornerRoundingHeight : LongInt;
      FCornerRoundingWidth  : LongInt;
   protected
      procedure SetTop (const Value: LongInt);
      procedure SetBottom (const Value: LongInt);
      procedure SetLeft (const Value: LongInt);
      procedure SetRight (const Value: LongInt);
      procedure SetSectionStart (const Value: string);
      procedure SetSectionEnd (const Value: string);
      procedure SetBorderStyle (const Value: TCrLineStyle);
      procedure SetBorderWidth (const Value: LongInt);
      procedure SetBorderColor (const Value: TColor);
      procedure SetDropShadow (const Value: Boolean);
      procedure SetFillColor (const Value: TColor);
      procedure SetCloseBorder (const Value: Boolean);
      procedure SetExtend (const Value: Boolean);
      procedure SetSuppress (const Value: Boolean);
      procedure SetCornerRoundingHeight (const Value: LongInt);
      procedure SetCornerRoundingWidth (const Value: LongInt);
   published
      property Top : LongInt
          read FTop
         write SetTop
       default -1;
      property Bottom : LongInt
          read FBottom
         write SetBottom
       default -1;
      property Left : LongInt
          read FLeft
         write SetLeft
       default -1;
      property Right : LongInt
          read FRight
         write SetRight
       default -1;
      property SectionStart : string
          read FSectionStart
         write SetSectionStart;
      property SectionEnd : string
          read FSectionEnd
         write SetSectionEnd;
      property BorderStyle : TCrLineStyle
          read FBorderStyle
         write SetBorderStyle
       default lsNone;
      property BorderWidth : LongInt
          read FBorderWidth
         write SetBorderWidth
       default -1;
      property BorderColor : TColor
          read FBorderColor
         write SetBorderColor
       default clBlack;
      property DropShadow : Boolean
          read FDropShadow
         write SetDropShadow
       default False;
      property FillColor : TColor
          read FFillColor
         write SetFillColor
       default clNone;
      property CloseBorder : Boolean
          read FCloseBorder
         write SetCloseBorder
       default True;
      property Extend : Boolean
          read FExtend
         write SetExtend
       default False;
      property Suppress : Boolean
          read FSuppress
         write SetSuppress
       default False;
      property CornerRoundingHeight : LongInt
          read FCornerRoundingHeight
         write SetCornerRoundingHeight
       default -1;
      property CornerRoundingWidth : LongInt
          read FCornerRoundingWidth
         write SetCornerRoundingWidth
       default -1;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     function  StatusIsGo: Boolean;
     constructor Create;
   end; { Class TCrpeBoxesItem }

{------------------------------------------------------------------------------}
{ Class TCrpeBoxes                                                             }
{------------------------------------------------------------------------------}
   TCrpeBoxes = class(TCrpeContainerX)
   private
     FItem : TCrpeBoxesItem;
   protected
     procedure SetIndex (nIndex: integer);
     function  GetItem (nIndex: integer) : TCrpeBoxesItem;
   published
     property Number : TCrLookupNumber
         read FIndex
        write SetIndex;
     property Item : TCrpeBoxesItem
         read FItem
        write FItem;
   public
     property ItemIndex : integer
         read FIndex
        write SetIndex;
     property Items[nIndex: integer]: TCrpeBoxesItem
         read GetItem; default;
{     procedure Assign(Source: TPersistent); override;}
     procedure Clear;
     function  Count : integer; override;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeBoxes }

{------------------------------------------------------------------------------}
{ Class TCrpeConnect                                                           }
{------------------------------------------------------------------------------}
   TCrpeConnect = class(TCrpePersistentX)
   private
     FServerName   : string;
     FUserID       : string;
     FPassword     : string;
     FDatabaseName : string;
     FPropagate    : Boolean;
   protected
     function  GetServerName : string;
     procedure SetServerName (const Value: string);
     function  GetUserID : string;
     procedure SetUserID (const Value: string);
     function  GetPassword : string;
     procedure SetPassword (const Value: string);
     function  GetDatabaseName : string;
     procedure SetDatabaseName (const Value: string);
     procedure SetPropagate (const Value: Boolean);
   published
      property ServerName : string
          read GetServerName
         write SetServerName;
      property UserID : string
          read GetUserID
         write SetUserID;
      property Password : string
          read GetPassword
         write SetPassword;
      property DatabaseName : string
          read GetDatabaseName
         write SetDatabaseName;
      property Propagate : Boolean
          read FPropagate
         write SetPropagate
       default False;
   public
     function  Test : Boolean;
     procedure Clear;
     constructor Create;
   end; { Class TCrpeConnect Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeCrossTabSummariesItem                                             }
{------------------------------------------------------------------------------}
  TCrpeCrossTabSummariesItem = class(TCrpeItemX)
  private
    FSummarizedField  : string;
    FFieldType        : TCrFieldValueType;
    FFieldLength      : Word;
    {SummaryType properties}
    FSummaryType      : TCrSummaryType;
    FSummaryTypeN     : Smallint; {Only applies to certain SummaryTypes, ie. stPercentage}
    FSummaryTypeField : string;   {Only applies to certain SummaryTypes, ie. stCorrelation}
  protected
    procedure SetSummarizedField(const Value: string);
    procedure SetFieldType(const Value: TCrFieldValueType);
    procedure SetFieldLength(const Value: Word);
    procedure SetSummaryType(const Value: TCrSummaryType);
    procedure SetSummaryTypeN(const Value: Smallint);
    procedure SetSummaryTypeField(const Value: string);
  published
    property SummarizedField : string
        read FSummarizedField
       write SetSummarizedField;
    property FieldType : TCrFieldValueType
        read FFieldType
       write SetFieldType
     default fvUnknown;
    property FieldLength : Word
        read FFieldLength
       write SetFieldLength
     default 0;
    property SummaryType : TCrSummaryType
        read FSummaryType
       write SetSummaryType
     default stCount;
    property SummaryTypeN : Smallint
        read FSummaryTypeN
       write SetSummaryTypeN
     default -1;
    property SummaryTypeField : string
        read FSummaryTypeField
       write SetSummaryTypeField;
  public
    procedure Assign(Source: TPersistent); override;
    procedure Clear;
    function  StatusIsGo (nIndex: integer) : Boolean;
    constructor Create;
  end;  { TCrpeCrossTabSummariesItem }

{------------------------------------------------------------------------------}
{ Class TCrpeCrossTabSummaries                                                 }
{------------------------------------------------------------------------------}
  TCrpeCrossTabSummaries = class(TCrpeContainerX)
  private
    FItem   : TCrpeCrossTabSummariesItem;
  protected
    procedure SetIndex (nIndex: integer);
    function  GetItem(nIndex: integer) : TCrpeCrossTabSummariesItem;
  published
    property Number : TCrLookupNumber
        read FIndex
       write SetIndex
     default -1;
    property Item : TCrpeCrossTabSummariesItem
        read FItem
       write FItem;
  public
    property ItemIndex : integer
        read FIndex
       write SetIndex;
    property Items[nIndex: integer]: TCrpeCrossTabSummariesItem
        read GetItem; default;
    function  Count : integer; override;
{    procedure Assign(Source: TPersistent); override;     }
    procedure Clear;
    constructor Create;
    destructor Destroy; override;
  end; {TCrpeCrossTabSummaries}

TCrpeCrossTabGroups = class;
{------------------------------------------------------------------------------}
{ Class TCrpeCrossTabGroupsItem                                                }
{------------------------------------------------------------------------------}
  TCrpeCrossTabGroupsItem = class(TCrpeItemX)
  private
    FRowCol           : TCrCrossTabGroupPlacement; {for private use}
    FFieldName        : string;
    FCondition        : TCrGroupCondition;
    FDirection        : TCrGroupDirection;
    FBackgroundColor  : TColor;
    FSuppressSubtotal : Boolean;
    FSuppressLabel    : Boolean;
  protected
    procedure SetFieldName(const Value: string);
    procedure SetCondition(const Value: TCrGroupCondition);
    procedure SetDirection(const Value: TCrGroupDirection);
    procedure SetBackgroundColor(const Value: TColor);
    procedure SetSuppressSubtotal(const Value: Boolean);
    procedure SetSuppressLabel(const Value: Boolean);
  published
    property FieldName : string
        read FFieldName
       write SetFieldName;
    property Condition : TCrGroupCondition
        read FCondition
       write SetCondition
     default AnyChange;
    property Direction : TCrGroupDirection
        read FDirection
       write SetDirection
     default gdAscending;
    property BackgroundColor : TColor
        read FBackgroundColor
       write SetBackgroundColor
     default clNone;
    property SuppressSubtotal : Boolean
        read FSuppressSubtotal
       write SetSuppressSubtotal
     default False;
    property SuppressLabel : Boolean
        read FSuppressLabel
       write SetSuppressLabel
     default False;
  public
    procedure Assign(Source: TPersistent); override;
    procedure Clear;
    function  StatusIsGo (nIndex: integer) : Boolean;
    constructor Create;
  end;  { TCrpeCrossTabGroups }

{------------------------------------------------------------------------------}
{ Class TCrpeCrossTabGroups                                                    }
{------------------------------------------------------------------------------}
  TCrpeCrossTabGroups = class(TCrpeContainerX)
  private
    FItem   : TCrpeCrossTabGroupsItem;
  protected
    procedure SetIndex (nIndex: integer);
    function  GetItem(nIndex: integer) : TCrpeCrossTabGroupsItem;
  published
    property Number : TCrLookupNumber
        read FIndex
       write SetIndex
     default -1;
    property Item : TCrpeCrossTabGroupsItem
        read FItem
       write FItem;
  public
    property ItemIndex : integer
        read FIndex
       write SetIndex;
    property Items[nIndex: integer]: TCrpeCrossTabGroupsItem
        read GetItem; default;
    function  Count : integer; override;
{  procedure Assign(Source: TPersistent); override;}
    procedure Clear;
    constructor Create;
    destructor Destroy; override;
  end;

{------------------------------------------------------------------------------}
{ Class TCrpeCrossTabsItem                                                     }
{------------------------------------------------------------------------------}
  TCrpeCrossTabsItem = class(TCrpeObjectItemAX)
  private
    FShowCellMargins           : Boolean;
    FShowGridLines             : Boolean;
    FRepeatRowLabels           : Boolean;
    FKeepColumnsTogether       : Boolean;
    FSuppressEmptyRows         : Boolean;
    FSuppressEmptyColumns      : Boolean;
    FSuppressRowGrandTotals    : Boolean;
    FSuppressColumnGrandTotals : Boolean;
    FColorRowGrandTotals       : TColor;
    FColorColumnGrandTotals    : TColor;
    FSummaries                 : TCrpeCrossTabSummaries;
    FRowGroups                 : TCrpeCrossTabGroups;
    FColumnGroups              : TCrpeCrossTabGroups;
  protected
    procedure SetShowCellMargins (const Value: Boolean);
    procedure SetSuppressEmptyRows (const Value: Boolean);
    procedure SetSuppressEmptyColumns (const Value: Boolean);
    procedure SetKeepColumnsTogether (const Value: Boolean);
    procedure SetRepeatRowLabels (const Value: Boolean);
    procedure SetSuppressRowGrandTotals (const Value: Boolean);
    procedure SetSuppressColumnGrandTotals (const Value: Boolean);
    procedure SetColorRowGrandTotals (const Value: TColor);
    procedure SetColorColumnGrandTotals (const Value: TColor);
    procedure SetShowGridLines (const Value: Boolean);
  published
    property ShowCellMargins : Boolean
        read FShowCellMargins
       write SetShowCellMargins
     default True;
    property SuppressEmptyRows : Boolean
        read FSuppressEmptyRows
       write SetSuppressEmptyRows
     default False;
    property SuppressEmptyColumns : Boolean
        read FSuppressEmptyColumns
       write SetSuppressEmptyColumns
     default False;
    property KeepColumnsTogether : Boolean
        read FKeepColumnsTogether
       write SetKeepColumnsTogether
     default True;
    property RepeatRowLabels : Boolean
        read FRepeatRowLabels
       write SetRepeatRowLabels
     default False;
    property SuppressRowGrandTotals : Boolean
        read FSuppressRowGrandTotals
       write SetSuppressRowGrandTotals
     default False;
    property SuppressColumnGrandTotals : Boolean
        read FSuppressColumnGrandTotals
       write SetSuppressColumnGrandTotals
     default False;
    property ColorRowGrandTotals : TColor
        read FColorRowGrandTotals
       write SetColorRowGrandTotals
     default clNone;
    property ColorColumnGrandTotals : TColor
        read FColorColumnGrandTotals
       write SetColorColumnGrandTotals
     default clNone;
    property ShowGridLines : Boolean
        read FShowGridLines
       write SetShowGridLines
     default True;
    property Summaries : TCrpeCrossTabSummaries
        read FSummaries
       write FSummaries;
    property RowGroups : TCrpeCrossTabGroups
        read FRowGroups
       write FRowGroups;
    property ColumnGroups : TCrpeCrossTabGroups
        read FColumnGroups
       write FColumnGroups;
  public
    procedure Assign(Source: TPersistent); override;
    procedure Clear;
    constructor Create;
    destructor Destroy; override;
  end;  {TCrpeCrossTabsItem}

{------------------------------------------------------------------------------}
{ Class TCrpeCrossTabs                                                         }
{------------------------------------------------------------------------------}
  TCrpeCrossTabs = class(TCrpeObjectContainerAX)
  private
  protected
    procedure SetIndex (nIndex: integer);
    function  GetItems(nIndex: integer) : TCrpeCrossTabsItem;
    function  GetItem : TCrpeCrossTabsItem;
    procedure SetItem (const nItem: TCrpeCrossTabsItem);
  published
    property Number : TCrLookupNumber
        read FIndex
       write SetIndex
     default -1;
    property Item : TCrpeCrossTabsItem  {accesses inherited FItem}
        read GetItem
       write SetItem;
  public
    property ItemIndex : integer
        read FIndex
       write SetIndex;
    property Items[nIndex: integer]: TCrpeCrossTabsItem
        read GetItems; default;
{  procedure Assign(Source: TPersistent); override;}
    procedure Clear;
    constructor Create;
    destructor Destroy; override;
  end;  {TCrpeCrossTabs}

{------------------------------------------------------------------------------}
{ Class TCrpeDatabaseFieldsItem                                                }
{------------------------------------------------------------------------------}
   TCrpeDatabaseFieldsItem = class(TCrpeFieldObjectItemX)
   private
   protected
   published
   public
     procedure Assign(Source: TPersistent); override;
   end; { Class TCrpeDatabaseFieldsItem }

{------------------------------------------------------------------------------}
{ Class TCrpeDatabaseFields                                                    }
{------------------------------------------------------------------------------}
   TCrpeDatabaseFields = class(TCrpeFieldObjectContainerX)
   private
   protected
     procedure SetIndex (nIndex: integer);
     function  GetItems(nIndex: integer) : TCrpeDatabaseFieldsItem;
     function  GetItem : TCrpeDatabaseFieldsItem;
     procedure SetItem (const nItem: TCrpeDatabaseFieldsItem);
   published
     property Number : TCrLookupNumber
         read FIndex
        write SetIndex
      default -1;
     property Item : TCrpeDatabaseFieldsItem
         read GetItem
        write SetItem;
   public
     property ItemIndex : integer
         read FIndex
        write SetIndex;
     property Items[nIndex: integer]: TCrpeDatabaseFieldsItem
         read GetItems; default;
{    procedure Assign(Source: TPersistent); override;}
     procedure Clear;
     function  IndexOf (FieldName: string): integer;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeDatabaseFields }

{------------------------------------------------------------------------------}
{ Class TCrpeExportEmail                                                       }
{------------------------------------------------------------------------------}
   TCrpeExportEmail = class(TCrpePersistentX)
   private
     FCCList   : string;
     FMessage  : string;
     FSubject  : string;
     FToList   : string;
     FBCCList  : string;
     FUserName : string;
     FPassword : string;
   protected
   published
     property CCList: string
         read FCCList
        write FCCList;
     property Message : string
         read FMessage
        write FMessage;
     property Subject : string
         read FSubject
        write FSubject;
     property ToList : string
         read FToList
        write FToList;
     property BCCList : string
         read FBCCList
        write FBCCList;
     property UserName : string
         read FUserName
        write FUserName;
     property Password : string
         read FPassword
        write FPassword;
   public
     procedure Clear;
     constructor Create;
   end; { Class TCrpeExportEmail Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeExportExchange                                                    }
{------------------------------------------------------------------------------}
   TCrpeExportExchange = class(TCrpePersistentX)
   private
     FFolder   : string;
     FPassword : string;
     FProfile  : string;
   protected
   published
      property Folder: string
          read FFolder
         write FFolder;
      property Password : string
          read FPassword
         write FPassword;
      property Profile : string
          read FProfile
         write FProfile;
   public
     procedure Clear;
     constructor Create;
   end; { Class TCrpeExportExchange Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeExportLotusNotes                                                  }
{------------------------------------------------------------------------------}
   TCrpeExportLotusNotes = class(TCrpePersistentX)
   private
     FDBName   : string;
     FFormName : string;
     FComments : string;
   protected
   published
      property DBName : string
          read FDBName
         write FDBName;
      property FormName : string
          read FFormName
         write FFormName;
      property Comments : string
          read FComments
         write FComments;
   public
     procedure Clear;
     constructor Create;
   end; { Class TCrpeExportLotusNotes Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeExportODBC                                                        }
{------------------------------------------------------------------------------}
   TCrpeExportODBC = class(TCrpePersistentX)
   private
     FPrompt   : Boolean;
     FPassword : string;
     FSource   : string;
     FTable    : string;
     FUser     : string;
   protected
   published
      property Prompt : Boolean //Prompt for Options
          read FPrompt
         write FPrompt
       default False;
      property Password: string
          read FPassword
         write FPassword;
      property Source : string
          read FSource
         write FSource;
      property Table : string
          read FTable
         write FTable;
      property User : string
          read FUser
         write FUser;
   public
     procedure Clear;
     constructor Create;
   end; { Class TCrpeExportODBC Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeExportExcel                                                       }
{------------------------------------------------------------------------------}
   TCrExportExcelType = (ExcelStandard, ExcelDataOnly);
   TCrColumnWidth = (ByArea, ByConstant);
   TCrExportExcelPageAreaPair = (DoNotExportPHOrPF, PHPFOncePerReport, PHPFOnEachPage);

   TCrpeExportExcel = class(TCrpePersistentX)
   private
     FColumnWidth             : TCrColumnWidth;
     FConstant                : double;
     FArea                    : string;
     FWorksheetFunctions      : Boolean;
     FCreatePageBreaks        : Boolean;
     FConvertDatesToStrings   : Boolean;
     FUsePageRange            : Boolean;
     FFirstPage               : DWord;
     FLastPage                : DWord;
     FExportHeaderFooter      : Boolean; // deprecated;
     FChopPageHeader          : Boolean; //for Data Only format
     FExportImagesInDataOnly  : Boolean;
     FUseFormatInDataOnly     : Boolean;
     FMaintainColumnAlignment : Boolean; //for Data Only format
     FMaintainRelativeObjPosition : Boolean; //for Data Only format
     FShowGridlines           : Boolean;     //for page-based format only
     FExportPageAreaPair      : TCrExportExcelPageAreaPair;
     FXlsType                 : TCrExportExcelType;
   protected
   published
      property ColumnWidth : TCrColumnWidth
          read FColumnWidth
         write FColumnWidth
       default ByArea;
      property Constant : double
          read FConstant
         write FConstant;
       {default 36.0 points = .5 inch}
      property Area : string
          read FArea
         write FArea;
       {default '' - indicates Whole Report}
      property WorksheetFunctions : Boolean
          read FWorksheetFunctions
         write FWorksheetFunctions
       default True;
      property CreatePageBreaks : Boolean
          read FCreatePageBreaks
         write FCreatePageBreaks
       default False;
      property ConvertDatesToStrings : Boolean
          read FConvertDatesToStrings
         write FConvertDatesToStrings
       default False;
      property UsePageRange : Boolean
          read FUsePageRange
         write FUsePageRange
       default False;
      property FirstPage : DWord
          read FFirstPage
         write FFirstPage
       default 0;
      property LastPage : DWord
          read FLastPage
         write FLastPage
       default 0;
      property ExportHeaderFooter : Boolean //deprecated, replaced by ExportPageHeaderFooterEx
          read FExportHeaderFooter  //deprecated, replaced by FExportPageAreaPair
         write FExportHeaderFooter
       default True;
      property ChopPageHeader : Boolean
          read FChopPageHeader
         write FChopPageHeader
       default True;
      property ExportImagesInDataOnly : Boolean
          read FExportImagesInDataOnly
         write FExportImagesInDataOnly
       default False;
      property ExportObjectFormattingInDataOnly : Boolean
          read FUseFormatInDataOnly
         write FUseFormatInDataOnly
       default False;
      property MaintainColumnAlignmentInDataOnly: Boolean
          read FMaintainColumnAlignment
         write FMaintainColumnAlignment
       default False;
      property MaintainRelativeObjPositionInDataOnly : Boolean
          read FMaintainRelativeObjPosition
         write FMaintainRelativeObjPosition
       default False;
      property ShowGridlines : Boolean
          read FShowGridlines
         write FShowGridlines
       default False;
      property XlsType : TCrExportExcelType
          read FXlsType
         write FXlsType
       default ExcelStandard;
     property ExportHeaderFooterEx : TCrExportExcelPageAreaPair
          read FExportPageAreaPair
         write FExportPageAreaPair
       default PHPFOncePerReport;
   public
     procedure Clear;
     constructor Create;
   end; { Class TCrpeExportExcel Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeExportHTML                                                        }
{------------------------------------------------------------------------------}
   TCrpeExportHTML = class(TCrpePersistentX)
   private
     FPageNavigator : Boolean;
     FSeparatePages : Boolean;
     FUsePageRange  : Boolean;
     FFirstPage     : DWord;
     FLastPage      : DWord;
   protected
   published
      property PageNavigator: Boolean
          read FPageNavigator
         write FPageNavigator;
      property SeparatePages : Boolean
          read FSeparatePages
         write FSeparatePages;
      property UsePageRange : Boolean
          read FUsePageRange
         write FUsePageRange
       default False;
      property FirstPage : DWord
          read FFirstPage
         write FFirstPage
       default 0;
      property LastPage : DWord
          read FLastPage
         write FLastPage
       default 0;
   public
     procedure Clear;
     constructor Create;
   end; { Class TCrpeExportHTML Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeExportPDF                                                         }
{------------------------------------------------------------------------------}
  TCrpeExportPDF = class(TCrpePersistentX)
  private
    FPrompt       : Boolean;
    FUsePageRange : Boolean;
    FFirstPage    : Word;
    FLastPage     : Word;
  protected
  published
     property Prompt : Boolean //Prompt for Page Range
         read FPrompt
        write FPrompt
      default False;
     property UsePageRange : Boolean
         read FUsePageRange
        write FUsePageRange
      default False;
     property FirstPage : Word
         read FFirstPage
        write FFirstPage
      default 0;
     property LastPage : Word
         read FLastPage
        write FLastPage
      default 0;
  public
    procedure Clear;
    constructor Create;
  end; { Class TCrpeExportPDF Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeExportRTF                                                         }
{------------------------------------------------------------------------------}
  TCrpeExportRTF = class(TCrpePersistentX)
  private
    FPrompt          : Boolean;
    FUsePageRange    : Boolean;
    FFirstPage       : Word;
    FLastPage        : Word;
    FIncludePgBreaks : Boolean;
  protected
  published
     property Prompt : Boolean
         read FPrompt
        write FPrompt
      default False;
     property UsePageRange : Boolean
         read FUsePageRange
        write FUsePageRange
      default False;
     property FirstPage : Word
         read FFirstPage
        write FFirstPage
      default 0;
     property LastPage : Word
         read FLastPage
        write FLastPage
      default 0;
     property InsertPageBreaks : Boolean
         read FIncludePgBreaks
        write FIncludePgBreaks
      default false;  
  public
    procedure Clear;
    constructor Create;
  end; { Class TCrpeExportRTF Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeExportWord                                                        }
{------------------------------------------------------------------------------}
  TCrpeExportWord = class(TCrpePersistentX)
  private
    FPrompt       : Boolean;
    FUsePageRange : Boolean;
    FFirstPage    : Word;
    FLastPage     : Word;
  protected
  published
     property Prompt : Boolean
         read FPrompt
        write FPrompt
      default False;
     property UsePageRange : Boolean
         read FUsePageRange
        write FUsePageRange
      default False;
     property FirstPage : Word
         read FFirstPage
        write FFirstPage
      default 0;
     property LastPage : Word
         read FLastPage
        write FLastPage
      default 0;
  public
    procedure Clear;
    constructor Create;
  end; { Class TCrpeExportWord Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeExportText                                                        }
{------------------------------------------------------------------------------}
  TCrRecordsType = (ColumnsWithSpaces, ColumnsNoSpaces);

  TCrpeExportText = class(TCrpePersistentX)
  private
    FUseRptNumberFmt : Boolean;
    FUseRptDateFmt   : Boolean;
    FStringDelimiter : Char;
    FFieldSeparator  : string;
    FLinesPerPage    : Word;
    FCharPerInch     : Word;
    FRecordsType     : TCrRecordsType;
  protected
  published
      {Char/Comma/Tab/Record Text Exports}
     property UseRptNumberFmt : Boolean
         read FUseRptNumberFmt
        write FUseRptNumberFmt
      default False;
     property UseRptDateFmt : Boolean
         read FUseRptDateFmt
        write FUseRptDateFmt
      default False;
      {CSV}
     property StringDelimiter : Char
         read FStringDelimiter
        write FStringDelimiter;
     property FieldSeparator : string
         read FFieldSeparator
        write FFieldSeparator;
      {PaginatedText}
     property LinesPerPage : Word
         read FLinesPerPage
        write FLinesPerPage
      default 60;
     property CharPerInch : Word
         read FCharPerInch
        write FCharPerInch
      default 0; //zero means "use Default CPI"
     property RecordsType : TCrRecordsType
         read FRecordsType
        write FRecordsType
      default ColumnsWithSpaces;
  public
    procedure Clear;
    constructor Create;
  end; { Class TCrpeExportText Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeExportXML                                                         }
{------------------------------------------------------------------------------}
  TCrpeExportXML = class(TCrpePersistentX)
  private
    FPrompt        : Boolean;
    FSeparatePages : Boolean;
  protected
  published
     property Prompt : Boolean
         read FPrompt
        write FPrompt
      default False;
     property SeparatePages : Boolean
         read FSeparatePages
        write FSeparatePages
      default True;
  public
    procedure Clear;
    constructor Create;
  end; { Class TCrpeExportXML Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeExportOptions                                                     }
{------------------------------------------------------------------------------}
  TCrpeExportOptions = class(TCrpePersistentX)
  private
    FAppName           : string;
    FFileName          : string;
    FFileType          : TCrExportType;
    FDestination       : TCrExportDestination;
    FEmail             : TCrpeExportEmail;
    FExchange          : TCrpeExportExchange;
    FODBC              : TCrpeExportODBC;
    FExcel             : TCrpeExportExcel;
    FLotusNotes        : TCrpeExportLotusNotes;
    FHTML              : TCrpeExportHTML;
    FRTF               : TCrpeExportRTF;
    FWord              : TCrpeExportWord;
    FPDF               : TCrpeExportPDF;
    FText              : TCrpeExportText;
    FXML               : TCrpeExportXML;
    FPromptForOptions  : Boolean;
    FPromptOnOverwrite : Boolean;
  protected
  published
     property AppName : TCrExportAppName
         read FAppName
        write FAppName;
     property FileName : TCrExportFileName
         read FFileName
        write FFileName;
     property FileType : TCrExportType
         read FFileType
        write FFileType
      default TextFormat;
     property Destination : TCrExportDestination
         read FDestination
        write FDestination
      default toFile;
      {Email}
     property Email : TCrpeExportEmail
         read FEmail
        write FEmail;
      {Exchange}
     property Exchange : TCrpeExportExchange
         read FExchange
        write FExchange;
      {ODBC}
     property ODBC : TCrpeExportODBC
         read FODBC
        write FODBC;
      {Excel}
     property Excel : TCrpeExportExcel
         read FExcel
        write FExcel;
      {Lotus Notes}
     property LotusNotes : TCrpeExportLotusNotes
         read FLotusNotes
        write FLotusNotes;
      {HTML}
     property HTML : TCrpeExportHTML
         read FHTML
        write FHTML;
      {RTF}
     property RTF : TCrpeExportRTF
         read FRTF
        write FRTF;
      {Word}
     property Word : TCrpeExportWord
         read FWord
        write FWord;
      {PDF}
     property PDF : TCrpeExportPDF
         read FPDF
        write FPDF;
      {Text}
     property Text : TCrpeExportText
         read FText
        write FText;
      {XML}
     property XML : TCrpeExportXML
         read FXML
        write FXML;
      {Prompt}
     property PromptForOptions: Boolean
         read FPromptForOptions
        write FPromptForOptions
      default False;
     property PromptOnOverwrite: Boolean
         read FPromptOnOverwrite
        write FPromptOnOverwrite
      default False;
  public
    PEExpOptions  : PEExportOptions;
    {UXF}
    UXFPDF        : UXFPDFFormatOptions;
    UXFHTML       : UXFHTML3Options;
    UXFXls        : UXFXlsOptions;
    UXFWord       : UXFEDOCFormatOptions;
    UXFODBC       : UXFODBCOptions;
    UXFRec        : UXFRecordStyleOptions;
    UXFRTF        : UXFERTFFormatOptions;
    UXFEditableRTF: UXFEditableRTFFormatOptions;
    UXFSepVal     : UXFCharCommaTabSeparatedOptions;
    UXFPagText    : UXFPaginatedTextOptions;
    UXFXML        : UXFXMLOptions;
    {UXD}
    UXDDisk       : UXDDiskOptions;
    UXDMapi       : UXDMapiOptions;
    UXDVIM        : UXDVIMOptions;
    UXDExchange   : UXDPostFolderOptions;
    UXDNotes      : UXDNotesOptions;
    UXDApp        : UXDApplicationOptions;
    UXDAppFileName: string;
    pFormat       : Pointer;
    pDisk         : Pointer;
    procedure Clear;
    function  Send : Boolean;
    constructor Create;
    destructor Destroy; override;
   end; { Class TCrpeExportOptions Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeFormulasItem                                                      }
{------------------------------------------------------------------------------}
  TCrpeFormulasItem = class(TCrpeFieldObjectItemX)
  private
    FName    : string;
    FFormula : TStrings;
    xFormula : TStrings;
  protected
    procedure SetName (const Value: string);
    procedure SetFormula (const ListVar: TStrings);
    procedure OnChangeFormula (Sender: TObject);
  published
    property Name : string
        read FName
       write SetName;
    property Formula : TStrings
        read FFormula
       write SetFormula;
  public
    function  Check : Boolean;
    procedure Assign(Source: TPersistent); override;
    procedure Clear;
    constructor Create;
    destructor Destroy; override;
  end; { Class TCrpeFormulasItem }

{------------------------------------------------------------------------------}
{ Class TCrpeFormulas                                                          }
{------------------------------------------------------------------------------}
  TCrpeFormulas = class(TCrpeFieldObjectContainerX)
  private
    FName                   : string;
    FNames                  : TStrings;
    FObjectPropertiesActive : Boolean;
  protected
    procedure SetName (const Value: string);
    procedure SetObjectPropertiesActive (const Value: Boolean);
    procedure SetIndex (nIndex: integer);
    function  GetItems (nIndex: integer) : TCrpeFormulasItem;
    function  GetItem : TCrpeFormulasItem;
    procedure SetItem (const nItem: TCrpeFormulasItem);
  published
    property Number : TCrLookupNumber {lookup by number}
        read FIndex
       write SetIndex
     default -1;
    property Name : TCrLookupString    {lookup by name}
        read FName
       write SetName;
    property Item : TCrpeFormulasItem
        read GetItem
       write SetItem;
    property ObjectPropertiesActive : Boolean
        read FObjectPropertiesActive
       write SetObjectPropertiesActive
     default True;
  public
    property ItemIndex : integer
        read FIndex
       write SetIndex;
    property Items[nIndex: integer]: TCrpeFormulasItem
        read GetItems; default;
    function  Names : TStrings; {read only - list of Formula Names}
    function  Count : integer; override;
{    procedure Assign(Source: TPersistent); override;}
    procedure Clear;
    function  IndexOf (FormulaName: string): integer;
    function  ByName (FormulaName: string): TCrpeFormulasItem;
    constructor Create;
    destructor Destroy; override;
  end;

{------------------------------------------------------------------------------}
{ Class TCrpeGraphAxis                                                         }
{------------------------------------------------------------------------------}
   TCrpeGraphAxis = class(TCrpePersistentX)
   private
      { Grid Lines }
      FGridLineX        : TCrGraphGridLines;
      FGridLineY        : TCrGraphGridLines;
      FGridLineY2       : TCrGraphGridLines;
      FGridLineZ        : TCrGraphGridLines;
      { Auto Range }
      FDataValuesY      : TCrGraphDVType;
      FDataValuesY2     : TCrGraphDVType;
      FDataValuesZ      : TCrGraphDVType;
      { Min/Max Values }
      FMinY             : Double;
      FMaxY             : Double;
      FMinY2            : Double;
      FMaxY2            : Double;
      FMinZ             : Double;
      FMaxZ             : Double;
      { Number Format }
      FNumberFormatY    : TCrGraphNumberFormat;
      FNumberFormatY2   : TCrGraphNumberFormat;
      FNumberFormatZ    : TCrGraphNumberFormat;
      { Automatic Division }
      FDivisionTypeY    : TCrGraphDVType;
      FDivisionTypeY2   : TCrGraphDVType;
      FDivisionTypeZ    : TCrGraphDVType;
      { Manual Division }
      FDivisionsY       : LongInt;
      FDivisionsY2      : LongInt;
      FDivisionsZ       : LongInt;
   protected
      procedure GetAxis;
      {GridLines}
      procedure SetGridLineX (const Value: TCrGraphGridLines);
      procedure SetGridLineY (const Value: TCrGraphGridLines);
      procedure SetGridLineY2 (const Value: TCrGraphGridLines);
      procedure SetGridLineZ (const Value: TCrGraphGridLines);
      {DataValues - AutoRange}
      procedure SetDataValuesY (const Value: TCrGraphDVType);
      procedure SetDataValuesY2 (const Value: TCrGraphDVType);
      procedure SetDataValuesZ (const Value: TCrGraphDVType);
      {Min/Max}
      procedure SetMinY (const Value: Double);
      procedure SetMaxY (const Value: Double);
      procedure SetMinY2 (const Value: Double);
      procedure SetMaxY2 (const Value: Double);
      procedure SetMinZ (const Value: Double);
      procedure SetMaxZ (const Value: Double);
      {NumberFormat}
      procedure SetNumberFormatY (const Value: TCrGraphNumberFormat);
      procedure SetNumberFormatY2 (const Value: TCrGraphNumberFormat);
      procedure SetNumberFormatZ (const Value: TCrGraphNumberFormat);
      {DivisionType}
      procedure SetDivisionTypeY (const Value: TCrGraphDVType);
      procedure SetDivisionTypeY2 (const Value: TCrGraphDVType);
      procedure SetDivisionTypeZ (const Value: TCrGraphDVType);
      {Divisions}
      procedure SetDivisionsY (const Value: LongInt);
      procedure SetDivisionsY2 (const Value: LongInt);
      procedure SetDivisionsZ (const Value: LongInt);
   published
      {GridLines}
      property GridLineX : TCrGraphGridLines
          read FGridLineX
         write SetGridLineX;
      property GridLineY : TCrGraphGridLines
          read FGridLineY
         write SetGridLineY;
      property GridLineY2 : TCrGraphGridLines
          read FGridLineY2
         write SetGridLineY2;
      property GridLineZ : TCrGraphGridLines
          read FGridLineZ
         write SetGridLineZ;
      {DataValues - AutoRange}
      property DataValuesY : TCrGraphDVType
          read FDataValuesY
         write SetDataValuesY;
      property DataValuesY2 : TCrGraphDVType
          read FDataValuesY2
         write SetDataValuesY2;
      property DataValuesZ : TCrGraphDVType
          read FDataValuesZ
         write SetDataValuesZ;
      {Min/Max}
      property MinY : Double
          read FMinY
         write SetMinY;
      property MaxY : Double
          read FMaxY
         write SetMaxY;
      property MinY2 : Double
          read FMinY2
         write SetMinY2;
      property MaxY2 : Double
          read FMaxY2
         write SetMaxY2;
      property MinZ : Double
          read FMinZ
         write SetMinZ;
      property MaxZ : Double
          read FMaxZ
         write SetMaxZ;
      {NumberFormat}
      property NumberFormatY : TCrGraphNumberFormat
          read FNumberFormatY
         write SetNumberFormatY;
      property NumberFormatY2 : TCrGraphNumberFormat
          read FNumberFormatY2
         write SetNumberFormatY2;
      property NumberFormatZ : TCrGraphNumberFormat
          read FNumberFormatZ
         write SetNumberFormatZ;
      {DivisionType}
      property DivisionTypeY : TCrGraphDVType
          read FDivisionTypeY
         write SetDivisionTypeY;
      property DivisionTypeY2 : TCrGraphDVType
          read FDivisionTypeY2
         write SetDivisionTypeY2;
      property DivisionTypeZ : TCrGraphDVType
          read FDivisionTypeZ
         write SetDivisionTypeZ;
      {Divisions}
      property DivisionsY : LongInt
          read FDivisionsY
         write SetDivisionsY;
      property DivisionsY2 : LongInt
          read FDivisionsY2
         write SetDivisionsY2;
      property DivisionsZ : LongInt
          read FDivisionsZ
         write SetDivisionsZ;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
   end; { Class TCrpeGraphAxis }

{------------------------------------------------------------------------------}
{ Class TCrpeGraphOptionInfo                                                   }
{------------------------------------------------------------------------------}
   TCrpeGraphOptionInfo = class(TCrpePersistentX)
   private
      FColor            : TCrGraphColor;
      FLegend           : TCrGraphLegend; { showLegend and LegendPosition }
      { Pie Charts and Doughut Charts }
      FPieSize          : TCrGraphPieSize;
      FPieSlice         : TCrGraphPieSlice;
      { Bar Chart }
      FBarSize          : TCrGraphBarSize;
      FBarDirection     : TCrGraphBarDirection;
      { Markers (used for line and bar charts) }
      FMarkerSize       : TCrGraphMarkerSize;
      FMarkerShape      : TCrGraphMarkerShape;
      { Data Points }
      FDataPoints       : TCrGraphDataPoints;
      FNumberFormat     : TCrGraphNumberFormat;
      { 3D }
      FViewingAngle     : TCrGraphViewingAngle;
      FLegendLayout     : TCrGraphLegendLayout;
   protected
      procedure SetColor (const Value: TCrGraphColor);
      procedure SetLegend (const Value: TCrGraphLegend);
      procedure SetPieSize (const Value: TCrGraphPieSize);
      procedure SetPieSlice (const Value: TCrGraphPieSlice);
      procedure SetBarSize (const Value: TCrGraphBarSize);
      procedure SetBarDirection (const Value: TCrGraphBarDirection);
      procedure SetMarkerSize (const Value: TCrGraphMarkerSize);
      procedure SetMarkerShape (const Value: TCrGraphMarkerShape);
      procedure SetDataPoints (const Value: TCrGraphDataPoints);
      procedure SetNumberFormat (const Value: TCrGraphNumberFormat);
      procedure SetViewingAngle (const Value: TCrGraphViewingAngle);
      procedure SetLegendLayout (const Value: TCrGraphLegendLayout);
      procedure GetOptionInfo;
   published
      property Color : TCrGraphColor
          read FColor
         write SetColor
       default gcColor;
      property Legend : TCrGraphLegend
          read FLegend
         write SetLegend
       default glRight;
      property PieSize : TCrGraphPieSize
          read FPieSize
         write SetPieSize
       default gpsAverage;
      property PieSlice : TCrGraphPieSlice
          read FPieSlice
         write SetPieSlice
       default gslNone;
      property BarSize : TCrGraphBarSize
          read FBarSize
         write SetBarSize
       default gbsLarge;
      property BarDirection : TCrGraphBarDirection
          read FBarDirection
         write SetBarDirection
       default bdVertical;
      property MarkerSize : TCrGraphMarkerSize
          read FMarkerSize
         write SetMarkerSize
       default gmsMedium;
      property MarkerShape : TCrGraphMarkerShape
          read FMarkerShape
         write SetMarkerShape
       default gshRectangle;
      property DataPoints : TCrGraphDataPoints
          read FDataPoints
         write SetDataPoints
       default gdpNone;
      property NumberFormat : TCrGraphNumberFormat
          read FNumberFormat
         write SetNumberFormat
       default gnfNoDecimal;
      property ViewingAngle : TCrGraphViewingAngle
          read FViewingAngle
         write SetViewingAngle
       default gvaStandard;
      property LegendLayout : TCrGraphLegendLayout
          read FLegendLayout
         write SetLegendLayout
       default gllPercentage;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
   end; { Class TCrpeGraphOptionInfo }

{------------------------------------------------------------------------------}
{ Class TCrpeGraphText                                                         }
{------------------------------------------------------------------------------}
   TCrpeGraphText = class(TCrpePersistentX)
   private
     FTitle            : string;
     FSubTitle         : string;
     FFootNote         : string;
     FGroupsTitle      : string;
     FSeriesTitle      : string;
     FXAxisTitle       : string;
     FYAxisTitle       : string;
     FZAxisTitle       : string;
     FTitleFont        : TCrpeFont;
     FSubTitleFont     : TCrpeFont;
     FFootNoteFont     : TCrpeFont;
     FGroupsTitleFont  : TCrpeFont;
     FDataTitleFont    : TCrpeFont;
     FLegendFont       : TCrpeFont;
     FGroupLabelsFont  : TCrpeFont;
     FDataLabelsFont   : TCrpeFont;
     xFont             : TCrpeFont;
   protected
     {Text properties}
     procedure SetTitle (const Value: string);
     procedure SetSubTitle (const Value: string);
     procedure SetFootNote (const Value: string);
     procedure SetGroupsTitle (const Value: string);
     procedure SetSeriesTitle (const Value: string);
     procedure SetXAxisTitle (const Value: string);
     procedure SetYAxisTitle (const Value: string);
     procedure SetZAxisTitle (const Value: string);
     {Font properties for CR7+}
     procedure SetTitleFont (const Value: TCrpeFont);
     procedure SetSubTitleFont (const Value: TCrpeFont);
     procedure SetFootNoteFont (const Value: TCrpeFont);
     procedure SetGroupsTitleFont (const Value: TCrpeFont);
     procedure SetDataTitleFont (const Value: TCrpeFont);
     procedure SetLegendFont (const Value: TCrpeFont);
     procedure SetGroupLabelsFont (const Value: TCrpeFont);
     procedure SetDataLabelsFont (const Value: TCrpeFont);
     {Font Change Events}
     procedure OnChangeTitleFont (Sender: TObject);
     procedure OnChangeSubTitleFont (Sender: TObject);
     procedure OnChangeFootNoteFont (Sender: TObject);
     procedure OnChangeGroupsTitleFont (Sender: TObject);
     procedure OnChangeDataTitleFont (Sender: TObject);
     procedure OnChangeLegendFont (Sender: TObject);
     procedure OnChangeGroupLabelsFont (Sender: TObject);
     procedure OnChangeDataLabelsFont (Sender: TObject);
     {Others}
     procedure GetText;
     function  CompareFonts(RptFontInfo: PEFontColorInfo;
        var RptFont: TCrpeFont; FontArea: Word): Boolean;
     procedure CopyFontInfo(var FontInfo: PEFontColorInfo; VCLFont: TCrpeFont);
   published
     property Title : string
         read FTitle
        write SetTitle;
     property SubTitle : string
         read FSubTitle
        write SetSubTitle;
     property FootNote : string
         read FFootNote
        write SetFootNote;
     property GroupsTitle : string
         read FGroupsTitle
        write SetGroupsTitle;
     property SeriesTitle : string
         read FSeriesTitle
        write SetSeriesTitle;
     property XAxisTitle : string
         read FXAxisTitle
        write SetXAxisTitle;
     property YAxisTitle : string
         read FYAxisTitle
        write SetYAxisTitle;
     property ZAxisTitle : string
         read FZAxisTitle
        write SetZAxisTitle;
     {Font properties for CR7+}
     property TitleFont : TCrpeFont
         read FTitleFont
        write SetTitleFont;
     property SubTitleFont : TCrpeFont
         read FSubTitleFont
        write SetSubTitleFont;
     property FootNoteFont : TCrpeFont
         read FFootNoteFont
        write SetFootNoteFont;
     property GroupsTitleFont : TCrpeFont
         read FGroupsTitleFont
        write SetGroupsTitleFont;
     property DataTitleFont : TCrpeFont
         read FDataTitleFont
        write SetDataTitleFont;
     property LegendFont : TCrpeFont
         read FLegendFont
        write SetLegendFont;
     property GroupLabelsFont : TCrpeFont
         read FGroupLabelsFont
        write SetGroupLabelsFont;
     property DataLabelsFont : TCrpeFont
         read FDataLabelsFont
        write SetDataLabelsFont;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeGraphText }

{------------------------------------------------------------------------------}
{ Class TCrpeGraphsItem                                                        }
{------------------------------------------------------------------------------}
   TCrpeGraphsItem = class(TCrpeObjectItemAX)
   private
     FSectionGraphNum : Smallint;
     FStyle           : TCrGraphType;
     {Graph Subclasses}
     FText            : TCrpeGraphText;
     FOptionInfo      : TCrpeGraphOptionInfo;
     FAxis            : TCrpeGraphAxis;
   protected
     procedure SetStyle (const Value: TCrGraphType);
     procedure SetSectionGraphNum (const Value: Smallint);
     function  GetGraphType (nGraphType, nSubType: Smallint): TCrGraphType;
     procedure GetGraphTypeConst (xGraphType: TCrGraphType;
       var nGraphType: Smallint; var nSubType: Smallint);
   published
     property Style : TCrGraphType
         read FStyle
        write SetStyle;
     property Text : TCrpeGraphText
         read FText
        write FText;
     property OptionInfo : TCrpeGraphOptionInfo
         read FOptionInfo
        write FOptionInfo;
     property Axis : TCrpeGraphAxis
         read FAxis
        write FAxis;
   public
     property SectionGraphNum : Smallint
         read FSectionGraphNum
        write SetSectionGraphNum;
     function  SectionAsCode: Smallint;
     function  SectionType : string;
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeGraphsItem }

{------------------------------------------------------------------------------}
{ Class TCrpeGraphs                                                            }
{------------------------------------------------------------------------------}
   TCrpeGraphs = class(TCrpeObjectContainerAX)
   private
   protected
     procedure SetIndex (nIndex: integer);
     function  GetItems(nIndex: integer) : TCrpeGraphsItem;
     function  GetItem : TCrpeGraphsItem;
     procedure SetItem (const nItem: TCrpeGraphsItem);
   published
     property Number : TCrLookupNumber
         read FIndex
        write SetIndex;
     property Item : TCrpeGraphsItem
         read GetItem
        write SetItem;
   public
     property ItemIndex : integer
         read FIndex
        write SetIndex;
     property Items[nIndex: integer]: TCrpeGraphsItem
         read GetItems; default;
     function  Count : integer; override;
//     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeGraphs }

{------------------------------------------------------------------------------}
{ Class TCrpeGroupNameFieldsItem                                               }
{------------------------------------------------------------------------------}
   TCrpeGroupNameFieldsItem = class(TCrpeFieldObjectItemX)
   private
   protected
   published
   public
//     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
   end; { Class TCrpeGroupNameFieldsItem }

{------------------------------------------------------------------------------}
{ Class TCrpeGroupNameFields                                                    }
{------------------------------------------------------------------------------}
   TCrpeGroupNameFields = class(TCrpeFieldObjectContainerX)
   private
   protected
      procedure SetIndex (nIndex: integer);
      function  GetItems (nIndex: integer) : TCrpeGroupNameFieldsItem;
      function  GetItem : TCrpeGroupNameFieldsItem;
      procedure SetItem (const nItem: TCrpeGroupNameFieldsItem);
   published
      property Number : TCrLookupNumber
          read FIndex
         write SetIndex;
      property Item : TCrpeGroupNameFieldsItem
          read GetItem
         write SetItem;
   public
      property ItemIndex : integer
          read FIndex
         write SetIndex;
      property Items[nIndex: integer]: TCrpeGroupNameFieldsItem
          read GetItems; default;
//     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeGroupNameFields }

{------------------------------------------------------------------------------}
{ Class TCrpeGroupTopN                                                         }
{------------------------------------------------------------------------------}
   TCrpeGroupTopN = class(TCrpePersistentX)
   private
     FSortType      : TCrTopNSortType;
     FNGroups       : Smallint;
     FSortField     : string;
     FIncludeOthers : Boolean;
     FOthersName    : string;
   protected
     procedure SetSortType (const Value: TCrTopNSortType);
     procedure SetNGroups (const Value: Smallint);
     procedure SetSortField (const Value: string);
     procedure SetIncludeOthers (const Value: Boolean);
     procedure SetOthersName (const Value: string);
   published
     property SortType : TCrTopNSortType
         read FSortType
        write SetSortType
      default tnUnsorted;
     property NGroups : Smallint
         read FNGroups
        write SetNGroups
      default 5;
     property SortField : string
         read FSortField
        write SetSortField;
     property IncludeOthers : Boolean
         read FIncludeOthers
        write SetIncludeOthers
      default True;
     property OthersName : string
         read FOthersName
        write SetOthersName;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
   end; { Class TCrpeGroupTopN }

{------------------------------------------------------------------------------}
{ Class TCrpeGroupHierarchy                                                    }
{------------------------------------------------------------------------------}
   TCrpeGroupHierarchy = class(TCrpePersistentX)
   private
     FEnabled       : Boolean;
     FInstanceField : string;
     FParentField   : string;
     FIndent        : LongInt;
   protected
     procedure SetEnabled (const Value: Boolean);
     procedure SetInstanceField (const Value: string);
     procedure SetParentField (const Value: string);
     procedure SetIndent (const Value: LongInt);
   published
     property Enabled : Boolean
         read FEnabled
        write SetEnabled
      default False;
     property InstanceField : string
         read FInstanceField
        write SetInstanceField;
     property ParentField : string
         read FParentField
        write SetParentField;
     property Indent : LongInt
         read FIndent
        write SetIndent
      default 0;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
   end; { Class TCrpeGroupHierarchy }

{------------------------------------------------------------------------------}
{ Class TCrpeGroupsItem                                                        }
{------------------------------------------------------------------------------}
   TCrpeGroupsItem = class(TCrpeItemX)
   private
     FFieldName          : string;
     FCondition          : TCrGroupCondition;
     FDirection          : TCrGroupDirection;
     FGroupType          : TCrGroupType;
     FRepeatGH           : Boolean;
     FKeepTogether       : Boolean;
     FTopN               : TCrpeGroupTopN;
     FHierarchy          : TCrpeGroupHierarchy;
     FCustomizeGroupName : Boolean;
     FGroupNameFormula   : TStrings;
     xFormula            : TStrings;
   protected
     procedure SetFieldName (const Value: string);
     procedure SetGroupType (const Value: TCrGroupType);
     procedure SetCondition (const Value: TCrGroupCondition);
     procedure SetDirection (const Value: TCrGroupDirection);
     procedure SetRepeatGH (const Value: Boolean);
     procedure SetKeepTogether (const Value: Boolean);
     procedure SetCustomizeGroupName (const Value: Boolean);
     function  GetGroupNameFormula : TStrings;
     procedure SetGroupNameFormula (const Value: TStrings);
     {OnChange StringList methods}
     procedure OnChangeGroupNameFormula (Sender: TObject);
  published
     property FieldName : string
         read FFieldName
        write SetFieldName;
     property Condition : TCrGroupCondition
         read FCondition
        write SetCondition
      default AnyChange;
     property Direction : TCrGroupDirection
         read FDirection
        write SetDirection
      default gdAscending;
     property GroupType : TCrGroupType
         read FGroupType
        write SetGroupType
      default gtOther;
     property RepeatGH : Boolean
         read FRepeatGH
        write SetRepeatGH
      default False;
     property KeepTogether : Boolean
         read FKeepTogether
        write SetKeepTogether
      default False;
     property TopN : TCrpeGroupTopN
         read FTopN
        write FTopN;
     property Hierarchy : TCrpeGroupHierarchy
         read FHierarchy
        write FHierarchy;
     property CustomizeGroupName : Boolean
         read FCustomizeGroupName
        write SetCustomizeGroupName;
     property GroupNameFormula : TStrings
         read GetGroupNameFormula
        write SetGroupNameFormula;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeGroupsItem }

{------------------------------------------------------------------------------}
{ Class TCrpeGroups                                                            }
{------------------------------------------------------------------------------}
   TCrpeGroups = class(TCrpeContainerX)
   private
      FItem       : TCrpeGroupsItem;
      FGroupNames : TStrings;
   protected
      procedure SetIndex (nIndex: integer);
      function  GetItem(nIndex: integer) : TCrpeGroupsItem;
      procedure SetItem (const nItem: TCrpeGroupsItem);
   published
      property Number : TCrLookupNumber
          read FIndex
         write SetIndex;
      property Item : TCrpeGroupsItem
          read FItem
         write SetItem;
   public
      property ItemIndex : integer
          read FIndex
         write SetIndex;
      property Items[nIndex: integer]: TCrpeGroupsItem
          read GetItem; default;
     function  Names : TStrings;
     function  Count: integer; override;
//     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     procedure Swap(SourceN, TargetN: Smallint);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeGroups }

{------------------------------------------------------------------------------}
{ Class TCrpeGroupSelection                                                    }
{------------------------------------------------------------------------------}
   TCrpeGroupSelection = class(TCrpePersistentX)
   private
      FFormula : TStrings;
      xFormula : TStrings;
   protected
      function  GetFormula : TStrings;
      procedure SetFormula (ListVar: TStrings);
      procedure OnChangeStrings (Sender: TObject);
   published
      property Formula : TStrings
          read GetFormula
         write SetFormula;
   public
     function  Check : Boolean;
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeGroupSelection }

{------------------------------------------------------------------------------}
{ Class TCrpeGroupSortFieldsItem                                               }
{------------------------------------------------------------------------------}
   TCrpeGroupSortFieldsItem = class(TCrpeItemX)
   private
     FFieldName : string;
     FDirection : TCrSortDirection;
   protected
     procedure SetFieldName (const Value: string);
     procedure SetDirection (const Value: TCrSortDirection);
   published
     property FieldName : string
         read FFieldName
        write SetFieldName;
     property Direction : TCrSortDirection
         read FDirection
        write SetDirection
      default sdAscending;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
   end; { Class TCrpeGroupSortFieldsItem }

{------------------------------------------------------------------------------}
{ Class TCrpeGroupSortFields                                                   }
{------------------------------------------------------------------------------}
   TCrpeGroupSortFields = class(TCrpeContainerX)
   private
      FItem : TCrpeGroupSortFieldsItem;
   protected
      procedure SetIndex (nIndex: integer);
      function  GetItem(nIndex: integer) : TCrpeGroupSortFieldsItem;
   published
      property Number : TCrLookupNumber
          read FIndex
         write SetIndex;
      property Item : TCrpeGroupSortFieldsItem
          read FItem
         write FItem;
   public
      property ItemIndex : integer
          read FIndex
         write SetIndex;
      property Items[nIndex: integer]: TCrpeGroupSortFieldsItem
          read GetItem; default;
     function  Count : integer; override;
//     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     function  Add (FieldName: string) : integer;
     procedure Delete (nIndex: integer);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeGroupSortFields }

{------------------------------------------------------------------------------}
{ Class TCrpeLinesItem                                                         }
{------------------------------------------------------------------------------}
   TCrpeLinesItem = class(TCrpeItemX)
   private
     FSectionStart : string;
     FSectionEnd   : string;
     FLineStyle    : TCrLineStyle;
     FTop          : LongInt;
     FLeft         : LongInt;
     FWidth        : LongInt;
     FRight        : LongInt;
     FBottom       : LongInt;
     FColor        : TColor;
     FExtend       : Boolean; {extend to bottom of section when printing}
     FSuppress     : Boolean;
   protected
     procedure SetSectionStart (const Value: string);
     procedure SetSectionEnd (const Value: string);
     procedure SetLineStyle (const Value: TCrLineStyle);
     procedure SetTop (const Value: LongInt);
     procedure SetLeft (const Value: LongInt);
     procedure SetWidth (const Value: LongInt);
     procedure SetRight (const Value: LongInt);
     procedure SetBottom (const Value: LongInt);
     procedure SetColor (const Value: TColor);
     procedure SetExtend (const Value: Boolean);
     procedure SetSuppress (const Value: Boolean);
   published
     property SectionStart : string
         read FSectionStart
        write SetSectionStart;
     property SectionEnd : string
         read FSectionEnd
        write SetSectionEnd;
     property LineStyle : TCrLineStyle
         read FLineStyle
        write SetLineStyle;
     property Left : LongInt
         read FLeft
        write SetLeft
      default 0;
     property Right : LongInt
         read FRight
        write SetRight
      default 0;
     property Width : LongInt
         read FWidth
        write SetWidth
      default 0;
     property Top : LongInt
         read FTop
        write SetTop
      default 0;
     property Bottom : LongInt
         read FBottom
        write SetBottom
      default 0;
     property Color : TColor
         read FColor
        write SetColor;
     property Extend : Boolean
         read FExtend
        write SetExtend;
     property Suppress : Boolean
         read FSuppress
        write SetSuppress;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     function  StatusIsGo: Boolean;
     constructor Create;
   end; { Class TCrpeLinesItem }

{------------------------------------------------------------------------------}
{ Class TCrpeLines                                                             }
{------------------------------------------------------------------------------}
   TCrpeLines = class(TCrpeContainerX)
   private
     FItem : TCrpeLinesItem;
   protected
     procedure SetIndex (nIndex: integer);
     function  GetItem(nIndex: integer) : TCrpeLinesItem;
   published
     property Number : TCrLookupNumber
         read FIndex
        write SetIndex
      default -1;
     property Item : TCrpeLinesItem
         read FItem
        write FItem;
   public
     property ItemIndex : integer
         read FIndex
        write SetIndex;
     property Items[nIndex: integer]: TCrpeLinesItem
         read GetItem; default;
//     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     function  Count : integer; override;
     function  StatusIsGo: Boolean;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeLines }

{------------------------------------------------------------------------------}
{ Class TCrpeLogOnInfoItem                                                     }
{------------------------------------------------------------------------------}
   TCrpeLogOnInfoItem = class(TCrpeItemX)
   private
     FServerName   : string;
     FUserID       : string;
     FPassword     : string;
     FDatabaseName : string;
     FDLLName      : string;
     FServerType   : string;
     FTableType    : TCrTableType;
   protected
     procedure SetServerName(const Value: string);
     procedure SetUserID(const Value: string);
     procedure SetPassword(const Value: string);
     procedure SetDatabaseName(const Value: string);
     procedure SetTable(const nIndex: integer);
     procedure SetServerType(const Value: string);
   published
     property Table : integer
         read FIndex
        write SetTable;
     property ServerName : string
         read FServerName
        write SetServerName;
     property UserID : string
         read FUserID
        write SetUserID;
     property Password : string
         read FPassword
        write SetPassword;
     property DatabaseName : string
         read FDatabaseName
        write SetDatabaseName;
     property ServerType : string
         read FServerType
        write SetServerType;
   public
     {Read-only properties}
     property DLLName : string
         read FDLLName;
     property TableType : TCrTableType
         read FTableType;
     function  Test : Boolean;
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
   end; { Class TCrpeLogOnInfoItem Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeLogOnInfo                                                         }
{------------------------------------------------------------------------------}
   TCrpeLogOnInfo = class(TCrpeContainerX)
   private
     FSQLTablesOnly : Boolean;
     FItem          : TCrpeLogOnInfoItem;
   protected
     procedure SetIndex (nIndex: integer);
     function  GetItem (nIndex: integer) : TCrpeLogOnInfoItem;
   published
      property Table : TCrLookupNumber
          read FIndex
         write SetIndex
       default -1;
      property SQLTablesOnly : Boolean
          read FSQLTablesOnly
         write FSQLTablesOnly
       default True;
      property Item : TCrpeLogOnInfoItem
          read FItem
         write FItem;
   public
      property ItemIndex : integer
          read FIndex
         write SetIndex;
      {Read-only properties}
      property Items[nIndex: integer]: TCrpeLogOnInfoItem
          read GetItem; default;
     function  Count : integer; override;
//     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeLogOnInfo Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeLogOnServerItem                                                   }
{------------------------------------------------------------------------------}
   TCrpeLogOnServerItem = class(TCrpeItemX)
   private
     FServerName   : string;
     FUserID       : string;
     FPassword     : string;
     FDatabaseName : string;
     FDLLName      : string;
     FLogNumber    : integer;
   protected
     procedure SetServerName(const Value: string);
     procedure SetUserID(const Value: string);
     procedure SetPassword(const Value: string);
     procedure SetDatabaseName(const Value: string);
     procedure SetDLLName(const Value: string);
   published
     property ServerName : string
         read FServerName
        write SetServerName;
     property UserID : string
         read FUserID
        write SetUserID;
     property Password : string
         read FPassword
        write SetPassword;
     property DatabaseName : string
         read FDatabaseName
        write SetDatabaseName;
     property DLLName : string
         read FDLLName
        write SetDLLName;
   public
     property LogNumber : integer
         read FLogNumber;
     procedure Assign(Source: TPersistent); override;
     function  IsLoggedOn : Boolean;
     procedure Clear;
     function  LogOn : Boolean;
     function  LogOff : Boolean;
     constructor Create;
   end;

{------------------------------------------------------------------------------}
{ Class TCrpeLogOnServer                                                       }
{  - Keeps track of logged-on datasources for LogOn/LogOff Server              }
{------------------------------------------------------------------------------}
   TCrpeLogOnServer = class(TCrpeContainerX)
   private
     FList : TList;
     FItem : TCrpeLogOnServerItem;
   protected
     procedure SetIndex (nIndex: integer);
     function  GetItems(nIndex: integer) : TCrpeLogOnServerItem;
     function  GetItem : TCrpeLogOnServerItem;
   published
     property Number : TCrLookupNumber
         read FIndex
        write SetIndex
      default -1;
     property Item : TCrpeLogOnServerItem
         read GetItem
        write FItem;
   public
     property ItemIndex : integer
         read FIndex
        write SetIndex;
     property Items[nIndex: integer]: TCrpeLogOnServerItem
         read GetItems; default;
     procedure Clear;
     function  Add (ServerName: string) : integer;
     procedure Delete (nIndex : integer);
     function  Count : integer; override;
     function  Retrieve : Boolean;
     function  IndexOf(ServerName : string): integer;
     function  IndexOfLogNumber (LogN : integer) : integer;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeLogOnServer Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeMapSummaryFieldsItem                                              }
{------------------------------------------------------------------------------}
  TCrpeMapSummaryFieldsItem = class(TCrpeItemX)
  private
    FFieldName  : string;
  protected
    procedure SetFieldName (const Value: string);
  published
    property FieldName : string
        read FFieldName
       write SetFieldName;
  public
    procedure Assign(Source: TPersistent); override;
    procedure Clear;
    constructor Create;
  end;

TCrpeMapsItem = class;
{------------------------------------------------------------------------------}
{ Class TCrpeMapSummaryFields                                                  }
{------------------------------------------------------------------------------}
  TCrpeMapSummaryFields = class(TCrpeContainerX)
  private
    FItem   : TCrpeMapSummaryFieldsItem;
  protected
    procedure SetIndex (nIndex: integer);
    function  GetItem (nIndex: integer) : TCrpeMapSummaryFieldsItem;
  published
    property Number : TCrLookupNumber
        read FIndex
       write SetIndex
     default -1;
    property Item : TCrpeMapSummaryFieldsItem
        read FItem
       write FItem;
  public
    property ItemIndex : integer
        read FIndex
       write SetIndex;
    property Items[nIndex: integer]: TCrpeMapSummaryFieldsItem
        read GetItem; default;
//    procedure Assign(Source: TPersistent); override;
    procedure Clear;
    function  Count : integer; override;
    constructor Create;
    destructor Destroy; override;
  end;  {TCrpeMapSummaryFields}

TCrpeMapConditionFields = class;
{------------------------------------------------------------------------------}
{ Class TCrpeMapConditionFieldsItem                                            }
{------------------------------------------------------------------------------}
  TCrpeMapConditionFieldsItem = class(TCrpeItemX)
  private
    FFieldName : string;
  protected
    procedure SetFieldName (const Value: string);
  published
    property FieldName : string
        read FFieldName
       write SetFieldName;
  public
    procedure Assign(Source: TPersistent); override;
    procedure Clear;
    constructor Create;
  end;

{------------------------------------------------------------------------------}
{ Class TCrpeMapConditionFields                                                }
{------------------------------------------------------------------------------}
  TCrpeMapConditionFields = class(TCrpeContainerX)
  private
    FItem   : TCrpeMapConditionFieldsItem;
  protected
    procedure SetIndex (nIndex: integer);
    function  GetItem (nIndex: integer) : TCrpeMapConditionFieldsItem;
  published
    property Number : TCrLookupNumber
        read FIndex
       write SetIndex
     default -1;
    property Item : TCrpeMapConditionFieldsItem
        read FItem
       write FItem;
  public
    property ItemIndex : integer
        read FIndex
       write SetIndex;
    property Items[nIndex: integer]: TCrpeMapConditionFieldsItem
        read GetItem; default;
//    procedure Assign(Source: TPersistent); override;
    procedure Clear;
    function  Count : integer; override;
    constructor Create;
    destructor Destroy; override;
  end;

{------------------------------------------------------------------------------}
{ Class TCrpeMapsItem                                                          }
{------------------------------------------------------------------------------}
  TCrpeMapsItem = class(TCrpeObjectItemAX)
  private
    {Layout}
    FLayout               : TCrMapLayout;
    FDontSummarizeValues  : Boolean;
    {Type}
    FMapType              : TCrMapType;
     {Ranged}
    FNumberOfIntervals    : Smallint;
    FDistributionMethod   : TCrMapDistributionMethod;
    FColorHighestInterval : TColor;
    FColorLowestInterval  : TColor;
    FAllowEmptyIntervals  : Boolean;
     {Dot Density}
    FDotSize              : Smallint;
     {Pie}
    FPieSize              : Smallint;
    FPieProportional        : Boolean;
     {Bar}
    FBarSize              : Smallint;
    {Text}
    FTitle                : string;
    FLegend               : TCrMapLegend;
    FLegendTitleType      : TCrMapLegendTitle;
    FLegendTitle          : string;
    FLegendSubTitle       : string;
    {CrossTab/Olap Maps}
    FOrientation          : TCrMapOrientation;
    FGroupSelected        : Boolean;
    FSummaryFields        : TCrpeMapSummaryFields;
    FConditionFields      : TCrpeMapConditionFields;
  protected
    procedure SetLayout (const Value: TCrMapLayout);
    procedure SetDontSummarizeValues (const Value: Boolean);
    procedure SetMapType (const Value: TCrMapType);
    procedure SetNumberOfIntervals (const Value: Smallint);
    procedure SetDotSize (const Value: Smallint);
    procedure SetPieSize (const Value: Smallint);
    procedure SetBarSize (const Value: Smallint);
    procedure SetAllowEmptyIntervals (const Value: Boolean);
    procedure SetPieProportional (const Value: Boolean);
    procedure SetDistributionMethod (const Value: TCrMapDistributionMethod);
    procedure SetColorLowestInterval (const Value: TColor);
    procedure SetColorHighestInterval (const Value: TColor);
    procedure SetLegend (const Value: TCrMapLegend);
    procedure SetLegendTitleType (const Value: TCrMapLegendTitle);
    procedure SetTitle (const Value: string);
    procedure SetLegendTitle (const Value: string);
    procedure SetLegendSubTitle (const Value: string);
    procedure SetOrientation (const Value: TCrMapOrientation);
    procedure SetGroupSelected (const Value: Boolean);
  published
    property Layout : TCrMapLayout
        read FLayout
       write SetLayout
     default mlGroup;
    property DontSummarizeValues : Boolean
        read FDontSummarizeValues
       write SetDontSummarizeValues
     default False;
    property MapType : TCrMapType
        read FMapType
       write SetMapType
     default mttRanged;
    property NumberOfIntervals : Smallint
        read FNumberOfIntervals
       write SetNumberOfIntervals
     default 5;
    property DotSize : Smallint
        read FDotSize
       write SetDotSize
     default 0;
    property PieSize : Smallint
        read FPieSize
       write SetPieSize
     default 0;
    property BarSize : Smallint
        read FBarSize
       write SetBarSize
     default 0;
    property AllowEmptyIntervals : Boolean
        read FAllowEmptyIntervals
       write SetAllowEmptyIntervals
     default True;
    property PieProportional : Boolean
        read FPieProportional
       write SetPieProportional
     default True;
    property DistributionMethod : TCrMapDistributionMethod
        read FDistributionMethod
       write SetDistributionMethod
     default mdmEqualCount;
    property ColorLowestInterval : TColor
        read FColorLowestInterval
       write SetColorLowestInterval
     default clBlack;
    property ColorHighestInterval : TColor
        read FColorHighestInterval
       write SetColorHighestInterval
     default clWhite;
    property Legend : TCrMapLegend
        read FLegend
       write SetLegend
     default mlFull;
    property LegendTitleType : TCrMapLegendTitle
        read FLegendTitleType
       write SetLegendTitleType
     default mltAuto;
    property Title : string
        read FTitle
       write SetTitle;
    property LegendTitle : string
        read FLegendTitle
       write SetLegendTitle;
    property LegendSubTitle : string
        read FLegendSubTitle
       write SetLegendSubTitle;
    property Orientation : TCrMapOrientation
        read FOrientation
       write SetOrientation
     default moRowsOnly;
    property GroupSelected : Boolean
        read FGroupSelected
       write SetGroupSelected
     default True;
    property SummaryFields : TCrpeMapSummaryFields
        read FSummaryFields
       write FSummaryFields;
    property ConditionFields : TCrpeMapConditionFields
        read FConditionFields
       write FConditionFields;
  public
    procedure Assign(Source: TPersistent); override;
    procedure Clear;
    constructor Create;
    destructor Destroy; override;
  end;  { TCrpeMapsItem }

{------------------------------------------------------------------------------}
{ Class TCrpeMaps                                                              }
{------------------------------------------------------------------------------}
  TCrpeMaps = class(TCrpeObjectContainerAX)
  private
  protected
    procedure SetIndex (nIndex: integer);
    function  GetItems (nIndex: integer) : TCrpeMapsItem;
    function  GetItem : TCrpeMapsItem;
    procedure SetItem (const nItem: TCrpeMapsItem);
  published
    property Number : TCrLookupNumber
        read FIndex
       write SetIndex
     default -1;
    property Item : TCrpeMapsItem
        read GetItem
       write SetItem;
  public
    property ItemIndex : integer
        read FIndex
       write SetIndex;
    property Items[nIndex: integer]: TCrpeMapsItem
        read GetItems; default;
//    procedure Assign(Source: TPersistent); override;
    procedure Clear;
    constructor Create;
    destructor Destroy; override;
  end;  { TCrpeMaps }

{------------------------------------------------------------------------------}
{ Class TCrpeMargins                                                           }
{------------------------------------------------------------------------------}
   TCrpeMargins = class(TCrpePersistentX)
   private
      FTop    : Smallint;
      FBottom : Smallint;
      FLeft   : Smallint;
      FRight  : Smallint;
   protected
     function  GetLeft : Smallint;
     procedure SetLeft (const Value: Smallint);
     function  GetRight : Smallint;
     procedure SetRight (const Value: Smallint);
     function  GetTop : Smallint;
     procedure SetTop (const Value: Smallint);
     function  GetBottom : Smallint;
     procedure SetBottom (const Value: Smallint);
   published
      property Left : Smallint
          read GetLeft
         write SetLeft
       default -1;
      property Right : Smallint
          read GetRight
         write SetRight
       default -1;
      property Top : Smallint
          read GetTop
         write SetTop
       default -1;
      property Bottom : Smallint
          read GetBottom
         write SetBottom
       default -1;
   public
     procedure Clear;
     constructor Create;
   end; { Class TCrpeMargins Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeOLAPCubesItem                                                     }
{------------------------------------------------------------------------------}
  TCrpeOLAPCubesItem = class(TCrpeObjectItemAX)
  private
    FServerName       : string;
    {User ID and password used to logo to the OLAP datasource}
    FUserID           : string;
    FPassword         : string;
    FDatabaseName     : string;
    FConnectionString : string;
    FCubeName         : string;
  protected
    procedure SetServerName(const Value: string);
    procedure SetDatabaseName(const Value: string);
    procedure SetConnectionString(const Value: string);
    procedure SetCubeName(const Value: string);
    procedure SetUserID(const Value: string);
    procedure SetPassword(const Value: string);
  published
    property ServerName : string
        read FServerName
       write SetServerName;
    property DatabaseName : string
        read FDatabaseName
       write SetDatabaseName;
    property ConnectionString : string
        read FConnectionString
       write SetConnectionString;
    property CubeName : string
        read FCubeName
       write SetCubeName;
    property UserID : string
        read FUserID
       write SetUserID;
    property Password : string
        read FPassword
       write SetPassword;
  public
    procedure Clear;
    function  Test : Boolean;
    procedure Assign(Source: TPersistent); override;
    constructor Create;
  end;  { TCrpeOLAPCubesItem }

{------------------------------------------------------------------------------}
{ Class TCrpeOLAPCubes                                                         }
{------------------------------------------------------------------------------}
  TCrpeOLAPCubes = class(TCrpeObjectContainerAX)
  private
  protected
    procedure SetIndex (nIndex: integer);
    function  GetItems (nIndex: integer) : TCrpeOLAPCubesItem;
    function  GetItem : TCrpeOLAPCubesItem;
    procedure SetItem (const nItem : TCrpeOLAPCubesItem);
  published
    property Number : TCrLookupNumber
        read FIndex
       write SetIndex
     default -1;
    property Item : TCrpeOLAPCubesItem
        read GetItem
       write SetItem;
  public
    property ItemIndex : integer
        read FIndex
       write SetIndex;
    property Items[nIndex: integer]: TCrpeOLAPCubesItem
        read GetItems; default;
    procedure Clear;
//    procedure Assign(Source: TPersistent); override;
    constructor Create;
    destructor Destroy; override;
  end;  { TCrpeOLAPCubes }

{------------------------------------------------------------------------------}
{ Class TCrpeOleObjectsItem                                                    }
{------------------------------------------------------------------------------}
  TCrpeOleObjectsItem = class(TCrpeObjectItemAX)
  private
    FOleType    : TCrOleObjectType;
    FUpdateType : TCrOleUpdateType;
    FLinkSource : string;
  protected
    procedure SetOleType (const Value: TCrOleObjectType);
    procedure SetUpdateType (const Value: TCrOleUpdateType);
    procedure SetLinkSource (const Value: string);
  published
    property OleType : TCrOleObjectType
        read FOleType
       write SetOleType
     default ootStatic;
    property UpdateType : TCrOleUpdateType
        read FUpdateType
       write SetUpdateType
     default AutoUpdate;
    property LinkSource : string
        read FLinkSource
       write SetLinkSource;
  public
//    procedure Assign(Source: TPersistent); override;
    procedure Clear;
    constructor Create;
  end;  { TCrpeOleObjectsItem }

{------------------------------------------------------------------------------}
{ Class TCrpeOleObjects                                                        }
{------------------------------------------------------------------------------}
  TCrpeOleObjects = class(TCrpeObjectContainerAX)
  private
  protected
    procedure SetIndex (nIndex: integer);
    function  GetItems (nIndex: integer) : TCrpeOleObjectsItem;
    function  GetItem : TCrpeOleObjectsItem;
    procedure SetItem (const nItem: TCrpeOleObjectsItem);
  published
    property Number : TCrLookupNumber
        read FIndex
       write SetIndex
     default -1;
    property Item : TCrpeOleObjectsItem
        read GetItem
       write SetItem;
  public
    property ItemIndex : integer
        read FIndex
       write SetIndex;
    property Items[nIndex: integer]: TCrpeOleObjectsItem
        read GetItems; default;
//    procedure Assign(Source: TPersistent); override;
    procedure Clear;
    constructor Create;
    destructor Destroy; override;
  end;  { TCrpeOleObjects }

{------------------------------------------------------------------------------}
{ Class TCrpePages                                                             }
{------------------------------------------------------------------------------}
   TCrpePages = class(TCrpePersistentX)
   private
     FStartPageNumber : LongInt;
   protected
     function  GetStartPageNumber : LongInt;
     procedure SetStartPageNumber (const Value: LongInt);
     function  GetIndex : integer;
     procedure SetIndex (nIndex: integer);
     function  GetItem (nIndex: integer) : string;
   published
      property StartPageNumber : LongInt
          read GetStartPageNumber
         write SetStartPageNumber
       default 1;
   public
     property ItemIndex : integer
         read GetIndex
        write SetIndex;
     property Items[nIndex: integer]: string
         read GetItem; default;
     function  GetDisplayed : Word;
     function  GetLatest : Word;
     function  GetStart : Word;
     function  Count : Smallint;
     procedure First;
     procedure Next;
     procedure Previous;
     procedure Last;
     procedure GoToPage(const Value : Smallint);
     constructor Create;
   end; { Class TCrpePages Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeParamFieldInfo                                                    }
{------------------------------------------------------------------------------}
   TCrpeParamFieldInfo = class(TCrpePersistentX)
   private
     FAllowNull              : Boolean;
     FAllowEditing           : Boolean;
     FAllowMultipleValues    : Boolean;
     FPartOfGroup            : Boolean;
     FMutuallyExclusiveGroup : Boolean;
     FValueType              : TCrParamInfoValueType;
     FGroupNum               : Smallint;
   protected
     procedure SetAllowNull (const Value: Boolean);
     procedure SetAllowEditing (const Value: Boolean);
     procedure SetAllowMultipleValues (const Value: Boolean);
     procedure SetValueType (const Value: TCrParamInfoValueType);
     procedure SetPartOfGroup (const Value: Boolean);
     procedure SetMutuallyExclusiveGroup (const Value: Boolean);
     procedure SetGroupNum (const Value: Smallint);
   published
     property AllowNull : Boolean
         read FAllowNull
        write SetAllowNull;
     property AllowEditing : Boolean
         read FAllowEditing
        write SetAllowEditing;
     property AllowMultipleValues : Boolean
         read FAllowMultipleValues
        write SetAllowMultipleValues;
     property ValueType : TCrParamInfoValueType
         read FValueType
        write SetValueType;
     property PartOfGroup : Boolean
         read FPartOfGroup
        write SetPartOfGroup;
     property MutuallyExclusiveGroup : Boolean
         read FMutuallyExclusiveGroup
        write SetMutuallyExclusiveGroup;
     property GroupNum : Smallint
         read FGroupNum
        write SetGroupNum;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
   end; { Class TCrpeParamFieldInfo }

TCrpeParamFieldRanges = class;
{------------------------------------------------------------------------------}
{ Class TCrpeParamFieldRangesItem                                              }
{------------------------------------------------------------------------------}
   TCrpeParamFieldRangesItem = class(TCrpeItemX)
   private
     FRangeStart : string;
     FRangeEnd   : string;
     FBounds     : TCrRangeBounds;
   protected
     procedure SetRangeStart (const Value: string);
     procedure SetRangeEnd (const Value: string);
     procedure SetBounds (const Value: TCrRangeBounds);
   published
      property RangeStart : string
          read FRangeStart
         write SetRangeStart;
      property RangeEnd : string
          read FRangeEnd
         write SetRangeEnd;
      property Bounds : TCrRangeBounds
          read FBounds
         write SetBounds;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     function  Send : Boolean;
     constructor Create;
   end; { Class TCrpeParamFieldRangesItem }

{------------------------------------------------------------------------------}
{ Class TCrpeParamFieldRanges                                                  }
{------------------------------------------------------------------------------}
   TCrpeParamFieldRanges = class(TCrpeContainerX)
   private
     FItem   : TCrpeParamFieldRangesItem;
   protected
     procedure SetIndex (nIndex: integer);
     function  GetItem (nIndex: integer) : TCrpeParamFieldRangesItem;
   published
     property Number : TCrLookupNumber
         read FIndex
        write SetIndex
      default -1;
     property Item : TCrpeParamFieldRangesItem
         read FItem
        write FItem;
   public
     property ItemIndex : integer
         read FIndex
        write SetIndex;
     property Items[nIndex: integer]: TCrpeParamFieldRangesItem
         read GetItem; default;
     function  Count : integer; override;
     function  Add : integer;
     procedure Delete (nIndex : integer);
//     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeParamFieldRanges }

TCrpeParamFieldPromptValues = class;
{------------------------------------------------------------------------------}
{ Class TCrpeParamFieldPromptValuesItem                                        }
{------------------------------------------------------------------------------}
   TCrpeParamFieldPromptValuesItem = class(TCrpeItemX)
   private
     FText        : string;
     FDescription : string;
   protected
     procedure SetText (const Value: string);
     procedure SetDescription (const Value: string);
   published
     property Text : string
         read FText
        write SetText;
     property Description : string
         read FDescription
        write SetDescription;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
   end; { Class TCrpeParamFieldPromptValuesItem }

{------------------------------------------------------------------------------}
{ Class TCrpeParamFieldPromptValues                                            }
{------------------------------------------------------------------------------}
   TCrpeParamFieldPromptValues = class(TCrpeContainerX)
   private
     FDescriptionOnly   : Boolean;
     FSortMethod        : TCrPickListSortMethod;
     FSortByDescription : Boolean;
     FItem              : TCrpeParamFieldPromptValuesItem;
   protected
     procedure SetDescriptionOnly (const Value: Boolean);
     procedure SetSortMethod (const Value: TCrPickListSortMethod);
     procedure SetSortByDescription (const Value: Boolean);
     procedure SetIndex (nIndex: integer);
     function  GetItem (nIndex: integer) : TCrpeParamFieldPromptValuesItem;
   published
     property Number : TCrLookupNumber
         read FIndex
        write SetIndex
      default -1;
     property DescriptionOnly : Boolean
         read FDescriptionOnly
        write SetDescriptionOnly
      default False;
     property SortMethod : TCrPickListSortMethod
         read FSortMethod
        write SetSortMethod
      default psmNoSort;
     property SortByDescription : Boolean
         read FSortByDescription
        write SetSortByDescription
      default False;
     property Item : TCrpeParamFieldPromptValuesItem
         read FItem
        write FItem;
   public
     property ItemIndex : integer
         read FIndex
        write SetIndex;
     property Items[nIndex: integer]: TCrpeParamFieldPromptValuesItem
         read GetItem; default;
     function  Count : integer; override;
     function  Add (const Value: string) : integer;
     procedure Delete (nIndex : integer);
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeParamFieldPromptValues }


TCrpeParamFieldCurrentValues = class;
{------------------------------------------------------------------------------}
{ Class TCrpeParamFieldCurrentValuesItem                                       }
{------------------------------------------------------------------------------}
   TCrpeParamFieldCurrentValuesItem = class(TCrpeItemX)
   private
     FText   : string;
   protected
     procedure SetText (const Value: string);
   published
     property Text : string
         read FText
        write SetText;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
   end; { Class TCrpeParamFieldCurrentValuesItem }

{------------------------------------------------------------------------------}
{ Class TCrpeParamFieldCurrentValues                                           }
{------------------------------------------------------------------------------}
   TCrpeParamFieldCurrentValues = class(TCrpeContainerX)
   private
     FItem   : TCrpeParamFieldCurrentValuesItem;
   protected
     procedure SetIndex (nIndex: integer);
     function  GetItem (nIndex: integer) : TCrpeParamFieldCurrentValuesItem;
   published
     property Number : TCrLookupNumber
         read FIndex
        write SetIndex
      default -1;
     property Item : TCrpeParamFieldCurrentValuesItem
         read FItem
        write FItem;
   public
     property ItemIndex : integer
         read FIndex
        write SetIndex;
     property Items[nIndex: integer]: TCrpeParamFieldCurrentValuesItem
         read GetItem; default;
     function  Count : integer; override;
     function  Add (const Value: string) : integer;
     procedure Delete (nIndex : integer);
//     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeParamFieldCurrentValues }

{------------------------------------------------------------------------------}
{ Class TCrpeParamFieldsItem                                                   }
{------------------------------------------------------------------------------}
   TCrpeParamFieldsItem = class(TCrpeFieldObjectItemX)
   private
     FName              : string;
     FPrompt            : string;
     FPromptValue       : string;
     FCurrentValue      : string;
     FShowDialog        : Boolean;
     FParamType         : TCrParamFieldType;
     FReportName        : string;
     FNeedsCurrentValue : Boolean;
     {CR7+}
     FRanges            : TCrpeParamFieldRanges;
     FInfo              : TCrpeParamFieldInfo;
     FPromptValues      : TCrpeParamFieldPromptValues;
     FCurrentValues     : TCrpeParamFieldCurrentValues;
     FParamSource       : TCrParamFieldSource;
     FValueLimit        : Boolean;
     FValueMin          : string;
     FValueMax          : string;
     FEditMask          : string;
     FBrowseField       : string;
     FIsLinked          : Boolean;
   protected
     procedure SetName (const Value: string);
     procedure SetPrompt (const Value: string);
     procedure SetPromptValue (const Value: string);
     procedure SetCurrentValue (const Value: string);
     procedure SetShowDialog (const Value: Boolean);
     procedure SetParamType (const Value: TCrParamFieldType);
     procedure SetReportName (const Value: string);
     procedure SetNeedsCurrentValue (const Value: Boolean);
     procedure SetIsLinked (const Value: Boolean);
     {CR 7+}
     procedure SetParamSource (const Value: TCrParamFieldSource);
     procedure SetValueLimit (const Value: Boolean);
     procedure SetValueMin (const Value: string);
     procedure SetValueMax (const Value: string);
     procedure SetEditMask (const Value: string);
     procedure SetBrowseField (const Value: string);
   published
     property Name : string
         read FName
        write SetName;
     property Prompt : string
         read FPrompt
        write SetPrompt;
     property PromptValue : string
         read FPromptValue
        write SetPromptValue;
     property CurrentValue : string
         read FCurrentValue
        write SetCurrentValue;
     property ShowDialog : Boolean
         read FShowDialog
        write SetShowDialog
      default False;
     property ParamType : TCrParamFieldType
         read FParamType
        write SetParamType;
     property ParamSource : TCrParamFieldSource
         read FParamSource
        write SetParamSource;
     property EditMask : string
         read FEditMask
        write SetEditMask;
     property Info : TCrpeParamFieldInfo
         read FInfo
        write FInfo;
     property PromptValues : TCrpeParamFieldPromptValues
         read FPromptValues
        write FPromptValues;
     property CurrentValues : TCrpeParamFieldCurrentValues
         read FCurrentValues
        write FCurrentValues;
     property ValueLimit : Boolean
         read FValueLimit
        write SetValueLimit;
     property ValueMin : string
         read FValueMin
        write SetValueMin;
     property ValueMax : string
         read FValueMax
        write SetValueMax;
     property Ranges : TCrpeParamFieldRanges
         read FRanges
        write FRanges;
     property BrowseField : string
         read FBrowseField
        write SetBrowseField;
     {Read only properties}
     property ReportName : string
         read FReportName
        write SetReportName;
     property NeedsCurrentValue : Boolean
         read FNeedsCurrentValue
        write SetNeedsCurrentValue;
     property IsLinked : Boolean
         read FIsLinked
        write SetIsLinked;
   public
     function  ParamTypeAsString: string;
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeParamFieldsItem }


{------------------------------------------------------------------------------}
{ Class TCrpeParamFields                                                       }
{------------------------------------------------------------------------------}
   TCrpeParamFields = class(TCrpeFieldObjectContainerX)
   private
      FNames                  : TStrings;
      FReportNames            : TStrings;
      FAllowDialog            : Boolean;
      FObjectPropertiesActive : Boolean;
   protected
     procedure SetIndex (nIndex: integer);
     procedure SetAllowDialog (const Value: Boolean);
     procedure SetObjectPropertiesActive (const Value: Boolean);
     function  GetItems (nIndex: integer) : TCrpeParamFieldsItem;
     function  GetItem : TCrpeParamFieldsItem;
     procedure SetItem (const nItem: TCrpeParamFieldsItem);
   published
     property Number : TCrLookupNumber
         read FIndex
        write SetIndex
      default -1;
     property AllowDialog : Boolean
         read FAllowDialog
        write SetAllowDialog;
     property Item : TCrpeParamFieldsItem
         read GetItem
        write SetItem;
     property ObjectPropertiesActive : Boolean
         read FObjectPropertiesActive
        write SetObjectPropertiesActive
      default True;
   public
     property ItemIndex : integer
         read FIndex
        write SetIndex;
     property Items[nIndex: integer]: TCrpeParamFieldsItem
         read GetItems; default;
     function  Names : TStrings;
     function  Count : integer; override;
//     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     function  IndexOf (ParamFieldName, ReportName: string): integer;
     function  ByName (ParamFieldName: string; ReportName: string): TCrpeParamFieldsItem;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeParamFields }

{------------------------------------------------------------------------------}
{ Class TCrpePicturesItem                                                      }
{------------------------------------------------------------------------------}
   TCrpePicturesItem = class(TCrpeObjectItemAX)
   private
     FCropLeft      : LongInt;
     FCropRight     : LongInt;
     FCropTop       : LongInt;
     FCropBottom    : LongInt;
     FScalingWidth  : Double;
     FScalingHeight : Double;
     FCanGrow       : Boolean; {Format property isn't inherited in FormatA}
   protected
     procedure SetCropLeft (const Value: LongInt);
     procedure SetCropRight (const Value: LongInt);
     procedure SetCropTop (const Value: LongInt);
     procedure SetCropBottom (const Value: LongInt);
     procedure SetScalingWidth (const Value: Double);
     procedure SetScalingHeight (const Value: Double);
     function  GetCanGrow : Boolean;
     procedure SetCanGrow (const Value: Boolean);
   published
     property CropLeft : LongInt
         read FCropLeft
        write SetCropLeft;
     property CropRight : LongInt
         read FCropRight
        write SetCropRight;
     property CropTop : LongInt
         read FCropTop
        write SetCropTop;
     property CropBottom : LongInt
         read FCropBottom
        write SetCropBottom;
     property ScalingWidth : Double
         read FScalingWidth
        write SetScalingWidth;
     property ScalingHeight : Double
         read FScalingHeight
        write SetScalingHeight;
     property CanGrow : Boolean
         read GetCanGrow
        write SetCanGrow
      default False;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
   end; { Class TCrpePicturesItem }

{------------------------------------------------------------------------------}
{ Class TCrpePictures                                                          }
{------------------------------------------------------------------------------}
   TCrpePictures = class(TCrpeObjectContainerAX)
   private
   protected
     procedure SetIndex (nIndex: integer);
     function  GetItems (nIndex: integer) : TCrpePicturesItem;
     function  GetItem : TCrpePicturesItem;
     procedure SetItem (const nItem: TCrpePicturesItem);
   published
     property Number : TCrLookupNumber
         read FIndex
        write SetIndex
      default -1;
     property Item : TCrpePicturesItem
         read GetItem
        write SetItem;
   public
     property ItemIndex : integer
         read FIndex
        write SetIndex;
     property Items[nIndex: integer]: TCrpePicturesItem
         read GetItems; default;
//     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpePictures }

{------------------------------------------------------------------------------}
{ Class TCrpePrintDate                                                         }
{------------------------------------------------------------------------------}
   TCrpePrintDate = class(TCrpePersistentX)
   private
      FDay    : Smallint;
      FMonth  : Smallint;
      FYear   : Smallint;
   protected
     function  GetDay : Smallint;
     procedure SetDay (const Value: Smallint);
     function  GetMonth : Smallint;
     procedure SetMonth (const Value: Smallint);
     function  GetYear : Smallint;
     procedure SetYear (const Value: Smallint);
   published
      property Day : Smallint
          read GetDay
         write SetDay;
      property Month : Smallint
          read GetMonth
         write SetMonth;
      property Year : Smallint
          read GetYear
         write SetYear;
   public
     procedure Clear;
     constructor Create;
   end; { Class TCrpePrintDate Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpePrinter                                                           }
{------------------------------------------------------------------------------}
   TCrpePrinter = class(TCrpePersistentX)
   private
      FName                : string;
      FDriver              : string;
      FPort                : string;
      FMode                : THandle;
      FPMode               : PDevMode;
      FOrientation         : TCrOrientation;
      FPreserveRptSettings : TCrPreserveRptSettings;
   protected
     procedure SetMode(const Value : THandle);
     procedure SetPMode(const Value : PDevMode);
     function  GetPrinterInfoFromName(PrtName: string): Boolean;
     function  GetDMPointerFromHandle(xHandle: THandle): PDevMode;
   published
      property Name : string
          read FName
         write FName;
      property Driver : string
          read FDriver
         write FDriver;
      property Port : string
          read FPort
         write FPort;
      property Orientation : TCrOrientation
          read FOrientation
         write FOrientation
       default orDefault;
      property PreserveRptSettings : TCrPreserveRptSettings
          read FPreserveRptSettings
         write FPreserveRptSettings
       default [];
   public
      property Mode: THandle
          read FMode
         write SetMode;
      property PMode: PDevMode
          read FPMode
         write SetPMode;
     function  Retrieve : Boolean;
     function  RetrieveFromReport (var sName: string; var sDriver: string;
                 var sPort: string; var pxDevMode: PDevMode) : Boolean;
     function  GetCurrent(PreserveDevMode: Boolean) : Boolean;
     function  SetCurrent: Boolean;
     procedure GetPrinterNames(List: TStrings);
     function  Prompt : Boolean;
     procedure Clear;
     function  Send : Boolean;
     procedure FreeDevMode;
     constructor Create;
   end; { Class TCrpePrinter Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpePrintOptions                                                      }
{------------------------------------------------------------------------------}
   TCrpePrintOptions = class(TCrpePersistentX)
   private
      FCollation      : Boolean;
      FCopies,
      FStartPage,
      FStopPage       : Word;
      FOutputFileName : string; {limited to 512 characters}
   protected
     function  GetCollation : Boolean;
     procedure SetCollation (const Value: Boolean);
     function  GetCopies : Word;
     procedure SetCopies (const Value: Word);
     function  GetStartPage : Word;
     procedure SetStartPage (const Value: Word);
     function  GetStopPage : Word;
     procedure SetStopPage (const Value: Word);
     function  GetOutputFileName : string;
     procedure SetOutputFileName(const Value: string);
   published
      property Copies : Word
          read GetCopies
         write SetCopies
       default 1;
      property Collation : Boolean
          read GetCollation
         write SetCollation
       default True;
      property StartPage : Word
          read GetStartPage
         write SetStartPage
       default 0;
      property StopPage : Word
          read GetStopPage
         write SetStopPage
       default 0;
      property OutputFileName : string
          read FOutputFileName
         write SetOutputFileName;
   public
     function  Prompt : Boolean;
     procedure Clear;
     constructor Create;
   end; { Class TCrpePrintOptions Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeRecords                                                           }
{------------------------------------------------------------------------------}
   TCrpeRecords = class(TCrpePersistentX)
   private
   protected
   published
   public
     function Printed     : LongInt;
     function Selected    : LongInt;
     function Read        : LongInt;
     function PercentRead : LongInt;
     function PercentCompleted : LongInt;
     procedure SetRecordLimit (const Value: LongInt);
     procedure SetTimeLimit (const Value: LongInt); {in seconds}
   end; { Class TCrpeRecords Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeGlobalOptions                                                     }
{------------------------------------------------------------------------------}
    TCrpeGlobalOptions = class(TCrpePersistentX)
    private
      FMorePrintEngineErrorMessages : TCrBoolean;
      FMatchLogOnInfo               : TCrBoolean;
      FUse70TextCompatibility       : TCrBoolean;
      FDisableThumbnailUpdates      : TCrBoolean;
  	  FVerifyWhenDatabaseDriverUpgraded : TCrBoolean;
    protected
      function  GetDefault: TCrBoolean;
      procedure SetMorePrintEngineErrorMessages(const Value: TCrBoolean);
      procedure SetMatchLogOnInfo(const Value: TCrBoolean);
      procedure SetUse70TextCompatibility(const Value: TCrBoolean);
      procedure SetDisableThumbnailUpdates(const Value: TCrBoolean);
      procedure SetVerifyWhenDatabaseDriverUpgraded(const Value: TCrBoolean);
    published
      property MorePrintEngineErrorMessages : TCrBoolean
          read GetDefault
         write SetMorePrintEngineErrorMessages
       default cDefault;
      property MatchLogOnInfo : TCrBoolean
          read GetDefault
         write SetMatchLogOnInfo
       default cDefault;
      property Use70TextCompatibility : TCrBoolean
          read GetDefault
         write SetUse70TextCompatibility
       default cDefault;
      property DisableThumbnailUpdates : TCrBoolean
          read GetDefault
         write SetDisableThumbnailUpdates
       default cDefault;
      property VerifyWhenDatabaseDriverUpgraded : TCrBoolean
          read GetDefault
         write SetVerifyWhenDatabaseDriverUpgraded
       default cDefault;
    public
      procedure Clear;
      constructor Create;
    end; { Class TCrpeGlobalOptions }

{------------------------------------------------------------------------------}
{ Class TCrpeReportOptions                                                     }
{------------------------------------------------------------------------------}
   TCrpeReportOptions = class(TCrpePersistentX)
   private
      FSaveDataWithReport,
      FSaveSummariesWithReport,
      FUseIndexForSpeed,
      FConvertNullFieldToDefault,
      FPrintEngineErrorMessages,
      FCaseInsensitiveSQLData,
      FVerifyOnEveryPrint,
      FCreateGroupTree,
      FNoDataForHiddenObjects,
      FPerformGroupingOnServer          : Boolean;
      FConvertDateTimeType              : TCrDateTimeType;
      FZoomMode                         : TCrZoomPreview;
      FAsyncQuery                       : Boolean;
      {CR 8}
      FPromptMode                       : TCrPromptMode;
      FSelectDistinctRecords            : Boolean;
      {CR 8.5+}
      FAlwaysSortLocally                : Boolean;
      FIsReadOnly                       : Boolean;  {read-only}
      FCanSelectDistinctRecords         : Boolean;  {read-only}
      {CR9}
      FUseDummyData                     : Boolean;
      FConvertOtherNullsToDefault       : Boolean;
      FVerifyStoredProcOnRefresh        : Boolean;
      FRetainImageColourDepth           : Boolean;
   protected
      function  GetSaveDataWithReport : Boolean;
      procedure SetSaveDataWithReport(const Value: Boolean);
      function  GetSaveSummariesWithReport : Boolean;
      procedure SetSaveSummariesWithReport(const Value: Boolean);
      function  GetUseIndexForSpeed : Boolean;
      procedure SetUseIndexForSpeed(const Value: Boolean);
      function  GetConvertNullFieldToDefault : Boolean;
      procedure SetConvertNullFieldToDefault(const Value: Boolean);
      function  GetPrintEngineErrorMessages : Boolean;
      procedure SetPrintEngineErrorMessages(const Value: Boolean);
      function  GetCaseInsensitiveSQLData : Boolean;
      procedure SetCaseInsensitiveSQLData(const Value: Boolean);
      function  GetVerifyOnEveryPrint : Boolean;
      procedure SetVerifyOnEveryPrint(const Value: Boolean);
      function  GetCreateGroupTree : Boolean;
      procedure SetCreateGroupTree(const Value: Boolean);
      function  GetNoDataForHiddenObjects : Boolean;
      procedure SetNoDataForHiddenObjects(const Value: Boolean);
      function  GetPerformGroupingOnServer : Boolean;
      procedure SetPerformGroupingOnServer(const Value: Boolean);
      function  GetConvertDateTimeType : TCrDateTimeType;
      procedure SetConvertDateTimeType(const Value: TCrDateTimeType);
      function  GetZoomMode : TCrZoomPreview;
      procedure SetZoomMode(const Value: TCrZoomPreview);
      function  GetAsyncQuery : Boolean;
      procedure SetAsyncQuery(const Value: Boolean);
      {CR 8}
      function  GetPromptMode : TCrPromptMode;
      procedure SetPromptMode(const Value: TCrPromptMode);
      function  GetSelectDistinctRecords : Boolean;
      procedure SetSelectDistinctRecords(const Value: Boolean);
      {CR 8.5+}
      function  GetAlwaysSortLocally : Boolean;
      procedure SetAlwaysSortLocally(const Value: Boolean);
      function  GetIsReadOnly : Boolean;
      procedure SetIsReadOnly(const Value: Boolean);
      function  GetCanSelectDistinctRecords : Boolean;
      procedure SetCanSelectDistinctRecords(const Value: Boolean);
      {CR9}
      function  GetUseDummyData : Boolean;
      procedure SetUseDummyData(const Value: Boolean);
      function  GetConvertOtherNullsToDefault : Boolean;
      procedure SetConvertOtherNullsToDefault(const Value: Boolean);
      function  GetVerifyStoredProcOnRefresh : Boolean;
      procedure SetVerifyStoredProcOnRefresh(const Value: Boolean);
      function  GetRetainImageColourDepth : Boolean;
      procedure SetRetainImageColourDepth(const Value: Boolean);
   published
      property SaveDataWithReport : Boolean
          read GetSaveDataWithReport
         write SetSaveDataWithReport
       default True;
      property SaveSummariesWithReport : Boolean
          read GetSaveSummariesWithReport
         write SetSaveSummariesWithReport
       default True;
      property UseIndexForSpeed : Boolean
          read GetUseIndexForSpeed
         write SetUseIndexForSpeed
       default True;
      property ConvertNullFieldToDefault : Boolean
          read GetConvertNullFieldToDefault
         write SetConvertNullFieldToDefault
       default False;
      property PrintEngineErrorMessages : Boolean
          read GetPrintEngineErrorMessages
         write SetPrintEngineErrorMessages
       default True;
      property CaseInsensitiveSQLData : Boolean
          read GetCaseInsensitiveSQLData
         write SetCaseInsensitiveSQLData
       default True;
      property VerifyOnEveryPrint : Boolean
          read GetVerifyOnEveryPrint
         write SetVerifyOnEveryPrint
       default False;
      property CreateGroupTree : Boolean
          read GetCreateGroupTree
         write SetCreateGroupTree
       default True;
      property NoDataForHiddenObjects : Boolean
          read GetNoDataForHiddenObjects
         write SetNoDataForHiddenObjects
       default False;
      property PerformGroupingOnServer : Boolean
          read GetPerformGroupingOnServer
         write SetPerformGroupingOnServer
       default False;
      property ConvertDateTimeType : TCrDateTimeType
          read GetConvertDateTimeType
         write SetConvertDateTimeType
       default ToDateTime;
      property ZoomMode : TCrZoomPreview
          read GetZoomMode
         write SetZoomMode
       default pwNormal;
      property AsyncQuery : Boolean
          read GetAsyncQuery
         write SetAsyncQuery
       default False;
      {CR 8}
      property PromptMode : TCrPromptMode
          read GetPromptMode
         write SetPromptMode
       default pmNormal;
      property SelectDistinctRecords : Boolean
          read GetSelectDistinctRecords
         write SetSelectDistinctRecords
       default False;
      {CR 8.5+}
      property AlwaysSortLocally : Boolean
          read GetAlwaysSortLocally
         write SetAlwaysSortLocally
       default True;
      property IsReadOnly : Boolean
          read GetIsReadOnly
         write SetIsReadOnly
       default False;
      property CanSelectDistinctRecords : Boolean
          read GetCanSelectDistinctRecords
         write SetCanSelectDistinctRecords
       default True;
      {CR9}
      property UseDummyData : Boolean
          read GetUseDummyData
         write SetUseDummyData
       default False;
      property ConvertOtherNullsToDefault : Boolean
          read GetConvertOtherNullsToDefault
         write SetConvertOtherNullsToDefault
       default False;
      property VerifyStoredProcOnRefresh : Boolean
          read GetVerifyStoredProcOnRefresh
         write SetVerifyStoredProcOnRefresh
       default False;
      property RetainImageColourDepth : Boolean
          read GetRetainImageColourDepth
         write SetRetainImageColourDepth
       default False;
   public
     procedure Clear;
     constructor Create;
   end; { Class TCrpeReportOptions }

{------------------------------------------------------------------------------}
{ Class TCrpeRunningTotalsItem                                                 }
{------------------------------------------------------------------------------}
   TCrpeRunningTotalsItem = class(TCrpeFieldObjectItemX)
   private
     FName             : string;
     FSummaryField     : string;
     FSummaryType      : TCrSummaryType;
     FSummaryTypeN     : Smallint;
     FSummaryTypeField : string;
     FEvalCondition    : TCrRunningTotalCondition;
     FEvalField        : string;
     FEvalGroupN       : Smallint;
     FEvalFormula      : TStrings;
     FResetField       : string;
     FResetFormula     : TStrings;
     FResetCondition   : TCrRunningTotalCondition;
     FResetGroupN      : Smallint;
     {temp}
     xEvalFormula      : TStrings;
     xResetFormula     : TStrings;
   protected
      procedure SetName (const Value: string);
      procedure SetSummaryField (const Value: string);
      procedure SetSummaryType (const Value: TCrSummaryType);
      procedure SetSummaryTypeN (const Value: Smallint);
      procedure SetSummaryTypeField (const Value: string);
      procedure SetEvalField (const Value: string);
      procedure SetEvalFormula (const Value: TStrings);
      procedure OnChangeEvalFormula (Sender: TObject);
      procedure SetEvalCondition (const Value: TCrRunningTotalCondition);
      procedure SetEvalGroupN (const Value: Smallint);
      procedure SetResetField (const Value: string);
      procedure SetResetFormula (const Value: TStrings);
      procedure OnChangeResetFormula (Sender: TObject);
      procedure SetResetCondition (const Value: TCrRunningTotalCondition);
      procedure SetResetGroupN (const Value: Smallint);
   published
      property Name : string
          read FName
         write SetName;
      property SummaryField : string
          read FSummaryField
         write SetSummaryField;
      property SummaryType : TCrSummaryType
          read FSummaryType
         write SetSummaryType
       default stCount;
      property SummaryTypeN : Smallint
          read FSummaryTypeN
         write SetSummaryTypeN
       default -1;
      property SummaryTypeField : string
          read FSummaryTypeField
         write SetSummaryTypeField;
      property EvalField : string
          read FEvalField
         write SetEvalField;
      property EvalFormula : TStrings
          read FEvalFormula
         write SetEvalFormula;
      property EvalCondition : TCrRunningTotalCondition
          read FEvalCondition
         write SetEvalCondition
       default rtcNoCondition;
      property EvalGroupN : Smallint
          read FEvalGroupN
         write SetEvalGroupN
       default -1;
      property ResetField : string
          read FResetField
         write SetResetField;
      property ResetFormula : TStrings
          read FResetFormula
         write SetResetFormula;
      property ResetCondition : TCrRunningTotalCondition
          read FResetCondition
         write SetResetCondition
       default rtcNoCondition;
      property ResetGroupN : Smallint
          read FResetGroupN
         write SetResetGroupN
       default -1;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
     destructor  Destroy; override;
   end; { Class TCrpeRunningTotalsItem }

{------------------------------------------------------------------------------}
{ Class TCrpeRunningTotals                                                     }
{------------------------------------------------------------------------------}
   TCrpeRunningTotals = class(TCrpeFieldObjectContainerX)
   private
     FName   : string;
     FNames  : TStrings;
   protected
      procedure SetIndex (nIndex: integer);
      function  GetItems (nIndex: integer) : TCrpeRunningTotalsItem;
      function  GetItem : TCrpeRunningTotalsItem;
      procedure SetItem (const nItem: TCrpeRunningTotalsItem);
      procedure SetName (const Value: string);
   published
      property Number : TCrLookupNumber
          read FIndex
         write SetIndex;
      property Name : TCrLookupString
          read FName
         write SetName;
      property Item : TCrpeRunningTotalsItem
          read GetItem
         write SetItem;
   public
      property ItemIndex : integer
          read FIndex
         write SetIndex;
      property Items[nIndex: integer]: TCrpeRunningTotalsItem
          read GetItems; default;
     function  Names : TStrings;
     function  Count : integer; override;
//     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     function  IndexOf (RunningTotalName: string): integer;
     function  ByName (RunningTotalName: string): TCrpeRunningTotalsItem;
     constructor Create;
     destructor  Destroy; override;
   end; { Class TCrpeRunningTotals }

{------------------------------------------------------------------------------}
{ Class TCrpeSectionFontItem                                                   }
{------------------------------------------------------------------------------}
   TCrpeSectionFontItem = class(TCrpeItemX)
   private
     FSection       : string;
     FScope         : TCrFontScope;
     FName          : TFontName;
     FPitch         : TFontPitch;
     FFamily        : TCrFontFamily;
     FCharSet       : TCrFontCharSet;
     FSize          : Smallint;
     FItalic        : TCrBoolean;
     FUnderlined    : TCrBoolean;
     FStrikeThrough : TCrBoolean;
     FWeight        : TCrFontWeight;
   protected
     procedure SetSection (const Value: string);
     procedure SetScope (const Value: TCrFontScope);
     procedure SetName (const Value: TFontName);
     procedure SetPitch (const Value: TFontPitch);
     procedure SetFamily (const Value: TCrFontFamily);
     procedure SetCharSet (const Value: TCrFontCharSet);
     procedure SetSize (const Value: Smallint);
     procedure SetItalic (const Value: TCrBoolean);
     procedure SetUnderlined (const Value: TCrBoolean);
     procedure SetStrikeThrough (const Value: TCrBoolean);
     procedure SetWeight (const Value: TCrFontWeight);
     procedure Send;
   published
     property Section : string
         read FSection
        write SetSection;
     property Scope : TCrFontScope
         read FScope
        write SetScope
      default fsBoth;
     property Name  : TFontName
         read FName
        write SetName;
     property Pitch : TFontPitch
         read FPitch
        write SetPitch
      default fpDefault;
     property Family : TCrFontFamily
         read FFamily
        write SetFamily
      default ffDefault;
     property CharSet : TCrFontCharSet
         read FCharSet
        write SetCharSet
      default fcDefault;
     property Size : Smallint
         read FSize
        write SetSize
      default 0;
     property Italic : TCrBoolean
         read FItalic
        write SetItalic
      default cDefault;
     property Underlined : TCrBoolean
         read FUnderlined
        write SetUnderlined
      default cDefault;
     property StrikeThrough : TCrBoolean
         read FStrikeThrough
        write SetStrikeThrough
      default cDefault;
     property Weight : TCrFontWeight
         read FWeight
        write SetWeight
      default fwDefault;
   public
     function  SectionAsCode: Smallint;
     function  SectionType : string;
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
   end; { Class TCrpeSectionFontItem }

{------------------------------------------------------------------------------}
{ Class TCrpeSectionFont                                                       }
{------------------------------------------------------------------------------}
   TCrpeSectionFont = class(TCrpeContainerX)
   private
     FSection : string;
     FItem    : TCrpeSectionFontItem;
   protected
     procedure SetSection (const Value: string);
     procedure SetIndex (nIndex: integer);
     function  GetItem (nIndex: integer) : TCrpeSectionFontItem;
   published
     property Number : TCrLookupNumber
         read FIndex
        write SetIndex
      default -1;
     property Section : TCrLookupString
         read FSection
        write SetSection;
     property Item : TCrpeSectionFontItem
         read FItem
        write FItem;
   public
     property ItemIndex : integer
         read FIndex
        write SetIndex;
     property Items[nIndex: integer]: TCrpeSectionFontItem
         read GetItem; default;
//     procedure Assign(Source: TPersistent); override;
     function  Count: integer; override;
     procedure Clear;
     function  IndexOf (SectionName: string): integer;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSectionFont }

{------------------------------------------------------------------------------}
{ Class TCrpeSectionFormatFormulas                                             }
{------------------------------------------------------------------------------}
   TCrpeSectionFormatFormulas = class(TCrpePersistentX)
   private
     FSuppress             : TStrings;
     FNewPageBefore        : TStrings;
     FNewPageAfter         : TStrings;
     FKeepTogether         : TStrings;
     FSuppressBlankSection : TStrings;
     FResetPageNAfter      : TStrings;
     FPrintAtBottomOfPage  : TStrings;
     FBackgroundColor      : TStrings;
     FUnderlaySection      : TStrings;
     xFormula              : TStrings;
   protected
     function  GetSuppress : TStrings;
     procedure SetSuppress (const Value: TStrings);
     function  GetNewPageBefore : TStrings;
     procedure SetNewPageBefore (const Value: TStrings);
     function  GetNewPageAfter : TStrings;
     procedure SetNewPageAfter (const Value: TStrings);
     function  GetKeepTogether : TStrings;
     procedure SetKeepTogether (const Value: TStrings);
     function  GetSuppressBlankSection : TStrings;
     procedure SetSuppressBlankSection (const Value: TStrings);
     function  GetResetPageNAfter : TStrings;
     procedure SetResetPageNAfter (const Value: TStrings);
     function  GetPrintAtBottomOfPage : TStrings;
     procedure SetPrintAtBottomOfPage (const Value: TStrings);
     function  GetBackgroundColor : TStrings;
     procedure SetBackgroundColor (const Value: TStrings);
     function  GetUnderlaySection : TStrings;
     procedure SetUnderlaySection (const Value: TStrings);
     {OnChange StringList methods}
     procedure OnChangeSuppress (Sender: TObject);
     procedure OnChangeNewPageBefore (Sender: TObject);
     procedure OnChangeNewPageAfter (Sender: TObject);
     procedure OnChangeKeepTogether (Sender: TObject);
     procedure OnChangeSuppressBlankSection (Sender: TObject);
     procedure OnChangeResetPageNAfter (Sender: TObject);
     procedure OnChangePrintAtBottomOfPage (Sender: TObject);
     procedure OnChangeBackgroundColor (Sender: TObject);
     procedure OnChangeUnderlaySection (Sender: TObject);
   published
     property Suppress : TStrings
         read GetSuppress
        write SetSuppress;
     property NewPageBefore : TStrings
         read GetNewPageBefore
        write SetNewPageBefore;
     property NewPageAfter : TStrings
         read GetNewPageAfter
        write SetNewPageAfter;
     property KeepTogether : TStrings
         read GetKeepTogether
        write SetKeepTogether;
     property SuppressBlankSection : TStrings
         read GetSuppressBlankSection
        write SetSuppressBlankSection;
     property ResetPageNAfter : TStrings
         read GetResetPageNAfter
        write SetResetPageNAfter;
     property PrintAtBottomOfPage : TStrings
         read GetPrintAtBottomOfPage
        write SetPrintAtBottomOfPage;
     property BackgroundColor : TStrings
         read GetBackgroundColor
        write SetBackgroundColor;
     property UnderlaySection : TStrings
         read GetUnderlaySection
        write SetUnderlaySection;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSectionFormatFormulas }


{------------------------------------------------------------------------------}
{ Class TCrpeSectionFormatItem                                                 }
{------------------------------------------------------------------------------}
  TCrpeSectionFormatItem = class(TCrpeItemX)
  private
    FSection              : string;
    FSuppress             : Boolean;
    FNewPageBefore        : Boolean;
    FNewPageAfter         : Boolean;
    FKeepTogether         : Boolean;
    FSuppressBlankSection : Boolean;
    FResetPageNAfter      : Boolean;
    FPrintAtBottomOfPage  : Boolean;
    FBackgroundColor      : TColor;
    FUnderlaySection      : Boolean;
    FFreeFormPlacement    : Boolean;
    FFormulas             : TCrpeSectionFormatFormulas;
  protected
    procedure SetSection (const Value: string);
    procedure SetSuppress (const Value: Boolean);
    procedure SetNewPageBefore (const Value: Boolean);
    procedure SetNewPageAfter (const Value: Boolean);
    procedure SetKeepTogether (const Value: Boolean);
    procedure SetSuppressBlankSection (const Value: Boolean);
    procedure SetResetPageNAfter (const Value: Boolean);
    procedure SetPrintAtBottomOfPage (const Value: Boolean);
    procedure SetBackgroundColor (const Value: TColor);
    procedure SetUnderlaySection (const Value: Boolean);
    procedure SetFreeFormPlacement (const Value: Boolean);
  published
    property Section : string
        read FSection
       write SetSection;
    property Suppress : Boolean
        read FSuppress
       write SetSuppress
     default False;
    property NewPageBefore : Boolean
        read FNewPageBefore
       write SetNewPageBefore
     default False;
    property NewPageAfter : Boolean
        read FNewPageAfter
       write SetNewPageAfter
     default False;
    property KeepTogether : Boolean
        read FKeepTogether
       write SetKeepTogether
     default True;
    property SuppressBlankSection : Boolean
        read FSuppressBlankSection
       write SetSuppressBlankSection
     default False;
    property ResetPageNAfter : Boolean
        read FResetPageNAfter
       write SetResetPageNAfter
     default False;
    property PrintAtBottomOfPage : Boolean
        read FPrintAtBottomOfPage
       write SetPrintAtBottomOfPage
     default False;
    property BackgroundColor : TColor
        read FBackgroundColor
       write SetBackgroundColor
     default clNone;
    property UnderlaySection : Boolean
        read FUnderlaySection
       write SetUnderlaySection
     default False;
    property FreeFormPlacement : Boolean
        read FFreeFormPlacement
       write SetFreeFormPlacement
     default True;
    property Formulas : TCrpeSectionFormatFormulas
        read FFormulas
       write FFormulas;
  public
    function  SectionAsCode: Smallint;
    function  SectionType : string;
    procedure Assign(Source: TPersistent); override;
    procedure Clear;
    constructor Create;
    destructor  Destroy; override;
  end; { Class TCrpeSectionFormatItem }

{------------------------------------------------------------------------------}
{ Class TCrpeSectionFormat                                                     }
{------------------------------------------------------------------------------}
  TCrpeSectionFormat = class(TCrpeContainerX)
  private
    FSection      : string;
    FItem         : TCrpeSectionFormatItem;
    FSectionNames : TStrings;
  protected
    procedure SetSection (const Value: string);
    procedure SetSectionAsCode (const nCode: Smallint);
    function  GetSectionAsCode : Smallint;
    procedure SetIndex (nIndex: integer);
    function  GetItem (nIndex: integer) : TCrpeSectionFormatItem;
  published
    property Number : TCrLookupNumber
        read FIndex
       write SetIndex
     default -1;
    property Section : TCrLookupString
        read FSection
       write SetSection;
    property SectionAsCode : Smallint
        read GetSectionAsCode
       write SetSectionAsCode
     default 0;
    property Item : TCrpeSectionFormatItem
        read FItem
       write FItem;
  public
    property ItemIndex : integer
        read FIndex
       write SetIndex;
    property Items[nIndex: integer]: TCrpeSectionFormatItem
        read GetItem; default;
    function  Names : TStrings;  {read only - list of Section Names}
    function  AreaType : string;
    function  Count: integer; override;
//    procedure Assign(Source: TPersistent); override;
    procedure Clear;
    function  IndexOf (SectionName: string): integer;
    function  ByName (SectionName: string): TCrpeSectionFormatItem;
    constructor Create;
    destructor  Destroy; override;
  end; { Class TCrpeSectionFormat }

{------------------------------------------------------------------------------}
{ Class TCrpeSectionSizeItem                                                   }
{------------------------------------------------------------------------------}
   TCrpeSectionSizeItem = class(TCrpeItemX)
   private
      FSection : string;
      FHeight  : Smallint;  {in twips: 1440 twips per inch}
      FWidth   : Smallint;  {in twips - read only}
   protected
      procedure SetSection (const Value: string);
      procedure SetHeight (const Value: Smallint);
      procedure SetWidth (const Value: Smallint);
   published
      property Section : string
          read FSection
         write SetSection;
      property Height : Smallint
          read FHeight
         write SetHeight;
      property Width : Smallint
          read FWidth
         write SetWidth;
   public
     function  SectionAsCode: Smallint;
     function  SectionType : string;
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
   end; { Class TCrpeSectionSizeItem }

{------------------------------------------------------------------------------}
{ Class TCrpeSectionSize                                                       }
{------------------------------------------------------------------------------}
   TCrpeSectionSize = class(TCrpeContainerX)
   private
      FSection : string;
      FItem    : TCrpeSectionSizeItem;
   protected
      procedure SetSection (const Value: string);
      procedure SetIndex (nIndex: integer);
      function  GetItem (nIndex: integer) : TCrpeSectionSizeItem;
   published
      property Number : TCrLookupNumber
          read FIndex
         write SetIndex
       default -1;
      property Section : TCrLookupString
          read FSection
         write SetSection;
      property Item : TCrpeSectionSizeItem
          read FItem
         write FItem;
   public
      property ItemIndex : integer
          read FIndex
         write SetIndex;
      property Items[nIndex: integer]: TCrpeSectionSizeItem
          read GetItem; default;
     function  Count: integer; override;
//     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     function  IndexOf (SectionName: string): integer;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSectionSize }

{------------------------------------------------------------------------------}
{ Class TCrpeSelection                                                         }
{------------------------------------------------------------------------------}
   TCrpeSelection = class(TCrpePersistentX)
   private
      FFormula : TStrings;
      xFormula : TStrings;
   protected
      function  GetFormula : TStrings;
      procedure SetFormula (ListVar: TStrings);
      procedure OnChangeStrings (Sender: TObject);
   published
      property Formula : TStrings
          read GetFormula
         write SetFormula;
   public
     function  Check : Boolean;
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSelection }

{------------------------------------------------------------------------------}
{ Class TCrpeSessionInfoItem                                                   }
{------------------------------------------------------------------------------}
   TCrpeSessionInfoItem = class(TCrpeItemX)
   private
     FUserID        : string;
     FDBPassword    : string;
     FUserPassword  : string;
     FSessionHandle : DWord;
     FPropagate     : Boolean;
     FPrevProp      : Boolean;
   protected
     procedure SetUserID (const Value: string);
     procedure SetDBPassword (const Value: string);
     procedure SetUserPassword (const Value: string);
     procedure SetSessionHandle (const Value: DWord);
     procedure SetPropagate (const Value: Boolean);
   published
     property UserID : string
         read FUserID
        write SetUserID;
     property DBPassword : string
         read FDBPassword
        write SetDBPassword;
     property UserPassword : string
         read FUserPassword
        write SetUserPassword;
     property Propagate : Boolean
         read FPropagate
        write SetPropagate;
   public
     property SessionHandle : DWord
         read FSessionHandle
        write SetSessionHandle;
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     function  Test : Boolean;
     constructor Create;
   end; { Class TCrpeSessionInfoItem }

{------------------------------------------------------------------------------}
{ Class TCrpeSessionInfo                                                       }
{   - Ms Access Only                                                           }
{------------------------------------------------------------------------------}
   TCrpeSessionInfo = class(TCrpeContainerX)
   private
     FItem : TCrpeSessionInfoItem;
   protected
     procedure SetIndex (nIndex: integer);
     function  GetItem (nIndex: integer) : TCrpeSessionInfoItem;
   published
     property Table : TCrLookupNumber
         read FIndex
        write SetIndex;
     property Item : TCrpeSessionInfoItem
         read FItem
        write FItem;
   public
     property ItemIndex : integer
         read FIndex
        write SetIndex;
     property Items[nIndex: integer]: TCrpeSessionInfoItem
         read GetItem; default;
     function  Count: integer; override;
//     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSessionInfo }

{------------------------------------------------------------------------------}
{ Class TCrpeSortFieldsItem                                                    }
{------------------------------------------------------------------------------}
   TCrpeSortFieldsItem = class(TCrpeItemX)
   private
     FFieldName : string;
     FDirection : TCrSortDirection;
   protected
     procedure SetFieldName (const Value: string);
     procedure SetDirection (const Value: TCrSortDirection);
   published
     property FieldName : string
         read FFieldName
        write SetFieldName;
     property Direction : TCrSortDirection
         read FDirection
        write SetDirection
      default sdAscending;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
   end; { Class TCrpeSortFieldsItem }

{------------------------------------------------------------------------------}
{ Class TCrpeSortFields                                                        }
{------------------------------------------------------------------------------}
   TCrpeSortFields = class(TCrpeContainerX)
   private
      FItem : TCrpeSortFieldsItem;
   protected
      procedure SetIndex (nIndex: integer);
      function  GetItem (nIndex: integer) : TCrpeSortFieldsItem;
   published
      property Number : TCrLookupNumber
          read FIndex
         write SetIndex
       default -1;
      property Item : TCrpeSortFieldsItem
          read FItem
         write FItem;
   public
      property ItemIndex : integer
          read FIndex
         write SetIndex;
      property Items[nIndex: integer]: TCrpeSortFieldsItem
          read GetItem; default;
     function  Count : integer; override;
//     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     function  Add (FieldName: string) : integer;
     procedure Delete (nIndex: integer);
     procedure Insert (Position: Smallint; FieldName: string;
       Direction: TCrSortDirection);
     procedure Swap (SourceN, TargetN: Smallint);
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSortFields }

{------------------------------------------------------------------------------}
{ Class TCrpeSpecialFieldsItem                                                 }
{------------------------------------------------------------------------------}
   TCrpeSpecialFieldsItem = class(TCrpeFieldObjectItemX)
   private
   protected
   published
   public
     procedure Assign(Source: TPersistent); override;
   end; { Class TCrpeSpecialFieldsItem }

{------------------------------------------------------------------------------}
{ Class TCrpeSpecialFields                                                     }
{------------------------------------------------------------------------------}
   TCrpeSpecialFields = class(TCrpeFieldObjectContainerX)
   private
   protected
     procedure SetIndex (nIndex: integer);
     function  GetItems (nIndex: integer) : TCrpeSpecialFieldsItem;
     function  GetItem : TCrpeSpecialFieldsItem;
     procedure SetItem (const nItem: TCrpeSpecialFieldsItem);
   published
     property Number : TCrLookupNumber
         read FIndex
        write SetIndex;
     property Item : TCrpeSpecialFieldsItem   {accesses inherited FItem}
         read GetItem
        write SetItem;
   public
     property ItemIndex : integer
         read FIndex
        write SetIndex;
     property Items[nIndex: integer]: TCrpeSpecialFieldsItem
         read GetItems; default;
     procedure Clear;
//     procedure Assign(Source: TPersistent); override;
     function  IndexOf (FieldName: string): integer;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSpecialFields }

{------------------------------------------------------------------------------}
{ Class TCrpeSQL                                                               }
{------------------------------------------------------------------------------}
   TCrpeSQL = class(TCrpePersistentX)
   private
     FQuery       : TStrings;
     xQuery       : TStrings;
   protected
     procedure SetQuery (ListVar: TStrings);
     procedure OnChangeStrings (Sender: TObject);
   published
      property Query : TStrings
          read FQuery
         write SetQuery;
   public
     procedure Clear;
     function  Retrieve : Boolean;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSQL Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeSQLExpressionsItem                                                }
{------------------------------------------------------------------------------}
   TCrpeSQLExpressionsItem = class(TCrpeFieldObjectItemX)
   private
     FName       : string;
     FExpression : TStrings;
     xExpression : TStrings; {Temp storage}
   protected
     procedure SetName (const Value: string);
     procedure SetExpression (ListVar: TStrings);
     procedure OnChangeStrings (Sender: TObject);
   published
     property Name : string
         read FName
        write SetName;
     property Expression : TStrings
         read FExpression
        write SetExpression;
   public
     function  Check : Boolean;
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSQLExpressionsItem }

{------------------------------------------------------------------------------}
{ Class TCrpeSQLExpressions                                                    }
{------------------------------------------------------------------------------}
   TCrpeSQLExpressions = class(TCrpeFieldObjectContainerX)
   private
     FName                   : string;
     FNames                  : TStrings;
     FObjectPropertiesActive : Boolean;
   protected
     procedure SetName (const Value: string);
     procedure SetObjectPropertiesActive (const Value: Boolean);
     procedure SetIndex (nIndex: integer);
     function  GetItems(nIndex: integer) : TCrpeSQLExpressionsItem;
     function  GetItem : TCrpeSQLExpressionsItem;
     procedure SetItem (const nItem: TCrpeSQLExpressionsItem);
   published
     property Name : TCrLookupString
         read FName
        write SetName;
     property Number : TCrLookupNumber
         read FIndex
        write SetIndex
      default -1;
     property Item : TCrpeSQLExpressionsItem
         read GetItem
        write SetItem;
    property ObjectPropertiesActive : Boolean
        read FObjectPropertiesActive
       write SetObjectPropertiesActive
     default True;
   public
      property ItemIndex : integer
          read FIndex
         write SetIndex;
      property Items[nIndex: integer]: TCrpeSQLExpressionsItem
          read GetItems; default;
     function  Names : TStrings;
     function  Count : integer; override;
//     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     function  IndexOf (ExpressionName: string): integer;
     function  ByName (ExpressionName: string): TCrpeSQLExpressionsItem;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSQLExpressions }


{------------------------------------------------------------------------------}
{ Class TCrpeSubreportLinksItem                                                }
{------------------------------------------------------------------------------}
   TCrpeSubreportLinksItem = class(TCrpeItemX)
   private
     FMainReportFieldName : string;
     FSubreportFieldName  : string;
     FParamFieldName      : string;
   protected
     procedure SetMainReportFieldName (const Value: string);
     procedure SetSubreportFieldName (const Value: string);
     procedure SetParamFieldName (const Value: string);
   published
     property MainReportFieldName : string
         read FMainReportFieldName
        write SetMainReportFieldName;
     property SubreportFieldName : string
         read FSubreportFieldName
        write SetSubreportFieldName;
     property ParamFieldName : string
         read FParamFieldName
        write SetParamFieldName;
   public
    {Methods}
     procedure Clear;
     function StatusIsGo : Boolean;
     constructor Create;
   end; { Class TCrpeSubreportLinksItem }

{------------------------------------------------------------------------------}
{ Class TCrpeSubreportLinks                                                    }
{------------------------------------------------------------------------------}
   TCrpeSubreportLinks = class(TCrpeContainerX)
   private
     FItem   : TCrpeSubreportLinksItem;
   protected
     procedure SetIndex (nIndex: integer);
     function  StatusIsGo: boolean;
     function  GetItem (nIndex: integer) : TCrpeSubreportLinksItem;
   published
     property Number : TCrLookupNumber
         read FIndex
        write SetIndex
      default -1;
     property Item : TCrpeSubreportLinksItem
         read FItem
        write FItem;
   public
     property ItemIndex : integer
         read FIndex
        write SetIndex;
     property Items[nIndex: integer]: TCrpeSubreportLinksItem
         read GetItem; default;
     function  Count : integer; override;
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSubreportLinks }

{------------------------------------------------------------------------------}
{ Class TCrpeSubreportsItem                                                    }
{------------------------------------------------------------------------------}
   TCrpeSubreportsItem = class(TCrpeObjectItemAX)
   private
     FName                : string;
     FNLinks              : Smallint;
     FOnDemand            : Boolean;
     FOnDemandCaption     : string;
     FPreviewTabCaption   : string;
     {CR 8+}
     FIsExternal          : Boolean;
     FReImportWhenOpening : Boolean;
     FLinks               : TCrpeSubreportLinks;
   protected
     procedure SetName (const Value: string);
     procedure SetNLinks (const Value: Smallint);
     procedure SetOnDemand (const Value: Boolean);
     procedure SetOnDemandCaption (const Value: string);
     procedure SetPreviewTabCaption (const Value: string);
     {CR 8+}
     procedure SetIsExternal (const Value: Boolean);
     procedure SetReImportWhenOpening (const Value: Boolean);
     {These methods allow the Subreports.ReportTitle, etc. syntax}
     function  GetDetailCopies: Smallint;
     procedure SetDetailCopies(const Value: Smallint);
     function  GetReportTitle: string;
     procedure SetReportTitle(const Value: string);
   published
     property Name : string
         read FName
        write SetName;
     property NLinks : Smallint
         read FNLinks
        write SetNLinks;
     property OnDemand : Boolean
         read FOnDemand
        write SetOnDemand
      default False;
     property OnDemandCaption : string
         read FOnDemandCaption
        write SetOnDemandCaption;
     property PreviewTabCaption : string
         read FPreviewTabCaption
        write SetPreviewTabCaption;
     {CR 8+}
     property IsExternal : Boolean
         read FIsExternal
        write SetIsExternal
      default False;
     property ReImportWhenOpening : Boolean
         read FReImportWhenOpening
        write SetReImportWhenOpening
      default True;
     property Links : TCrpeSubreportLinks
         read FLinks
        write FLinks;
   public
      {These are duplicates from the main Crpe class
       so that Crpe1.Subreports[1].ReportTitle syntax is valid}
      property ReportTitle : string
          read GetReportTitle
         write SetReportTitle;
      property DetailCopies : Smallint
          read GetDetailCopies
         write SetDetailCopies;
     {Reference Methods: variables}
     function  PrintJob              : Smallint;
     {Reference Methods: classes}
     function  ReportOptions         : TCrpeReportOptions;
     function  GlobalOptions         : TCrpeGlobalOptions;
     function  Margins               : TCrpeMargins;
     function  Connect               : TCrpeConnect;
     function  LogOnInfo             : TCrpeLogonInfo;
     function  SectionFont           : TCrpeSectionFont;
     function  SectionFormat         : TCrpeSectionFormat;
     function  AreaFormat            : TCrpeAreaFormat;
     function  SectionSize           : TCrpeSectionSize;
     function  Selection             : TCrpeSelection;
     function  GroupSelection        : TCrpeGroupSelection;
     function  SortFields            : TCrpeSortFields;
     function  GroupSortFields       : TCrpeGroupSortFields;
     function  Groups                : TCrpeGroups;
     function  SQL                   : TCrpeSQL;
     function  SQLExpressions        : TCrpeSQLExpressions;
     function  Formulas              : TCrpeFormulas;
     function  ParamFields           : TCrpeParamFields;
     function  Tables                : TCrpeTables;
     function  SessionInfo           : TCrpeSessionInfo;
     function  Graphs                : TCrpeGraphs;
     {Objects}
     function  Lines                 : TCrpeLines;
     function  Boxes                 : TCrpeBoxes;
     function  TextObjects           : TCrpeTextObjects;
     function  OleObjects            : TCrpeOleObjects;
     function  CrossTabs             : TCrpeCrossTabs;
     function  Maps                  : TCrpeMaps;
     function  OLAPCubes             : TCrpeOLAPCubes;
     {Field Objects}
     function  Pictures              : TCrpePictures;
     function  DatabaseFields        : TCrpeDatabaseFields;
     function  SummaryFields         : TCrpeSummaryFields;
     function  SpecialFields         : TCrpeSpecialFields;
     function  GroupNameFields       : TCrpeGroupNameFields;
     function  RunningTotals         : TCrpeRunningTotals;
    {Methods}
     procedure Clear;
     procedure ReImport;
     constructor Create;
     destructor  Destroy; override;
   end; { Class TCrpeSubreportsItem }

{------------------------------------------------------------------------------}
{ Class TCrpeSubreports                                                        }
{------------------------------------------------------------------------------}
   TCrpeSubreports = class(TCrpeObjectContainerAX)
   private
     {Subreport specific variables}
     FName       : string;
     FNames      : TStrings;
     FSubExecute : Boolean;
   protected
     procedure SetName (const Value: string);
     procedure SetIndex (nIndex: integer);
     function  GetItems (nIndex: integer) : TCrpeSubreportsItem;
     function  GetItem : TCrpeSubreportsItem;
     procedure SetItem (const nItem: TCrpeSubreportsItem);
   published
      property Number : TCrLookupNumber
          read FIndex
         write SetIndex;
      property Name : TCrLookupString
          read FName
         write SetName;
      property SubExecute : Boolean
          read FSubExecute
         write FSubExecute
       default False;
      property Item : TCrpeSubreportsItem
          read GetItem
         write SetItem;
   public
      property ItemIndex : integer
          read FIndex
         write SetIndex;
      property Items[nIndex: integer]: TCrpeSubreportsItem
          read GetItems; default;
     function  Names : TStrings; {read only - list of Subreport Names}
     function  Count : integer; override;
     procedure Clear;
     function  IndexOf (SubreportName: string): integer;
     function  ByName (SubreportName: string): TCrpeSubreportsItem;
     constructor Create;
     destructor  Destroy; override;
   end; { Class TCrpeSubreports }

{------------------------------------------------------------------------------}
{ Class TCrpeSummaryFieldsItem                                                 }
{------------------------------------------------------------------------------}
   TCrpeSummaryFieldsItem = class(TCrpeFieldObjectItemX)
   private
     FName             : string;
     FSummarizedField  : string;
     FSummaryType      : TCrSummaryType;
     {SummaryTypeN only applies to certain SummaryTypes, ie. stPercentage}
     FSummaryTypeN     : Smallint;
     {SummaryTypeField only applies to certain SummaryTypes, ie. stCorrelation}
     FSummaryTypeField : string;
     FHeaderAreaCode   : string;
     FFooterAreaCode   : string;
   protected
      procedure SetName (const Value: string);
      procedure SetSummarizedField (const Value: string);
      procedure SetSummaryType (const Value: TCrSummaryType);
      procedure SetSummaryTypeN (const Value: Smallint);
      procedure SetSummaryTypeField (const Value: string);
      procedure SetHeaderAreaCode (const Value: string);
      procedure SetFooterAreaCode (const Value: string);
   published
      property Name : string
          read FName
         write SetName;
      property SummarizedField : string
          read FSummarizedField
         write SetSummarizedField;
      property SummaryType : TCrSummaryType
          read FSummaryType
         write SetSummaryType
       default stCount;
      property SummaryTypeN : Smallint
          read FSummaryTypeN
         write SetSummaryTypeN
       default -1;
      property SummaryTypeField : string
          read FSummaryTypeField
         write SetSummaryTypeField;
      property HeaderAreaCode : string
          read FHeaderAreaCode
         write SetHeaderAreaCode;
      property FooterAreaCode : string
          read FFooterAreaCode
         write SetFooterAreaCode;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     procedure ChangeType (SumType: TCrSummaryType);
     constructor Create;
   end; { Class TCrpeSummaryFieldsItem }

{------------------------------------------------------------------------------}
{ Class TCrpeSummaryFields                                                     }
{------------------------------------------------------------------------------}
   TCrpeSummaryFields = class(TCrpeFieldObjectContainerX)
   private
   protected
      procedure SetIndex (nIndex: integer);
      function  GetItems (nIndex: integer) : TCrpeSummaryFieldsItem;
      function  GetItem : TCrpeSummaryFieldsItem;
      procedure SetItem (const nItem: TCrpeSummaryFieldsItem);
   published
      property Number : TCrLookupNumber
          read FIndex
         write SetIndex
       default -1;
      property Item : TCrpeSummaryFieldsItem
          read GetItem
         write SetItem;
   public
      property Items[nIndex: integer]: TCrpeSummaryFieldsItem
          read GetItems; default;
      property ItemIndex : integer
          read FIndex
         write SetIndex;
//     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSummaryFields }

{------------------------------------------------------------------------------}
{ Class TCrpeSummaryInfo                                                       }
{------------------------------------------------------------------------------}
   TCrpeSummaryInfo = class(TCrpePersistentX)
   private
      FAppName   : string;
      FTitle     : string;
      FSubject   : string;
      FAuthor    : string;
      FKeywords  : string;
      FComments  : TStrings;
      xComments  : TStrings;
      FTemplate  : string;
      FSavePreviewPicture : Boolean;
   protected
      function  GetTitle : string;
      procedure SetTitle(const Value: string);
      function  GetSubject : string;
      procedure SetSubject(const Value: string);
      function  GetAuthor : string;
      procedure SetAuthor(const Value: string);
      function  GetKeywords : string;
      procedure SetKeywords(const Value: string);
      function  GetComments : TStrings;
      procedure SetComments(ListVar: TStrings);
      function  GetTemplate : string;
      procedure SetTemplate(const Value: string);
      function  GetAppName : string;
      procedure SetAppName(const Value: string);
      function  GetSavePreviewPicture : Boolean;
      procedure SetSavePreviewPicture (const Value: Boolean);
      procedure OnChangeStrings (Sender: TObject);
   published
      property Title : string
          read GetTitle
         write SetTitle;
      property Subject : string
          read GetSubject
         write SetSubject;
      property Author : string
          read GetAuthor
         write SetAuthor;
      property Keywords : string
          read GetKeywords
         write SetKeywords;
      property Comments : TStrings
          read GetComments
         write SetComments;
      property Template : string
          read GetTemplate
         write SetTemplate;
      property AppName : string
          read GetAppName
         write SetAppName;
      property SavePreviewPicture : Boolean
          read GetSavePreviewPicture
         write SetSavePreviewPicture;
   public
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeSummaryInfo Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeTableFieldsItem                                                   }
{------------------------------------------------------------------------------}
   TCrpeTableFieldsItem = class(TCrpeItemX)
   private
     FFieldName   : string;
     FFieldType   : TCrFieldValueType;
     FFieldLength : Word;
   protected
     procedure SetFieldName (const Value: string);
     procedure SetFieldType (const Value: TCrFieldValueType);
     procedure SetFieldLength (const Value: Word);
   published
     property FieldName : string
         read FFieldName
        write SetFieldName;
     property FieldType : TCrFieldValueType
         read FFieldType
        write SetFieldType
      default fvUnknown;
     property FieldLength : Word
         read FFieldLength
        write SetFieldLength
      default 0;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     function  InUse : Boolean;    {ie. on the Report, in DatabaseFields}
     function  FullName : string;  {TableAlias.Field}
     constructor Create;
   end; { Class TCrpeTableFieldsItem }

{------------------------------------------------------------------------------}
{ Class TCrpeTableFields                                                            }
{------------------------------------------------------------------------------}
   TCrpeTableFields = class(TCrpeContainerX)
   private
     FItem       : TCrpeTableFieldsItem;
     FFieldNames : TStrings;
   protected
     procedure SetIndex (nIndex: integer);
     function  GetItem (nIndex: integer) : TCrpeTableFieldsItem;
   published
     property Number : TCrLookupNumber
         read FIndex
        write SetIndex
      default -1;
     property Item : TCrpeTableFieldsItem
         read FItem
        write FItem;
   public
     property ItemIndex : integer
         read FIndex
        write SetIndex;
     property Items[nIndex: integer]: TCrpeTableFieldsItem
         read GetItem; default;
     function  Count : integer; override;
//     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     function  FieldNames : TStrings; {List of Field names}
     function  FieldByName(sFieldName: string): TCrpeTableFieldsItem;
     function  IndexOf (sFieldName: string): integer;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeTableFields }

{------------------------------------------------------------------------------}
{ Class TCrpeTablesItem                                                        }
{------------------------------------------------------------------------------}
   TCrpeTablesItem = class(TCrpeItemX)
   private
     FName            : string;
     FAliasName       : string;
     FPath            : string;
     FSubName         : string; {for Access MDB table names}
     FConnectBuffer   : string; {for Access MDB table names}
     FPassword        : string; {for Paradox tables}
     {TableType}
     FTableType       : TCrTableType;
     FDLLName         : string;
     FServerType      : string;
     {PrivateInfo}
     FDataPointer     : Pointer;
     FFields          : TCrpeTableFields;
     FFieldNames      : TStrings;
   protected
     procedure SetName (const Value: string);
     procedure SetAliasName (const Value: string);
     procedure SetPath (const Value: string);
     procedure SetSubName (const Value: string);
     procedure SetConnectBuffer (const Value: string);
     procedure SetPassword (const Value: string);
     procedure SetServerType (const Value: string);
     procedure SetDataPointer (const Value: Pointer);
   published
     property Name : string
         read FName
        write SetName;
     property AliasName : string
         read FAliasName
        write SetAliasName;
     property Path : string
         read FPath
        write SetPath;
     property SubName : string
         read FSubName
        write SetSubName;
     property ConnectBuffer : string
         read FConnectBuffer
        write SetConnectBuffer;
     property Password : string
         read FPassword
        write SetPassword;
     property ServerType : string
         read FServerType
        write SetServerType;
     property Fields : TCrpeTableFields
         read FFields
        write FFields;
   public
     property DataPointer : Pointer
         read FDataPointer
        write SetDataPointer;
     {Read only properties: only for GetNthTable}
     property TableType : TCrTableType
         read FTableType;
     property DLLName : string
         read FDLLName;
     function  FieldByName(sFieldName: string): TCrpeTableFieldsItem;
     function  FieldNames : TStrings; {List of TableAlias.Field names}
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     function  Test : Boolean;
     function  CheckDifferences (var DifNums: TStringList; var DifStrings: TStringList): Boolean;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeTablesItem }

{------------------------------------------------------------------------------}
{ Class TCrpeTables                                                            }
{------------------------------------------------------------------------------}
   TCrpeTables = class(TCrpeContainerX)
   private
     FPropagate    : Boolean;
     FFieldMapping : TCrFieldMappingType;
     {VerifyFix for Tables.Verify and Paradox Link Errors}
     FVerifyFix    : Boolean; {Used with Tables.Verify to fix Paradox Link problems}
     FItem         : TCrpeTablesItem;
     FFieldNames   : TStrings;
   protected
     procedure SetPropagate (const Value: boolean);
     {FieldMapping}
     function  GetFieldMapping : TCrFieldMappingType;
     procedure SetFieldMapping(const Value: TCrFieldMappingType);
     procedure SetIndex (nIndex: integer);
     function  GetItem (nIndex: integer) : TCrpeTablesItem;
   published
     property Number : TCrLookupNumber
         read FIndex
        write SetIndex
      default -1;
     property Propagate : Boolean
         read FPropagate
        write SetPropagate
      default False;
     property FieldMapping : TCrFieldMappingType
         read GetFieldMapping
        write SetFieldMapping
      default fmAuto;
     property VerifyFix : Boolean
         read FVerifyFix
        write FVerifyFix
      default False;
     property Item : TCrpeTablesItem
         read FItem
        write FItem;
   public
     property ItemIndex : integer
         read FIndex
        write SetIndex;
     property Items[nIndex: integer]: TCrpeTablesItem
         read GetItem; default;
     function  FieldNames : TStrings;
     function  Count : integer; override;
//     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     function  IndexOf (TableName: string): integer;
     function  ByName (AliasName: string): TCrpeTablesItem;
     function  GetFieldInfo (var FieldInfo: TCrFieldInfo): boolean;
     function  Verify : Boolean;
     function  ConvertDriver (DLLName: string): Boolean;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeTables }

{------------------------------------------------------------------------------}
{ Class TCrpeTabStopsItem                                                      }
{------------------------------------------------------------------------------}
   TCrpeTabStopsItem = class(TCrpeItemX)
   private
     FAlignment : TCrHorizontalAlignment;
     FOffset    : LongInt;
   protected
     function  StatusIsGo : boolean;
     procedure SetAlignment (const Value: TCrHorizontalAlignment);
     procedure SetOffset (const Value: LongInt);
   published
      property Alignment : TCrHorizontalAlignment
          read FAlignment
         write SetAlignment;
      property Offset : LongInt
          read FOffset
         write SetOffset;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
   end; { Class TCrpeTabStopsItem }

{------------------------------------------------------------------------------}
{ Class TCrpeTabStops                                                          }
{------------------------------------------------------------------------------}
   TCrpeTabStops = class(TCrpeContainerX)
   private
     FItem   : TCrpeTabStopsItem;
   protected
     procedure SetIndex(nIndex: integer);
     function  GetItem(nIndex: integer) : TCrpeTabStopsItem;
   published
     property Number : TCrLookupNumber
         read FIndex
        write SetIndex
      default -1;
     property Item : TCrpeTabStopsItem
         read FItem
        write FItem;
   public
     property ItemIndex : integer
         read FIndex
        write SetIndex;
     property Items[nIndex: integer]: TCrpeTabStopsItem
         read GetItem; default;
//     procedure Assign(Source: TPersistent); override;
     function  Count : integer; override;
     function  Add (Alignment: TCrHorizontalAlignment; Offset: LongInt): integer;
     procedure Delete (nTab: integer);
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeTabStops }

{------------------------------------------------------------------------------}
{ Class TCrpeParagraphsItem                                                    }
{------------------------------------------------------------------------------}
   TCrpeParagraphsItem = class(TCrpeItemX)
   private
     FAlignment       : TCrHorizontalAlignment;
     FIndentFirstLine : LongInt;
     FIndentLeft      : LongInt;
     FIndentRight     : LongInt;
     FTextStart       : LongInt; {Read only}
     FTextEnd         : LongInt; {Read only}
     FTabStops        : TCrpeTabStops;
   protected
   published
     procedure SetAlignment (const Value: TCrHorizontalAlignment);
     procedure SetIndentFirstLine (const Value: LongInt);
     procedure SetIndentLeft (const Value: LongInt);
     procedure SetIndentRight (const Value: LongInt);
     procedure SetTextStart (const Value: LongInt);
     procedure SetTextEnd (const Value: LongInt);
      property Alignment : TCrHorizontalAlignment
          read FAlignment
         write SetAlignment;
      property IndentFirstLine : LongInt
          read FIndentFirstLine
         write SetIndentFirstLine;
      property IndentLeft : LongInt
          read FIndentLeft
         write SetIndentLeft;
      property IndentRight : LongInt
          read FIndentRight
         write SetIndentRight;
      property TextStart : LongInt
          read FTextStart
         write SetTextStart;
      property TextEnd : LongInt
          read FTextEnd
         write SetTextEnd;
      property TabStops : TCrpeTabStops
          read FTabStops
         write FTabStops;
   public
     procedure Assign(Source: TPersistent); override;
     function  StatusIsGo : Boolean;
     procedure Clear;
     constructor Create;
     destructor  Destroy; override;
   end; { Class TCrpeParagraphsItem }

{------------------------------------------------------------------------------}
{ Class TCrpeParagraphs                                                        }
{------------------------------------------------------------------------------}
   TCrpeParagraphs = class(TCrpeContainerX)
   private
     FItem   : TCrpeParagraphsItem;
   protected
     procedure SetIndex (nIndex: integer);
     function  GetItem (nIndex: integer) : TCrpeParagraphsItem;
   published
     property Number : TCrLookupNumber
         read FIndex
        write SetIndex
      default -1;
     property Item : TCrpeParagraphsItem
         read FItem
        write FItem;
   public
     property ItemIndex : integer
         read FIndex
        write SetIndex;
     property Items[nIndex: integer]: TCrpeParagraphsItem
         read GetItem; default;
     function  Count : integer; override;
//     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
     destructor  Destroy; override;
   end; { Class TCrpeParagraphs }

{------------------------------------------------------------------------------}
{ Class TCrpeEmbeddedFieldsItem                                                }
{------------------------------------------------------------------------------}
   TCrpeEmbeddedFieldsItem = class(TCrpeItemX)
   private
     FFieldName       : string;             {Read only}
     FFieldObjectType : TCrFieldObjectType; {database, formula, etc.}
     FFieldType       : TCrFieldValueType;  {number, string, etc.}
     FFieldN          : Smallint;
     FTextStart       : LongInt;            {Read only}
     FTextEnd         : LongInt;            {Read only}
     FFormat          : TCrpeFieldObjectFormat;
     FBorder          : TCrpeBorder;
   protected
     procedure SetFieldType(FType: TCrFieldValueType);
     procedure SetFieldN(nField: Smallint);
     {EmbeddedField procedures}
     procedure SetFObjectType (const Value: TCrFieldObjectType);
     procedure SetFType (const Value: TCrFieldValueType);
     procedure SetFName (const Value: string);
     procedure SetTextStart (const Value: LongInt);
     procedure SetTextEnd (const Value: LongInt);
   published
      property FieldName : string
          read FFieldName
         write SetFName;
      property FieldObjectType : TCrFieldObjectType
          read FFieldObjectType
         write SetFObjectType;
      property FieldType : TCrFieldValueType
          read FFieldType
         write SetFType;
      property TextStart : LongInt
          read FTextStart
         write SetTextStart;
      property TextEnd : LongInt
          read FTextEnd
         write SetTextEnd;
      {Format}
      property Format : TCrpeFieldObjectFormat
          read FFormat
         write FFormat;
      {Border}
      property Border : TCrpeBorder
          read FBorder
         write FBorder;
   public
     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeEmbeddedFieldsItem }

{------------------------------------------------------------------------------}
{ Class TCrpeEmbeddedFields                                                    }
{------------------------------------------------------------------------------}
   TCrpeEmbeddedFields = class(TCrpeContainerX)
   private
     FItem   : TCrpeEmbeddedFieldsItem;
   protected
     procedure SetIndex (nIndex: integer);
     function  GetItem (nIndex: integer) : TCrpeEmbeddedFieldsItem;
   published
     property Number : TCrLookupNumber
         read FIndex
        write SetIndex
      default -1;
     property Item : TCrpeEmbeddedFieldsItem
         read FItem
        write FItem;
   public
     property ItemIndex : integer
         read FIndex
        write SetIndex;
     property Items[nIndex: integer]: TCrpeEmbeddedFieldsItem
         read GetItem; default;
     function  Count : integer; override;
     procedure Delete (nField: integer);
     procedure Insert (FieldName: string; Position: LongInt);
//     procedure Assign(Source: TPersistent); override;
     procedure Clear;
     constructor Create;
     destructor Destroy; override;
   end; { Class TCrpeEmbeddedFields }

{------------------------------------------------------------------------------}
{ Class TCrpeTextObjectsItem                                                   }
{------------------------------------------------------------------------------}
  TCrpeTextObjectsItem = class(TCrpeObjectItemBX)
  private
    FParagraphs     : TCrpeParagraphs;
    FEmbeddedFields : TCrpeEmbeddedFields;
    FLines          : TStrings;
    xLines          : TStrings;
    FTextSize       : LongInt;
    FTextHeight     : LongInt;
  protected
    {Text}
    procedure SetLines (ListVar: TStrings);
    procedure OnChangeLines (Sender: TObject);
    procedure SetTextSize (const Value: LongInt);
    procedure SetTextHeight (const Value: LongInt);
  published
    property Paragraphs : TCrpeParagraphs
        read FParagraphs
       write FParagraphs;
    property EmbeddedFields : TCrpeEmbeddedFields
        read FEmbeddedFields
       write FEmbeddedFields;
    property Lines : TStrings
        read FLines
       write SetLines;
    property TextSize : LongInt
        read FTextSize
       write SetTextSize;
    property TextHeight : LongInt
        read FTextHeight
       write SetTextHeight;
  public
    procedure Assign(Source: TPersistent); override;
    procedure Clear;
    procedure InsertText (Text: TStrings; Position: LongInt);
    procedure DeleteText (TextStart, TextEnd: LongInt);
    procedure InsertFile (FilePath: string; Position: LongInt);
    constructor Create;
    destructor Destroy; override;
  end;  { TCrpeTextObjectsItem }

{------------------------------------------------------------------------------}
{ Class TCrpeTextObjects                                                       }
{------------------------------------------------------------------------------}
  TCrpeTextObjects = class(TCrpeObjectContainerBX)
  private
  protected
    procedure SetIndex (nIndex: integer);
    function  GetItems (nIndex: integer) : TCrpeTextObjectsItem;
    function  GetItem : TCrpeTextObjectsItem;
    procedure SetItem (const nItem: TCrpeTextObjectsItem);
  published
    property Number : TCrLookupNumber
        read FIndex
       write SetIndex
     default -1;
    property Item : TCrpeTextObjectsItem
        read GetItem
       write SetItem;
  public
    property ItemIndex : integer
        read FIndex
       write SetIndex;
    property Items[nIndex: integer]: TCrpeTextObjectsItem
        read GetItems; default;
//    procedure Assign(Source: TPersistent); override;
    procedure Clear;
    constructor Create;
    destructor Destroy; override;
  end;  {TCrpeTextObjects}

{------------------------------------------------------------------------------}
{ Class TCrpeWindowsVersion                                                    }
{------------------------------------------------------------------------------}
  TCrpeWindowsVersion = class(TCrpePersistentX)
  private
    FPlatform : string;
    FMajor    : DWord;
    FMinor    : DWord;
    FBuild    : string;
  protected
    function  GetPlatform : string;
    procedure SetPlatform(const Value: string);
    function  GetMinor: DWord;
    procedure SetMinor(const Value: DWord);
    function  GetMajor: DWord;
    procedure SetMajor(const Value: DWord);
    function  GetBuild : string;
    procedure SetBuild(const Value: string);
  published
    property Platform : string
        read GetPlatform
       write SetPlatform;
    property Major : DWord
        read GetMajor
       write SetMajor;
    property Minor : DWord
        read GetMinor
       write SetMinor;
    property Build : string
        read GetBuild
       write SetBuild;
  public
    procedure Clear;
    constructor Create;
  end; { Class TCrpeWindowsVersion Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeEngineVersion                                                     }
{------------------------------------------------------------------------------}
  TCrpeEngineVersion = class(TCrpePersistentX)
  private
    FDLL         : string;
    FEngine      : string;
    FFileVersion : string;
    FMajor       : integer;
    FMinor       : integer;
    FRelease     : integer;
    FBuild       : integer;
  protected
    function  GetDLL : string;
    procedure SetDLL(const Value : string);
    function  GetEngine : string;
    procedure SetEngine(const Value : string);
    function  GetFileVersion : string;
    procedure SetFileVersion(const Value : string);
    function  GetMajor : integer;
    procedure SetMajor(const Value : integer);
    function  GetMinor : integer;
    procedure SetMinor(const Value : integer);
    function  GetRelease : integer;
    procedure SetRelease(const Value : integer);
    function  GetBuild : integer;
    procedure SetBuild(const Value : integer);
  published
    property DLL : string
        read GetDLL
       write SetDLL;
    property Engine : string
        read GetEngine
       write SetEngine;
    property FileVersion : string
        read GetFileVersion
       write SetFileVersion;
    property Major : integer
        read GetMajor
       write SetMajor;
    property Minor : integer
        read GetMinor
       write SetMinor;
    property Release : integer
        read GetRelease
       write SetRelease;
    property Build : integer
        read GetBuild
       write SetBuild;
  public
    procedure Clear;
    constructor Create;
  end; { Class TCrpeEngineVersion Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeReportVersion                                                     }
{------------------------------------------------------------------------------}
  TCrpeReportVersion = class(TCrpePersistentX)
  private
    FMajor  : Word;
    FMinor  : Word;
    FLetter : string;
  protected
    function  GetMajor: Word;
    procedure SetMajor(const Value: Word);
    function  GetMinor: Word;
    procedure SetMinor(const Value: Word);
    function  GetLetter: string;
    procedure SetLetter(const Value: string);
  published
    property Major : Word
        read GetMajor
       write SetMajor;
    property Minor : Word
        read GetMinor
       write SetMinor;
    property Letter : string
        read GetLetter
       write SetLetter;
  public
    procedure Clear;
    constructor Create;
  end; { Class TCrpeReportVersion Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeVersion                                                           }
{------------------------------------------------------------------------------}
  TCrpeVersion = class(TCrpePersistentX)
  private
    FCrpe    : TCrpeEngineVersion;
    FReport  : TCrpeReportVersion;
    FWindows : TCrpeWindowsVersion;
  protected
  published
    property Crpe : TCrpeEngineVersion
        read FCrpe
       write FCrpe;
    property Report : TCrpeReportVersion
        read FReport
       write FReport;
    property Windows : TCrpeWindowsVersion
        read FWindows
       write FWindows;
  public
    procedure Clear;
    constructor Create;
    destructor Destroy; override;
  end; { Class TCrpeVersion Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeWindowButtonBar                                                   }
{------------------------------------------------------------------------------}
   TCrpeWindowButtonBar = class(TCrpePersistentX)
   private
      FVisible        : Boolean;
      FAllowDrillDown : Boolean;
      FCancelBtn      : Boolean;
      FCloseBtn       : Boolean;
      FExportBtn      : Boolean;
      FGroupTree      : Boolean;
      FNavigationCtls : Boolean;
      FPrintBtn       : Boolean;
      FPrintSetupBtn  : Boolean;
      FProgressCtls   : Boolean;
      FRefreshBtn     : Boolean;
      FSearchBtn      : Boolean;
      FZoomCtl        : Boolean;
      FToolbarTips    : Boolean;
      FDocumentTips   : Boolean;
      FLaunchBtn      : Boolean;
   protected
      function  GetVisible : Boolean;
      procedure SetVisible(const Value: Boolean);
      function  GetAllowDrillDown : Boolean;
      procedure SetAllowDrillDown(const Value: Boolean);
      function  GetCancelBtn : Boolean;
      procedure SetCancelBtn(const Value: Boolean);
      function  GetCloseBtn : Boolean;
      procedure SetCloseBtn(const Value: Boolean);
      function  GetExportBtn : Boolean;
      procedure SetExportBtn(const Value: Boolean);
      function  GetGroupTree : Boolean;
      procedure SetGroupTree(const Value: Boolean);
      function  GetNavigationCtls : Boolean;
      procedure SetNavigationCtls(const Value: Boolean);
      function  GetPrintBtn : Boolean;
      procedure SetPrintBtn(const Value: Boolean);
      function  GetPrintSetupBtn : Boolean;
      procedure SetPrintSetupBtn(const Value: Boolean);
      function  GetProgressCtls : Boolean;
      procedure SetProgressCtls(const Value: Boolean);
      function  GetRefreshBtn : Boolean;
      procedure SetRefreshBtn(const Value: Boolean);
      function  GetSearchBtn : Boolean;
      procedure SetSearchBtn(const Value: Boolean);
      function  GetZoomCtl : Boolean;
      procedure SetZoomCtl(const Value: Boolean);
      function  GetToolbarTips : Boolean;
      procedure SetToolbarTips(const Value: Boolean);
      function  GetDocumentTips : Boolean;
      procedure SetDocumentTips(const Value: Boolean);
      function  GetLaunchBtn : Boolean;
      procedure SetLaunchBtn(const Value: Boolean);
   published
      property Visible : Boolean
          read GetVisible
         write SetVisible
       default True;
      property AllowDrillDown : Boolean
          read GetAllowDrillDown
         write SetAllowDrillDown
       default False;
      property CancelBtn : Boolean
          read GetCancelBtn
         write SetCancelBtn
       default False;
      property CloseBtn : Boolean
          read GetCloseBtn
         write SetCloseBtn
       default False;
      property ExportBtn : Boolean
          read GetExportBtn
         write SetExportBtn
       default True;
      property GroupTree : Boolean
          read GetGroupTree
         write SetGroupTree
       default False;
      property NavigationCtls : Boolean
          read GetNavigationCtls
         write SetNavigationCtls
       default True;
      property PrintBtn : Boolean
          read GetPrintBtn
         write SetPrintBtn
       default True;
      property PrintSetupBtn : Boolean
          read GetPrintSetupBtn
         write SetPrintSetupBtn
       default False;
      property ProgressCtls : Boolean
          read GetProgressCtls
         write SetProgressCtls
       default True;
      property RefreshBtn : Boolean
          read GetRefreshBtn
         write SetRefreshBtn
       default False;
      property SearchBtn : Boolean
          read GetSearchBtn
         write SetSearchBtn
       default False;
      property ZoomCtl : Boolean
          read GetZoomCtl
         write SetZoomCtl
       default True;
      property ToolbarTips : Boolean
          read GetToolbarTips
         write SetToolbarTips
       default True;
      property DocumentTips : Boolean
          read GetDocumentTips
         write SetDocumentTips
       default False;
      property LaunchBtn : Boolean
          read GetLaunchBtn
         write SetLaunchBtn
       default False;
   public
     procedure Clear;
     procedure ActivateAll;
     procedure Send;
     constructor Create;
   end; { Class TCrpeWindowButtonBar Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeWindowCursor                                                      }
{------------------------------------------------------------------------------}
   TCrpeWindowCursor = class(TCrpePersistentX)
   private
      FGroupArea       : TCrWindowCursor;
      FGroupAreaField  : TCrWindowCursor;
      FDetailArea      : TCrWindowCursor;
      FDetailAreaField : TCrWindowCursor;
      FGraph           : TCrWindowCursor;
      FOnDemandSubreport : TCrWindowCursor;
      FHyperLink       : TCrWindowCursor;
   protected
     function  GetGroupArea : TCrWindowCursor;
     procedure SetGroupArea (const Value: TCrWindowCursor);
     function  GetGroupAreaField : TCrWindowCursor;
     procedure SetGroupAreaField (const Value: TCrWindowCursor);
     function  GetDetailArea : TCrWindowCursor;
     procedure SetDetailArea (const Value: TCrWindowCursor);
     function  GetDetailAreaField : TCrWindowCursor;
     procedure SetDetailAreaField (const Value: TCrWindowCursor);
     function  GetGraph : TCrWindowCursor;
     procedure SetGraph (const Value: TCrWindowCursor);
     function  GetOnDemandSubreport : TCrWindowCursor;
     procedure SetOnDemandSubreport (const Value: TCrWindowCursor);
     function  GetHyperLink : TCrWindowCursor;
     procedure SetHyperLink (const Value: TCrWindowCursor);
     function  ConvertCursorType(rptCursor: Smallint): TCrWindowCursor;
   published
      property GroupArea : TCrWindowCursor
          read GetGroupArea
         write SetGroupArea;
      property GroupAreaField : TCrWindowCursor
          read GetGroupAreaField
         write SetGroupAreaField;
      property DetailArea : TCrWindowCursor
          read GetDetailArea
         write SetDetailArea;
      property DetailAreaField : TCrWindowCursor
          read GetDetailAreaField
         write SetDetailAreaField;
      property Graph : TCrWindowCursor
          read GetGraph
         write SetGraph;
      property OnDemandSubreport : TCrWindowCursor
          read GetOnDemandSubreport
         write SetOnDemandSubreport;
      property HyperLink : TCrWindowCursor
          read GetHyperLink
         write SetHyperLink;
   public
     procedure Clear;
     procedure Send;
     constructor Create;
   end; { Class TCrpeWindowCursor Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeWindowSize                                                        }
{------------------------------------------------------------------------------}
   TCrpeWindowSize = class(TCrpePersistentX)
   private
      FTop     : Smallint;
      FLeft    : Smallint;
      FWidth   : Smallint;
      FHeight  : Smallint;
   protected
      function  GetLeft : Smallint;
      procedure SetLeft(const Value : Smallint);
      function  GetTop : Smallint;
      procedure SetTop(const Value : Smallint);
      function  GetWidth : Smallint;
      procedure SetWidth(const Value : Smallint);
      function  GetHeight : Smallint;
      procedure SetHeight(const Value : Smallint);
   published
      property Left : Smallint
          read GetLeft
         write SetLeft
       default -1;
      property Top : Smallint
          read GetTop
         write SetTop
       default -1;
      property Width : Smallint
          read GetWidth
         write SetWidth
       default -1;
      property Height : Smallint
          read GetHeight
         write SetHeight
       default -1;
   public
     procedure Clear;
     constructor Create;
   end; { Class TCrpeWindowSize Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeWindowStyle                                                       }
{------------------------------------------------------------------------------}
   TCrpeWindowStyle = class(TCrpePersistentX)
   private
      FTitle       : string;
      FSystemMenu  : Boolean;
      FMaxButton   : Boolean;
      FMinButton   : Boolean;
      FBorderStyle : TCrFormBorderStyle;
      FDisabled    : Boolean;
      FMDIForm     : TForm;
   protected
      procedure SetTitle(const Value: string);
      procedure SetDisabled(const Value: Boolean);
      procedure OnMDIResize(Sender: TObject);
      procedure OnMDIClose(Sender: TObject; var Action: TCloseAction);
   published
      property Title : string
          read FTitle
         write SetTitle;
      property SystemMenu : Boolean
          read FSystemMenu
         write FSystemMenu
       default True;
      property MaxButton : Boolean
          read FMaxButton
         write FMaxButton
       default True;
      property MinButton : Boolean
          read FMinButton
         write FMinButton
       default True;
      property BorderStyle : TCrFormBorderStyle
          read FBorderStyle
         write FBorderStyle
       default bsSizeable;
      property Disabled : Boolean
          read FDisabled
         write SetDisabled
       default False;
   public
     procedure Clear;
     constructor Create;
   end; { Class TCrpeWindowStyle Declaration }

{------------------------------------------------------------------------------}
{ Class TCrpeWindowZoom                                                        }
{------------------------------------------------------------------------------}
   TCrpeWindowZoom = class(TCrpePersistentX)
   private
      FPreview       : TCrZoomPreview;
      FMagnification : TCrZoomMagnification;
   protected
      procedure SetPreview(const Value: TCrZoomPreview);
      procedure SetMagnification(const Value: TCrZoomMagnification);
   published
      property Preview : TCrZoomPreview
          read FPreview
         write SetPreview
       default pwNormal;
      property Magnification : TCrZoomMagnification
          read FMagnification
         write SetMagnification
       default 0;
   public
     procedure NextLevel;
     procedure Clear;
     constructor Create;
   end; { Class TCrpeWindowZoom Declaration }

implementation

uses
  Dialogs, Messages, Winspool, Printers, ShellApi;

function TCrpePersistentX.Cr: TCrpe;
begin
  Result := nil;
  if Assigned(Cx) then
    Result := TCrpe(Cx);
end;

function TCrpeItemX.Cr: TCrpe;
begin
  Result := nil;
  if Assigned(Cx) then
    Result := TCrpe(Cx);
end;

function TCrpeContainerX.Cr: TCrpe;
begin
  Result := nil;
  if Assigned(Cx) then
    Result := TCrpe(Cx);
end;

function TCrpeObjectItemAX.Cr: TCrpe;
begin
  Result := nil;
  if Assigned(Cx) then
    Result := TCrpe(Cx);
end;

function TCrpeObjectContainerAX.Cr: TCrpe;
begin
  Result := nil;
  if Assigned(Cx) then
    Result := TCrpe(Cx);
end;

function TCrpeObjectItemBX.Cr: TCrpe;
begin
  Result := nil;
  if Assigned(Cx) then
    Result := TCrpe(Cx);
end;

function TCrpeObjectContainerBX.Cr: TCrpe;
begin
  Result := nil;
  if Assigned(Cx) then
    Result := TCrpe(Cx);
end;

function TCrpeFieldObjectItemX.Cr: TCrpe;
begin
  Result := nil;
  if Assigned(Cx) then
    Result := TCrpe(Cx);
end;

function TCrpeFieldObjectContainerX.Cr: TCrpe;
begin
  Result := nil;
  if Assigned(Cx) then
    Result := TCrpe(Cx);
end;

{******************************************************************************}
{ TCrpe Class Definition                                                       }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpe.Create(AOwner : TComponent);
begin
  inherited Create(AOwner);
  FCrpeEngine := TCrpeEngine.Create;
  hDLL := 0;
  FEngineOpened := False;
  if AOwner is TForm then
  begin
    with AOwner as TForm do
      FParentFormHandle := Handle;
  end
  else
    FParentFormHandle := 0;
  {General}
  FAbout := 'Version and Credits...';
  FReportName := '';
  FTempPath := CrGetTempPath;
  FPrintJob := 0;
  FPrintJobs := TStringList.Create;
  FOutput := toWindow;
  FLoadEngineOnUse := False;
  FIgnoreKnownProblems := True;
  FCrpeState := crsSetup;
  FDesignControls := 'Design-Time Window Controls';
  FProgressDialog := True;
  FWindowEvents := False;
  FReportTitle := '';
  FDetailCopies := 1;
  {Export}
  FExportOptions := TCrpeExportOptions.Create;
  FExportOptions.PropagateCrpe(Self, nil);
  {Pages}
  FPages := TCrpePages.Create;
  FPages.PropagateCrpe(Self, nil);
  {PrintDate}
  FPrintDate := TCrpePrintDate.Create;
  FPrintDate.PropagateCrpe(Self, nil);
  {Printer}
  FPrinter := TCrpePrinter.Create;
  FPrinter.PropagateCrpe(Self, nil);
  FPrintOptions := TCrpePrintOptions.Create;
  FPrintOptions.PropagateCrpe(Self, nil);
  {Records}
  FRecords := TCrpeRecords.Create;
  FRecords.PropagateCrpe(Self, nil);
  {SummaryInfo}
  FSummaryInfo := TCrpeSummaryInfo.Create;
  FSummaryInfo.PropagateCrpe(Self, nil);
  {Version}
  FVersion := TCrpeVersion.Create;
  FVersion.PropagateCrpe(Self, nil);
 {Window}
  {Window Buttons: for Crystal 6.0 & up}
  FWindowButtonBar := TCrpeWindowButtonBar.Create;
  FWindowButtonBar.PropagateCrpe(Self, nil);
  {Window Cursors: for Crystal 6.0 & up}
  FWindowCursor := TCrpeWindowCursor.Create;
  FWindowCursor.PropagateCrpe(Self, nil);
  {Window/Dialog Parent}
  FWindowParent := nil;
  FDialogParent := nil;
  {WindowSize}
  FWindowSize := TCrpeWindowSize.Create;
  FWindowSize.PropagateCrpe(Self, nil);
  {WindowStyle}
  FWindowStyle := TCrpeWindowStyle.Create;
  FWindowStyle.PropagateCrpe(Self, nil);
  {WindowZoom}
  FWindowZoom := TCrpeWindowZoom.Create;
  FWindowZoom.PropagateCrpe(Self, nil);
  {WindowState}
  FWindowState := wsNormal;
 {General Classes shared by Main and Subreports}
  {Group/Sort}
  FSortFields := TCrpeSortFields.Create;
  FSortFields.PropagateCrpe(Self, nil);
  FGroupSortFields := TCrpeGroupSortFields.Create;
  FGroupSortFields.PropagateCrpe(Self, nil);
  FGroups := TCrpeGroups.Create;
  FGroups.PropagateCrpe(Self, nil);
  {Margins}
  FMargins := TCrpeMargins.Create;
  FMargins.PropagateCrpe(Self, nil);
  {ReportOptions}
  FReportOptions := TCrpeReportOptions.Create;
  FReportOptions.PropagateCrpe(Self, nil);
  {ReportOptions}
  FGlobalOptions := TCrpeGlobalOptions.Create;
  FGlobalOptions.PropagateCrpe(Self, nil);
  {Section/Area Format}
  FAreaFormat := TCrpeAreaFormat.Create;
  FAreaFormat.PropagateCrpe(Self, nil);
  FSectionSize := TCrpeSectionSize.Create;
  FSectionSize.PropagateCrpe(Self, nil);
  FSectionFont := TCrpeSectionFont.Create;
  FSectionFont.PropagateCrpe(Self, nil);
  FSectionFormat := TCrpeSectionFormat.Create;
  FSectionFormat.PropagateCrpe(Self, nil);
  {Selection}
  FSelection := TCrpeSelection.Create;
  FSelection.PropagateCrpe(Self, nil);
  FGroupSelection := TCrpeGroupSelection.Create;
  FGroupSelection.PropagateCrpe(Self, nil);
  {SessionInfo}
  FSessionInfo := TCrpeSessionInfo.Create;
  FSessionInfo.PropagateCrpe(Self, nil);
  {SQL}
  FConnect := TCrpeConnect.Create;
  FConnect.PropagateCrpe(Self, nil);
  FLogOnInfo := TCrpeLogonInfo.Create;
  FLogOnInfo.PropagateCrpe(Self, nil);
  FLogOnServer := TCrpeLogOnServer.Create;
  FLogOnServer.PropagateCrpe(Self, nil);
  {Lines}
  FLines := TCrpeLines.Create;
  FLines.PropagateCrpe(Self, nil);
  {Boxes}
  FBoxes := TCrpeBoxes.Create;
  FBoxes.PropagateCrpe(Self, nil);
  {OleObjects}
  FOleObjects := TCrpeOleObjects.Create;
  FOleObjects.PropagateCrpe(Self, nil);
 {Other Objects}
  {Pictures}
  FPictures := TCrpePictures.Create;
  FPictures.PropagateCrpe(Self, nil);
  {OLAPCubes}
  FOLAPCubes := TCrpeOLAPCubes.Create;
  FOLAPCubes.PropagateCrpe(Self, nil);
  {Maps}
  FMaps := TCrpeMaps.Create;
  FMaps.PropagateCrpe(Self, nil);
  {Subreports}
  FSubreports := TCrpeSubreports.Create;
  FSubreports.PropagateCrpe(Self, nil);
  {TextObjects}
  FTextObjects := TCrpeTextObjects.Create;
  FTextObjects.PropagateCrpe(Self, nil);
  {CrossTabs}
  FCrossTabs := TCrpeCrossTabs.Create;
  FCrossTabs.PropagateCrpe(Self, nil);
  {Tables}
  FTables := TCrpeTables.Create;
  FTables.PropagateCrpe(Self, nil);
  {Graphs}
  FGraphs := TCrpeGraphs.Create;
  FGraphs.PropagateCrpe(Self, nil);
  {SQL}
  FSQL := TCrpeSQL.Create;
  FSQL.PropagateCrpe(Self, nil);
  FSQLExpressions := TCrpeSQLExpressions.Create;
  FSQLExpressions.PropagateCrpe(Self, nil);
  {Field Objects}
  {DatabaseFields}
  FDatabaseFields := TCrpeDatabaseFields.Create;
  FDatabaseFields.PropagateCrpe(Self, nil);
  {Formulas}
  FFormulas := TCrpeFormulas.Create;
  FFormulas.PropagateCrpe(Self, nil);
  {SummaryFields}
  FSummaryFields := TCrpeSummaryFields.Create;
  FSummaryFields.PropagateCrpe(Self, nil);
  {SpecialFields}
  FSpecialFields := TCrpeSpecialFields.Create;
  FSpecialFields.PropagateCrpe(Self, nil);
  {GroupNameFields}
  FGroupNameFields := TCrpeGroupNameFields.Create;
  FGroupNameFields.PropagateCrpe(Self, nil);
  {Parameter Fields}
  FParamFields := TCrpeParamFields.Create;
  FParamFields.PropagateCrpe(Self, nil);
  {Expressions - already done in SQL.Create}
  {RunningTotals}
  FRunningTotals := TCrpeRunningTotals.Create;
  FRunningTotals.PropagateCrpe(Self, nil);

  {OnCreate Event}
  if Assigned(FOnCreate) then
    FOnCreate(Self);
 end; { Constructor Create }

{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpe.Destroy;
begin
  {OnDestroy Event}
  if Assigned(FOnDestroy) then
    FOnDestroy(Self);
  Clear;
  {Close the Print Engine}
  if (hDLL > 0) or (FCrpeEngine.CRDEngine > 0) then
  begin
    ClosePrintEngine;
    FCrpeEngine.PEUnloadCrpeDLL;
    hDLL := 0;
  end;
  FPrintJobs.Free;

  {Main Sub-classes}
  FExportOptions.Free;
  FPages.Free;
  FPrintDate.Free;
  FPrinter.Free;
  FPrintOptions.Free;
  FRecords.Free;
  FSummaryInfo.Free;
  FVersion.Free;

  {Window}
  FWindowButtonBar.Free;
  FWindowCursor.Free;
  FWindowParent := nil;
  FDialogParent := nil;
  FWindowSize.Free;
  {Free the MDIForm if it exists}
  if FWindowStyle.FMDIForm <> nil then
    FWindowStyle.FMDIForm.Free;
  FWindowStyle.Free;
  FWindowZoom.Free;

  {General Classes shared by Main and Subreports}
  {Graphs}
  FGraphs.Free;
  {Group/Sort}
  FSortFields.Free;
  FGroupSortFields.Free;
  FGroups.Free;
  FMargins.Free;
  FReportOptions.Free;
  FGlobalOptions.Free;
  {Section/Area Format}
  FAreaFormat.Free;
  FSectionSize.Free;
  FSectionFont.Free;
  FSectionFormat.Free;
  {Selection}
  FSelection.Free;
  FGroupSelection.Free;
  {SessionInfo}
  FSessionInfo.Free;
  {SQL}
  FConnect.Free;
  FLogOnInfo.Free;
  FLogOnServer.Free;
  FSQL.Free;
  FSQLExpressions.Free;
  {Tables}
  FTables.Free;

  {Field Objects}
  FDatabaseFields.Free;
  FFormulas.Free;
  FSummaryFields.Free;
  FSpecialFields.Free;
  FGroupNameFields.Free;
  FParamFields.Free;
  {FExpressions freed with SQL}
  FRunningTotals.Free;

  {Other Objects}
  FTextObjects.Free;
  FLines.Free;
  FBoxes.Free;
  FSubreports.Free;
  FOleObjects.Free;
  FCrossTabs.Free;
  FPictures.Free;
  FMaps.Free;
  FOLAPCubes.Free;

  FCrpeEngine.Free;

  inherited Destroy;
end; { Destructor Destroy }
{------------------------------------------------------------------------------}
{  Loaded.                                                                     }
{   Checks the LoadEngineOnUse property during Loading.                        }
{------------------------------------------------------------------------------}
procedure TCrpe.Loaded;
begin
  inherited Loaded;
  if not (csDesigning in ComponentState) then
  begin
    if not FLoadEngineOnUse then
      OpenPrintEngine;
  end;
end;

{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpe.Clear;
begin
  {** Set Component Defaults **}
  {Clearing ReportName will Close the PrintJob}
  FReportName := '';
  {General - visible on Object Inspector}
  FDetailCopies := 1;
  FDialogParent := nil;
  FFormulaSyntax := fsCrystal;
  FLoadEngineOnUse := False;
  FIgnoreKnownProblems := True;
  FOutput := toWindow;
  FProgressDialog := True;
  FReportStyle := rsStandard;
  FReportTitle := '';
  FWindowEvents := False;
  FWindowParent := nil;
  FWindowState := wsNormal;

  {General - non visible}
  FCrpeState := crsSetup;
  FLastErrorNumber := 0;
  FLastErrorString := '';

  {Main Report sub-classes}
  FExportOptions.Clear;
  FPrintDate.Clear;
  FPrinter.Clear;
  FPrintOptions.Clear;
  FSummaryInfo.Clear;

  {Window}
  FWindowButtonBar.Clear;
  FWindowCursor.Clear;
  FWindowSize.Clear;
  FWindowStyle.Clear;
  FWindowZoom.Clear;

  {General Classes shared by Main and Subreports}
  {Graphs}
  FGraphs.Clear;
  {Group/Sort}
  FSortFields.Clear;
  FGroupSortFields.Clear;
  FGroups.Clear;
  {Margins}
  FMargins.Clear;
  FGlobalOptions.Clear;
  FReportOptions.Clear;
  {Section/Area Format}
  FAreaFormat.Clear;
  FSectionSize.Clear;
  FSectionFont.Clear;
  FSectionFormat.Clear;
  {Selection}
  FSelection.Clear;
  FGroupSelection.Clear;
  {SessionInfo}
  FSessionInfo.Clear;
  {SQL}
  FConnect.Clear;
  FLogOnInfo.Clear;
  FLogOnServer.Clear;
  FSQL.FQuery.Clear;
  FSQLExpressions.Clear;
  {Tables}
  FTables.Clear;

  {Field Objects}
  FDatabaseFields.Clear;
  FFormulas.Clear;
  FSummaryFields.Clear;
  FSpecialFields.Clear;
  FGroupNameFields.Clear;
  FParamFields.Clear;
  {Expressions cleared with SQL}
  FRunningTotals.Clear;

  {Other Objects}
  FTextObjects.Clear;
  FLines.Clear;
  FBoxes.Clear;
  FSubreports.Clear;
  FOleObjects.Clear;
  FCrossTabs.Clear;
  FPictures.Clear;
  FMaps.Clear;
  FOLAPCubes.Clear;
end; { Clear }

{------------------------------------------------------------------------------}
{  GetCRPEVersion procedure                                                    }
{------------------------------------------------------------------------------}
procedure TCrpe.GetCRPEVersion;
var
  sFile    : string;
  s1,s2,s3 : string;
  x        : char;
  n        : integer;
  nMajor   : integer;
  nMinor   : integer;
  nRelease : integer;
  nBuild   : integer;
  dwError  : DWord;
begin
  {Load the CRPE32.DLL}
  sFile := GetCommonFilesPath + 'CRPE32.DLL';
  if not FileExists(sFile) then
    sFile := 'CRPE32.DLL';

  {Get CRPE FileVersion}
  dwError := GetVersionInfo(sFile, 'FileVersion', s1);
  if dwError <> 0 then
  begin
    s2 := SysErrorMessage(GetLastError);
    if IsStrEmpty(s2) then
      s1 := 'GetCrpeVersion <GetVersionInfo>' + Chr(13) + Chr(10) +
        'Windows Error Number: ' + IntToStr(dwError)
    else
      s1 := 'GetCrpeVersion <GetVersionInfo>' + Chr(13) + Chr(10) +
        'Windows Error Number: ' + IntToStr(dwError) + ' - ' + Trim(s2);
    case GetErrorMsg(0,errNoOption,errVCL,ECRPE_VERSION_INFO, s1) of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  FVersion.FCrpe.FFileVersion := s1;

  x := 'x';
  if s1 <> '7,0,0,0' then
  begin
    if Length(s1) > 0 then
    begin
      if Pos(',', s1) > 0 then
        x := ','
      else if Pos('.', s1) > 0 then
        x := '.';
    end;
    if x <> 'x' then
    begin
      {Get First (major) Version Number: only take numbers}
      s2 := GetToken(s1, x);
      s3 := '';
      for n := 1 to Length(s2) do
      begin
        if (Ord(s2[n]) > 47) and (Ord(s2[n]) < 58) then
          s3 := s3 + s2[n];
      end;
      if IsNumeric(s3) then
        FVersion.FCrpe.FMajor := StrToInt(s3);
      {Get Second Version Number}
      s2 := GetToken(s1, x);
      if IsNumeric(s2) then
        FVersion.FCrpe.FMinor := StrToInt(s2);
      {Get Third Version Number}
      s2 := GetToken(s1, x);
      if IsNumeric(s2) then
        FVersion.FCrpe.FRelease := StrToInt(s2);
      {Get Fourth (minor) Version Number: only take numbers}
      s2 := '';
      for n := 1 to Length(s1) do
      begin
        if (Ord(s1[n]) > 47) and (Ord(s1[n]) < 58) then
          s2 := s2 + s1[n];
      end;
      FVersion.FCrpe.FBuild := StrToInt(s2);
    end;
  end;

  {If version wasn't obtained, initialize the variables}
  if x = 'x' then
  begin
    FVersion.FCrpe.FMajor   := 0;
    FVersion.FCrpe.FMinor   := 0;
    FVersion.FCrpe.FRelease := 0;
    FVersion.FCrpe.FBuild   := 0;
  end;

  {OnGetVersion event: let the user over-ride major/minor}
  nMajor := FVersion.FCrpe.FMajor;
  nMinor := FVersion.FCrpe.FMinor;
  nRelease := FVersion.FCrpe.FRelease;
  nBuild := FVersion.FCrpe.FBuild;
  if Assigned(FOnGetVersion) then
  begin
    FOnGetVersion(Self, nMajor, nMinor, nRelease, nBuild);
    FVersion.FCrpe.FMajor := nMajor;
    FVersion.FCrpe.FMinor := nMinor;
    FVersion.FCrpe.FRelease := nRelease;
    FVersion.FCrpe.FBuild := nBuild;
  end;
  {Update the CRDynamic variables}
  FCrpeEngine.CRDVerMajor   := FVersion.FCrpe.FMajor;
  FCrpeEngine.CRDVerMinor   := FVersion.FCrpe.FMinor;
  FCrpeEngine.CRDVerRelease := FVersion.FCrpe.FRelease;
  FCrpeEngine.CRDVerBuild   := FVersion.FCrpe.FBuild;
end;
{------------------------------------------------------------------------------}
{ LoadEngine                                                                   }
{------------------------------------------------------------------------------}
function TCrpe.LoadEngine : Boolean;
var
  bLoaded            : Boolean;
  ErrString          : string;
  sCrpe              : string;
begin
  Result := True;
  {If the DLL is not loaded...}
  if (hDLL = 0) then
  begin
    {Get the CRPE DLL version}
    GetCRPEVersion;
    {If the engine major version is not 11, quit}
    if FVersion.FCrpe.FMajor <> 11 then
    begin
      FLastErrorNumber := GetErrorNum(ECRPE_VERSION);
      ErrString := GetErrorStr(ECRPE_VERSION);
      FLastErrorString := ErrString + Chr(13) + Chr(10) +
        'CRPE32.DLL' + ' :: ' + FVersion.FCrpe.FFileVersion;
      raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;

    {Load the CRPE32.DLL}
    bLoaded := False;
    sCrpe := GetCommonFilesPath + 'CRPE32.DLL';
    if not FileExists(sCrpe) then
      sCrpe := 'CRPE32.DLL';
    if FileExists(sCrpe) then
    begin
      if FCrpeEngine.PELoadCrpeDll(sCrpe) then
      begin
        bLoaded := True;
        hDLL := FCrpeEngine.CRDEngine;
      end;
    end;

    {If the load attempt failed, report the error}
    if not bLoaded then
    begin
      {If an error was encountered...}
      Result := False;
      case GetErrorMsg(0, errNoOption, errVCL, ECRPE_LOAD_DLL, '') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ CrpeHandle                                                                   }
{------------------------------------------------------------------------------}
function TCrpe.CrpeHandle : THandle;
begin
  Result := hDLL;
end;
{------------------------------------------------------------------------------}
{ OpenEngine                                                                   }
{------------------------------------------------------------------------------}
function TCrpe.OpenEngine;
begin
  Result := OpenPrintEngine;
end;
{------------------------------------------------------------------------------}
{ OpenPrintEngine                                                              }
{------------------------------------------------------------------------------}
function TCrpe.OpenPrintEngine : Boolean;
begin
  Result := False;
  {Load the CRPE32.DLL}
  if not LoadEngine then Exit;
  if FEngineOpened then
  begin
    Result := True;
    Exit;
  end;
  {Attemp to Open the Engine...}
  FEngineOpened := FCrpeEngine.PEOpenEngine;
  if not FEngineOpened then
  begin
    case GetErrorMsg(0,errNoOption,errEngine,'','OpenPrintEngine <PEOpenEngine>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  SetTempPath(FTempPath);
  Result := True;
end; { OpenPrintEngine }
{------------------------------------------------------------------------------}
{ EngineOpen                                                                   }
{------------------------------------------------------------------------------}
function TCrpe.EngineOpen : Boolean;
begin
  Result := FEngineOpened;
end;
{------------------------------------------------------------------------------}
{ CanCloseEngine                                                               }
{------------------------------------------------------------------------------}
function TCrpe.CanCloseEngine : Boolean;
begin
  Result := True;
  if (hDLL = 0) then Exit;
  Result := FCrpeEngine.PECanCloseEngine;
end;
{------------------------------------------------------------------------------}
{ CloseEngine                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpe.CloseEngine;
begin
  ClosePrintJob;
  ClosePrintEngine;
end;
{------------------------------------------------------------------------------}
{ ClosePrintEngine                                                             }
{------------------------------------------------------------------------------}
procedure TCrpe.ClosePrintEngine;
begin
  FCrpeEngine.PECloseEngine;
  FEngineOpened := False;
  {If the Engine is to be loaded only as needed, unload it now}
  if FLoadEngineOnUse then
  begin
    if (hDLL > 0) or (FCrpeEngine.CRDEngine > 0) then
    begin
      FCrpeEngine.PEUnloadCrpeDLL;
      hDLL := 0;
      FVersion.Clear;
    end;
  end;
end; { ClosePrintEngine }
{------------------------------------------------------------------------------}
{ UnloadEngine                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpe.UnloadEngine;
begin
  {Make sure PrintJob and Engine are closed first}
  CloseEngine;
  {Unload DLL}
  if hDLL > 0 then
  begin
    hDLL := 0;
    FCrpeEngine.PEUnloadCrpeDLL;
    FVersion.Clear;
  end;
end;

{------------------------------------------------------------------------------}
{ OpenJob                                                                      }
{------------------------------------------------------------------------------}
function TCrpe.OpenJob: Boolean;
begin
  Result := OpenPrintJob;
end;
{------------------------------------------------------------------------------}
{ OpenPrintJob function                                                        }
{------------------------------------------------------------------------------}
function TCrpe.OpenPrintJob: Boolean;
begin
  Result := True;
  {If ReportName is blank raise error}
  if IsStrEmpty(FReportName) then
  begin
    Result := False;
    case GetErrorMsg(0,errNoOption,errVCL,ECRPE_NO_NAME,'') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  {If ReportName doesn't exist raise error}
  if not FileExists(FReportName) then
  begin
    Result := False;
    case GetErrorMsg(0,errNoOption,errVCL,ECRPE_REPORT_NOT_FOUND,'') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;

  {Make sure the Engine is Open}
  if not OpenPrintEngine then
  begin
    Result := False;
    Exit;
  end;

  {Check JobNumber list}
  if FPrintJobs.Count = 0 then
    FPrintJobs.Add('0');

  {Open Main Report Job if required}
  if PrintJobs(0) = 0 then
  begin
    {Open the Main PrintJob}
    FPrintJob := FCrpeEngine.PEOpenPrintJob(PChar(FReportName));
    FPrintJobs[0] := IntToStr(FPrintJob);
    {If PrintJob is zero, generate error}
    if FPrintJob = 0 then
    begin
      Result := False;
      case GetErrorMsg(0,errNoOption,errEngine,'','OpenPrintJob <PEOpenPrintJob>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
    if Assigned(FOnJobOpened) then
      FOnJobOpened(Self, FPrintJob);
  end;

  {Subreport}
  if FSubreports.FIndex > 0 then
  begin
    {Just in case!  Check the index...}
    if FSubreports.FIndex > (FPrintJobs.Count-1) then
      FSubreports.FIndex := (FPrintJobs.Count-1);
    if PrintJobs(FSubreports.FIndex) = 0 then
    begin
      {Open the Subreport PrintJob}
      FPrintJob := FCrpeEngine.PEOpenSubreport(PrintJobs(0), PChar(FSubreports.FName));
      FPrintJobs[FSubreports.FIndex] := IntToStr(FPrintJob);
      {If PrintJob is zero, generate error}
      if FPrintJob = 0 then
      begin
        Result := False;
        case GetErrorMsg(0,errNoOption,errEngine,'',
            'OpenPrintJob - Subreports[' + IntToStr(FSubreports.FIndex) +
            '] <PEOpenSubreport>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
        end;
      end;
    end;
  end;
end; { OpenPrintJob }
{------------------------------------------------------------------------------}
{ JobIsOpen                                                                    }
{------------------------------------------------------------------------------}
function TCrpe.JobIsOpen : Boolean;
begin
  Result := (FPrintJob > 0);
end;
{------------------------------------------------------------------------------}
{ JobNumber                                                                    }
{------------------------------------------------------------------------------}
function TCrpe.JobNumber : Smallint;
begin
  Result := FPrintJob;
end;
{------------------------------------------------------------------------------}
{ SetReportName                                                                }
{------------------------------------------------------------------------------}
procedure TCrpe.SetReportName(NewName: string);
begin
  if IsStrEmpty(NewName) or (CompareText(NewName, FReportName) <> 0) then
  begin
    ClosePrintJob;
    FReportName := NewName;
    FSubreports.Clear;
  end;
end;

{------------------------------------------------------------------------------}
{ CancelJob                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpe.CancelJob;
begin
  if (FPrintJob = 0) then
    Exit;
  FCrpeEngine.PECancelPrintJob(FPrintJob);
end;
{------------------------------------------------------------------------------}
{ CloseJob                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpe.CloseJob;
begin
  ClosePrintJob;
end;
{------------------------------------------------------------------------------}
{  ClosePrintJob procedure                                                     }
{------------------------------------------------------------------------------}
procedure TCrpe.ClosePrintJob;
var
  i : integer;
begin
  if (hDLL = 0) then Exit;
  if (FPrintJob = 0) then Exit;

  {Loop through Reports and Close Jobs}
  for i := (FSubreports.Count - 1) downto 1 do
  begin
    FSubreports.SetIndex(i);
    if (FPrintJob <> 0) then
    begin
      {Close Subreport}
      if not FCrpeEngine.PECloseSubreport(FPrintJob) then
      begin
        case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
            'ClosePrintJob <PECloseSubreport>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
        end;
      end;
    end;
    FPrintJobs.Delete(i);
  end;

  {Close the Main report}
  FSubreports.SetIndex(0);
  if not FCrpeEngine.PEClosePrintJob(FPrintJob) then
  begin
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
        'ClosePrintJob <PEClosePrintJob>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  FPrintJobs.Clear;
  FPrintJob := 0;
  FSubreports.Clear;
  if FLoadEngineOnUse then ClosePrintEngine;
end; { ClosePrintJob }

{------------------------------------------------------------------------------}
{ IsJobFinished                                                                }
{------------------------------------------------------------------------------}
function TCrpe.IsJobFinished : Boolean;
begin
  Result := True;
  if (FPrintJob = 0) then Exit;
  Result := FCrpeEngine.PEIsPrintJobFinished(FPrintJob);
end;
{------------------------------------------------------------------------------}
{ Status                                                                       }
{------------------------------------------------------------------------------}
function TCrpe.Status : TCrStatus;
var
  JobInfo : PEJobInfo;
  i       : smallint;
begin
  Result := crsNotOpen;
  if FPrintJob = 0 then Exit;
  {Get the Status}
  i := FCrpeEngine.PEGetJobStatus(FPrintJob, JobInfo);
  if i <= 0 then
    Result := crsNotOpen
  else
  begin
    if i > Ord(High(TCrStatus)) then i := Ord(crsUnknown);
    Result := TCrStatus(i);
  end;
end;
{------------------------------------------------------------------------------}
{ PrintEnded                                                                   }
{------------------------------------------------------------------------------}
function TCrpe.PrintEnded: Boolean;
var
  JobInfo : PEJobInfo;
  i       : smallint;
begin
  Result := True;
  if FPrintJob = 0 then Exit;
  {Get the Status}
  i := FCrpeEngine.PEGetJobStatus(FPrintJob, JobInfo);
  if i <= 0 then Exit;
  Result := JobInfo.PrintEnded;
end;

{------------------------------------------------------------------------------}
{ Save                                                                         }
{------------------------------------------------------------------------------}
function TCrpe.Save (filePath: string): Boolean;
begin
  Result := False;
  if IsStrEmpty(FReportName) then
  begin
    case GetErrorMsg(0,errNoOption,errVCL,ECRPE_NO_NAME,'<TCrpe.Save>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  if not OpenPrintJob then Exit;
{ShowMessage: only seems to apply to Main Report - if I use
 Sub Job Number, get error 140}
  if not FCrpeEngine.PESavePrintJob(PrintJobs(0), PChar(filePath)) then
  begin
    case GetErrorMsg(PrintJobs(0),errNoOption,errEngine,'',
        'Save <PESavePrintJob>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  Result := True;
end;
{------------------------------------------------------------------------------}
{ SaveAs                                                                       }
{------------------------------------------------------------------------------}
function TCrpe.SaveAs (filePath: string): Boolean;
var
  p : Pointer;
  x : LongInt;
begin
  Result := False;
  if IsStrEmpty(FReportName) then Exit;
  if not OpenPrintJob then Exit;

  p := nil;
  x := PE_SAVEAS_FORMAT_SCRDEFAULT;
  if not FCrpeEngine.PESavePrintJobAs(FPrintJob, PChar(filePath), x, p) then
  begin
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
        'SaveAs <PESavePrintJobAs>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  Result := True;
end;

{------------------------------------------------------------------------------}
{  BuildErrorString                                                            }
{------------------------------------------------------------------------------}
function TCrpe.BuildErrorString (Source: TCrpePersistent): string;
var
  zClass : TPersistent;
  zList  : TStringList;
  s1     : string;
  i      : integer;

  function ConvertClassName(xClass: TPersistent): string;
  var
    Name : string;
  begin
    Name := xClass.ClassName;
    if Pos('Item', Name) <> 0 then
    begin
      Result := '';
      Exit;
    end;
    if Name = 'TCrpeFieldObjectFormat' then
      Result := 'Format'
    else if Name = 'TCrpeFieldFormat' then
      Result := 'Field'
    else if Name = 'TCrpeFieldFormatFormulas' then
      Result := 'Formulas'
    else if Name = 'TCrpeNumberFormat' then
      Result := 'Number'
    else if Name = 'TCrpeDateFormat' then
      Result := 'Date'
    else if Name = 'TCrpeTimeFormat' then
      Result := 'Time'
    else if Name = 'TCrpeDateTimeFormat' then
      Result := 'DateTime'
    else if Name = 'TCrpeParagraphFormat' then
      Result := 'Paragraph'
    else if Name = 'TCrpeBorder' then
      Result := 'Border'
    else if Name = 'TCrpeFormatA' then
      Result := 'Format'
    else if Name = 'TCrpeFormatFormulasA' then
      Result := 'Formulas'
    else if Name = 'TCrpeFormatB' then
      Result := 'Format'
    else if Name = 'TCrpeFormatC' then
      Result := 'Format'
    else if Name = 'TCrpeFormatFormulasB' then
      Result := 'Formulas'
    else if Name = 'TCrpeBorderFormulas' then
      Result := 'Formulas'
    else if Name = 'TCrpeAreaFormatFormulas' then
      Result := 'Formulas'
    else if Name = 'TCrpeCrossTabSummaries' then
      Result := 'Summaries'
    else if Name = 'TCrpeCrossTabGroups' then
    begin
      if TCrpeCrossTabGroups(xClass).Item.FRowCol = gpRow then
        Result := 'RowGroups'
      else
        Result := 'ColumnGroups';
    end
    else if Name = 'TCrpeExportEmail' then
      Result := 'Email'
    else if Name = 'TCrpeExportExcel' then
      Result := 'Excel'
    else if Name = 'TCrpeExportExchange' then
      Result := 'Exchange'
    else if Name = 'TCrpeExportHTML' then
      Result := 'HTML'
    else if Name = 'TCrpeExportLotusNotes' then
      Result := 'LotusNotes'
    else if Name = 'TCrpeExportODBC' then
      Result := 'ODBC'
    else if Name = 'TCrpeExportPDF' then
      Result := 'PDF'
    else if Name = 'TCrpeExportRTF' then
      Result := 'RTF'
    else if Name = 'TCrpeExportText' then
      Result := 'Text'
    else if Name = 'TCrpeExportWord' then
      Result := 'Word'
    else if Name = 'TCrpeExportXML' then
      Result := 'XML'
    else if Name = 'TCrpeGraphAxis' then
      Result := 'Axis'
    else if Name = 'TCrpeGraphOptionInfo' then
      Result := 'OptionInfo'
    else if Name = 'TCrpeGraphOptions' then
      Result := 'Options'
    else if Name = 'TCrpeGraphText' then
      Result := 'Text'
    else if Name = 'TCrpeMapSummaryFields' then
      Result := 'SummaryFields'
    else if Name = 'TCrpeMapConditionFields' then
      Result := 'ConditionFields'
    else if Name = 'TCrpeParamFieldInfo' then
      Result := 'Info'
    else if Name = 'TCrpeParamFieldRanges' then
      Result := 'Ranges'
    else if Name = 'TCrpeParamFieldPromptValues' then
      Result := 'PromptValues'
    else if Name = 'TCrpeParamFieldCurrentValues' then
      Result := 'CurrentValues'
    else if Name = 'TCrpeSectionFormatFormulas' then
      Result := 'Formulas'
    else if Name = 'TCrpeTableFields' then
      Result := 'Fields'
    else
      Result := Copy(xClass.ClassName, 6, Length(xClass.ClassName));
  end;

begin
  zList := TStringList.Create;
  s1 := '';
  zClass := Source;

  {If it is a Container class, take the Class Name and get the Parent}
  if zClass is TCrpeContainer then
  begin
    s1 := ConvertClassName(zClass);
    if not IsStrEmpty(s1) then zList.Add(s1);
    zClass := TCrpePersistent(zClass).Parent;
  end;

  {If it is an Item class, take the Class Name + Index and get the Parent}
  if zClass is TCrpeItem then
  begin
    s1 := ConvertClassName(TCrpeItem(zClass).Parent);
    if not IsStrEmpty(s1) then zList.Add(s1 + '[' + IntToStr(TCrpeItem(zClass).FIndex) + ']');
    zClass := TCrpePersistent(zClass).Parent;
    if zClass is TCrpePersistent then
      zClass := TCrpePersistent(zClass).Parent;
  end;

  {Loop to follow the Class heirarchy, gathering Names}
  while (zClass is TCrpePersistent) do
  begin
    s1 := ConvertClassName(zClass);
    if zClass is TCrpeContainer then
      zList.Add(s1 + '[' + IntToStr(TCrpeContainer(zClass).FIndex) + ']')
    else
      if not IsStrEmpty(s1) then zList.Add(s1);
    zClass := TCrpePersistent(zClass).Parent;
  end;

  {Build the final Class heirarchy string}
  s1 := '';
  for i := (zList.Count-1) downto 0 do
    s1 := s1 + zList[i] + '.';
  zList.Free;
  Result := s1;
end;

{------------------------------------------------------------------------------}
{  GetErrorMsg function : Get Errors generated by VCL or CRPE engine           }
{    - nJob is the PrintJob number(only for Engine errors)                     }
{    - Option is error variation: regular, formula, or paging (Engine only)    }
{    - ErrType is errVCL or errEngine                                          }
{    - ErrString contains the VCL error constant string (if applicable)        }
{------------------------------------------------------------------------------}
function TCrpe.GetErrorMsg(nJob: Word; Option: TCrErrorOption;
  ErrType: TCrError; ErrConst: string; ErrString: string): TCrErrorResult;
var
  hText       : hWnd;
  iText       : Smallint;
  pText       : PChar;
  sErrorText  : string;
  IgnoreError : TCrErrorResult;
  Job1,Job2   : Smallint;

  function VCLError(ErrorConstant: string; ErrorString: string): TCrErrorResult;
  begin
    Result := errRaise;
    {Get Error Number and Error String}
    FLastErrorNumber := GetErrorNum(ErrorConstant);
    FLastErrorString := GetErrorStr(ErrorConstant);
    if not IsStrEmpty(ErrorString) then
      FLastErrorString := FLastErrorString + ' - ' + ErrorString;
    {If in Design state, show dialog}
    if (csDesigning in ComponentState) then
    begin
      MessageDlg('Error: ' + IntToStr(FLastErrorNumber) +
        Chr(13) + Chr(10) + FLastErrorString, mtError, [mbOk], 0);
      Result := errIgnore;
    end
    else
    begin
      {Check the OnError event}
      IgnoreError := errRaise;
      if Assigned(FOnError) then
      begin
        FOnError(Self, FLastErrorNumber, FLastErrorString, IgnoreError);
        Result := IgnoreError;
        {errIgnore = Ignore Error and continue}
        {errAbort = Silent Exception: assume user dialog}
        {errRaise = Raise built-in Exception & dialog}
      end;
    end;
  end;

begin
  FLastErrorNumber := 0;
  FLastErrorString := '';
  Result := errRaise;

  {errIgnore = Ignore Error and continue}
  {errAbort = Silent Exception: assume user dialog}
  {errRaise = Raise built-in Exception & dialog}

  Job1 := nJob;

  case ErrType of
    {VCL Error}
    errVCL: Result := VCLError(ErrConst, ErrString);

    {Print Engine Error}
    errEngine:
      begin
        {If there was an error in CRDynamic, show it}
        if not IsStrEmpty(FCrpeEngine.CRDErrorStr) then
        begin
          sErrorText := Copy(FCrpeEngine.CRDErrorStr, 1, 2);
          if UpperCase(sErrorText) = 'PE' then
            VCLError(ECRPE_LOAD_DLL_FUNCTION, FCrpeEngine.CRDErrorStr)
          else
          begin
            if FCrpeEngine.CRDErrorStr = CRD_ERROR_LOADING then
              VCLError(ECRPE_LOAD_DLL, '')
            else if FCrpeEngine.CRDErrorStr = CRD_ERROR_FREEING then
              VCLError(ECRPE_FREE_DLL, '')
            else if FCrpeEngine.CRDErrorStr = CRD_ENGINE_NOT_LOADED then
              VCLError(ECRPE_NOT_LOADED, '')
            else
              VCLError(ECRPE_UNDEFINED, FCrpeEngine.CRDErrorStr);
          end;
        end
        {Regular Print Engine Error}
        else
        begin
          {Get ErrorNumber}
          FLastErrorNumber := FCrpeEngine.PEGetErrorCode(Job1);
          if FLastErrorNumber = -1 then
          begin
            {Failed to Retrieve Error from Print Engine}
            FLastErrorNumber := GetErrorNum(ECRPE_FAILED_GETTING_ERROR);
            FLastErrorString := GetErrorStr(ECRPE_FAILED_GETTING_ERROR);
          end
          else
          begin
            {Error Number is zero: undefined}
            if FLastErrorNumber = 0 then
            begin
              {Try using the Main Report Job Number}
              Job2 := PrintJobs(0);
              FLastErrorNumber := FCrpeEngine.PEGetErrorCode(Job2);
              if FLastErrorNumber <> 0 then
                Job1 := Job2;
            end;
            if FLastErrorNumber = 0 then
            begin
              {Try using zero as the Job Number}
              Job2 := 0;
              FLastErrorNumber := FCrpeEngine.PEGetErrorCode(Job2);
              if FLastErrorNumber <> 0 then
                Job1 := Job2;
            end;
            {If all fails, raise error 140: Undefined}
            if FLastErrorNumber = 0 then
            begin
              {Get Undefined Error Number and Error String}
              FLastErrorNumber := GetErrorNum(ECRPE_UNDEFINED);
              FLastErrorString := GetErrorStr(ECRPE_UNDEFINED);
              FLastErrorString := FLastErrorString + Chr(13) + Chr(10) + ErrString;
            end;

            {Error Number is valid}
            if FLastErrorNumber <> GetErrorNum(ECRPE_UNDEFINED) then
            begin
              {Get ErrorString}
              if not FCrpeEngine.PEGetErrorText(Job1, hText, iText) then
                {Failed to Retrieve Error String from Print Engine}
                FLastErrorString := GetErrorStr(ECRPE_FAILED_GETTING_ERROR)
              else
              begin
                pText := StrAlloc(iText);
                if not FCrpeEngine.PEGetHandleString(hText, pText, iText) then
                  FLastErrorString := GetErrorStr(ECRPE_FAILED_GETTING_ERROR)
                else
                begin
                  sErrorText := String(pText);
                  if IsStrEmpty(sErrorText) then
                    {Failed to Retrieve Error String from Print Engine}
                    FLastErrorString := GetErrorStr(ECRPE_FAILED_GETTING_ERROR)
                  else
                  begin
                    FLastErrorString := sErrorText + Chr(13) + Chr(10) + ErrString;
                    FLastErrorString := MakeCRLF(FLastErrorString);
                  end;
                end;
                StrDispose(pText);
              end;
            end;
          end;

          {Check Error Option Flag}
          case Option of
            errNoOption : {nothing};
            {Formula error}
            errFormula  :
              begin
                if FLastErrorNumber = 515 then
                  Result := errIgnore;
              end;
            {Paging error: trap a ShowNext or ShowPrevious page
             error when on the last or first page}
            errPaging   :
              begin
                if ((FLastErrorNumber = 542) or (FLastErrorNumber = 543)) then
                  Result := errIgnore;
              end;
            {Export/Print Error: trap the Cancel error on Export dialog,
             PrintOptions dialog, PrintWindow/ExportWindow, VerifyDatabase}
            errCancelDialog :
              begin
                if (FLastErrorNumber = 545)       {Cancelled}
                or (FLastErrorNumber = 505)       {No destination}
                or (FLastErrorNumber = 524) then  {PrintJob busy}
                  Result := errIgnore;
              end;
            {SectionFormatFormulas/AreaFormatFormulas - trap the bad
             formula name error when trying to retrieve Formulas}
            errFormatFormulaName :
              begin
                if FLastErrorNumber = 510 then
                  Result := errIgnore;
              end;
            {ParamFields - trap the error when trying to clear current values
             on a linked Parameter}
            errLinkedParameter :
              begin
                if FLastErrorNumber = 656 then
                  Result := errIgnore;
              end;
            {ParamFields - trap the error when trying to get min/max values
             from a Date type Parameter}
            errMinMaxParameter :
              begin
                if FLastErrorNumber = 642 then
                  Result := errIgnore;
              end;
            errCRPEBugs :
              begin
                if FIgnoreKnownProblems = True then
                begin
                  if (FLastErrorNumber = 571) or   {Invalid ObjectFormat Name}
                     (FLastErrorNumber = 510) or   {Bad Formula Name}
                     (FLastErrorNumber = 999) or   {Not Implemented}
                     (FLastErrorNumber = 518) then {Bad Section}
                    Result := errIgnore;
                end;
              end;
          end;

          {If we are not to ignore the error, handle it...}
          if Result = errRaise then
          begin
            {In Design state, show dialog}
            if (csDesigning in ComponentState) then
            begin
              MessageDlg('Error: ' + IntToStr(FLastErrorNumber) +
                Chr(13) + Chr(10) + FLastErrorString, mtWarning, [mbOk], 0);
              Result := errIgnore;
            end
            {In Runtime state, check OnError event}
            else
            begin
              IgnoreError := errRaise;
              if Assigned(FOnError) then
              begin
                FOnError(Self, FLastErrorNumber, FLastErrorString, IgnoreError);
                Result := IgnoreError;
              end;
            end;
          end;
        end;
      end;
  end;
end; {GetErrorMsg}

{------------------------------------------------------------------------------}
{ GetObjectHandle                                                              }
{------------------------------------------------------------------------------}
function TCrpe.GetObjectHandle (SubObjectN: Smallint; ObjectType: TCrObjectType;
  FieldObjectType: TCrFieldObjectType): DWord;
var
  nSection        : integer;
  SectionCode     : Smallint;
  nObjects        : Smallint;
  nObject         : Smallint;
  hObject         : THandle;
  n1              : Smallint;
  objectInfo      : PEObjectInfo;
  fieldObjectInfo : PEFieldObjectInfo;
  slSectionsS     : TStringList;
  slSectionsN     : TStringList;
  int1            : LongInt;
begin
  Result := 0;
  if IsStrEmpty(FReportName) then
    Exit;
  if not OpenPrintJob then
    Exit;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;

  {Retrieve Section Codes}
  if not GetSectionCodes(FPrintJob, slSectionsN, slSectionsS, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        'GetObjectHandle <GetSectionCodes>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;

  n1 := 0;
  {Loop through the Sections}
  for nSection := 0 to (slSectionsS.Count - 1) do
  begin
    SectionCode := StrToInt(slSectionsN[nSection]);
    nObjects := FCrpeEngine.PEGetNObjectsInSection(FPrintJob, SectionCode);
    if nObjects = -1 then
    begin
      slSectionsN.Free;
      slSectionsS.Free;
      case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
          'GetObjectHandle <PEGetNObjectsInSection>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
    for nObject := 0 to (nObjects - 1) do
    begin
      hObject := FCrpeEngine.PEGetNthObjectInSection(FPrintJob, SectionCode, nObject);
      if hObject = 0 then
      begin
        slSectionsN.Free;
        slSectionsS.Free;
        case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
            'GetObjectHandle <PEGetObjectInfo>') of
          errIgnore : Continue;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
        end;
      end;
      if not FCrpeEngine.PEGetObjectInfo(FPrintJob, hObject, objectInfo) then
      begin
        case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
            'GetObjectHandle <PEGetObjectInfo>') of
          errIgnore : Continue;
          errAbort  :
            begin
              slSectionsN.Free;
              slSectionsS.Free;
              Abort;
            end;
          errRaise  :
            begin
              slSectionsN.Free;
              slSectionsS.Free;
              raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
            end;
        end;
      end;
      int1 := objectInfo.objectType;
      if int1 = Ord(ObjectType) then
      begin
        if ObjectType = otField then
        begin
          if not FCrpeEngine.PEGetFieldObjectInfo(FPrintJob, hObject, fieldObjectInfo) then
          begin
            case GetErrorMsg(FPrintJob,errFormula,errEngine,'',
                'GetObjectHandle <PEGetFieldObjectInfo>') of
              errIgnore : Continue;
              errAbort  :
                begin
                  slSectionsN.Free;
                  slSectionsS.Free;
                  Abort;
                end;
              errRaise  :
                begin
                  slSectionsN.Free;
                  slSectionsS.Free;
                  raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
                end;
            end;
          end;
          if Ord(FieldObjectType) = fieldObjectInfo.fieldType then
          begin
            if n1 = SubObjectN then
            begin
              Result := hObject;
              slSectionsN.Free;
              slSectionsS.Free;
              Exit;
            end;
            Inc(n1);
          end;
        end
        else
        begin
          if n1 = SubObjectN then
          begin
            Result := hObject;
            slSectionsN.Free;
            slSectionsS.Free;
            Exit;
          end;
          Inc(n1);
        end;
      end;
    end;
  end;
  slSectionsN.Free;
  slSectionsS.Free;
end;

{------------------------------------------------------------------------------}
{ GetFieldObjectHandle                                                         }
{------------------------------------------------------------------------------}
function TCrpe.GetFieldObjectHandle (FieldName: string;
  FieldObjectType: TCrFieldObjectType; var Index: integer): DWord;
var
  nSection        : integer;
  SectionCode     : Smallint;
  nObjects        : Smallint;
  nObject         : Smallint;
  hObject         : THandle;
  objectInfo      : PEObjectInfo;
  fieldObjectInfo : PEFieldObjectInfo;
  slSectionsN     : TStringList;
  slSectionsS     : TStringList;
begin
  Result := 0;
  if IsStrEmpty(FReportName) then
    Exit;
  if not OpenPrintJob then
    Exit;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;

  {Retrieve Section Codes}
  if not GetSectionCodes(FPrintJob, slSectionsN, slSectionsS, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        'GetFieldObjectHandle <GetSectionCodes>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;

  Index := 0;
  {Loop through the Sections}
  for nSection := 0 to (slSectionsS.Count - 1) do
  begin
    SectionCode := StrToInt(slSectionsN[nSection]);
    nObjects := FCrpeEngine.PEGetNObjectsInSection(FPrintJob, SectionCode);
    if nObjects = -1 then
    begin
      slSectionsN.Free;
      slSectionsS.Free;
      case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
          'GetObjectHandle <PEGetNObjectsInSection>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
    {Loop through Objects in Section}
    for nObject := 0 to (nObjects - 1) do
    begin
      hObject := FCrpeEngine.PEGetNthObjectInSection(FPrintJob, SectionCode, nObject);
      if hObject = 0 then
      begin
        case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
            'GetObjectHandle <PEGetObjectInfo>') of
          errIgnore : Continue;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
        end;
      end;
      {Get ObjectInfo}
      if not FCrpeEngine.PEGetObjectInfo(FPrintJob, hObject, objectInfo) then
      begin
        case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
            'GetObjectHandle <PEGetObjectInfo>') of
          errIgnore : Continue;
          errAbort  :
            begin
              slSectionsN.Free;
              slSectionsS.Free;
              Abort;
            end;
          errRaise  :
            begin
              slSectionsN.Free;
              slSectionsS.Free;
              raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
            end;
        end;
      end;
      {Check Field Objects}
      if objectInfo.objectType = PE_OI_FIELDOBJECT then
      begin
        {If the Formula field has an error, this call will fail...}
        if not FCrpeEngine.PEGetFieldObjectInfo(FPrintJob, hObject, fieldObjectInfo) then
        begin
          case GetErrorMsg(FPrintJob,errFormula,errEngine,'',
              'GetObjectHandle <PEGetFieldObjectInfo>') of
            errIgnore : Continue;
            errAbort  :
              begin
                slSectionsN.Free;
                slSectionsS.Free;
                Abort;
              end;
            errRaise  :
              begin
                slSectionsN.Free;
                slSectionsS.Free;
                raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
              end;
          end;
        end;
        {Is it Formula, Expression, or Parameter?}
        if fieldObjectInfo.fieldType = Ord(FieldObjectType) then
        begin
          if StrIComp(fieldObjectInfo.fieldName, PChar(FieldName)) = 0 then
          begin
            Result := hObject;
            slSectionsN.Free;
            slSectionsS.Free;
            Exit;
          end;
          Inc(Index);
        end;
      end;
    end;
  end;
  Index := 0;
  slSectionsN.Free;
  slSectionsS.Free;
end;

{------------------------------------------------------------------------------}
{ GetNObjects                                                                  }
{------------------------------------------------------------------------------}
function TCrpe.GetNObjects (ObjectType: TCrObjectType;
  ObjectFieldType: TCrFieldObjectType): Integer;
var
  nSection        : integer;
  SectionCode     : integer;
  nObjects        : Smallint;
  nObject         : Smallint;
  hObject         : THandle;
  objectInfo      : PEObjectInfo;
  fieldObjectInfo : PEFieldObjectInfo;
  n1              : Smallint;
  int1            : LongInt;
  slSectionsN     : TStringList;
  slSectionsS     : TStringList;
begin
  Result := -1;
  if IsStrEmpty(FReportName) then
    Exit;
  if not OpenPrintJob then
    Exit;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;

  {Retrieve Section Codes}
  if not GetSectionCodes(FPrintJob, slSectionsN, slSectionsS, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        'GetNObjects <GetSectionCodes>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;

  n1 := 0;
  {Loop through the Sections}
  for nSection := 0 to (slSectionsS.Count - 1) do
  begin
    SectionCode := StrToInt(slSectionsN[nSection]);
    nObjects := FCrpeEngine.PEGetNObjectsInSection(FPrintJob, SectionCode);
    if nObjects = -1 then
    begin
      case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
          'GetNObjects <PEGetNObjectsInSection>') of
        errIgnore : Continue;
        errAbort  :
          begin
            slSectionsN.Free;
            slSectionsS.Free;
            Abort;
          end;
        errRaise  :
          begin
            slSectionsN.Free;
            slSectionsS.Free;
            raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
          end;
      end;
    end;
    for nObject := 0 to (nObjects - 1) do
    begin
      hObject := FCrpeEngine.PEGetNthObjectInSection(FPrintJob, SectionCode, nObject);
      if hObject = 0 then
      begin
        case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
            'GetNObjects <PEGetNthObjectInSection>') of
          errIgnore : Continue;
          errAbort  :
            begin
              slSectionsN.Free;
              slSectionsS.Free;
              Abort;
            end;
          errRaise  :
            begin
              slSectionsN.Free;
              slSectionsS.Free;
              raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
            end;
        end;
      end;
      if not FCrpeEngine.PEGetObjectInfo(FPrintJob, hObject, objectInfo) then
      begin
        case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
            'GetNObjects <PEGetObjectInfo>') of
          errIgnore : Continue;
          errAbort  :
            begin
              slSectionsN.Free;
              slSectionsS.Free;
              Abort;
            end;
          errRaise  :
            begin
              slSectionsN.Free;
              slSectionsS.Free;
              raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
            end;
        end;
      end;
      int1 := objectInfo.objectType;
      if int1 = Ord(ObjectType) then
      begin
        if ObjectType = otField then
        begin
          if not FCrpeEngine.PEGetFieldObjectInfo(FPrintJob, hObject, fieldObjectInfo) then
          begin
            case GetErrorMsg(FPrintJob,errFormula,errEngine,'',
                'GetNObjects <PEGetFieldObjectInfo>') of
              errIgnore : Continue;
              errAbort  :
                begin
                  slSectionsN.Free;
                  slSectionsS.Free;
                  Abort;
                end;
              errRaise  :
                begin
                  slSectionsN.Free;
                  slSectionsS.Free;
                  raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
                end;
            end;
          end;
          if Ord(ObjectFieldType) = fieldObjectInfo.fieldType then
            Inc(n1);
        end
        else
          Inc(n1);
      end;
    end;
  end;
  Result := n1;
  slSectionsS.Free;
  slSectionsN.Free;
end;

{------------------------------------------------------------------------------}
{ GetFieldTypeFromName                                                         }
{------------------------------------------------------------------------------}
function TCrpe.GetFieldTypeFromName (FieldName: string): TCrFieldValueType;
var
  nSection        : integer;
  SectionCode     : Smallint;
  nObjects        : Smallint;
  nObject         : Smallint;
  hObject         : THandle;
  objectInfo      : PEObjectInfo;
  fieldObjectInfo : PEFieldObjectInfo;
  int1            : LongInt;
  nGlobalField    : integer;
  i,j,k           : integer;
  x1,x2           : integer;
  slSectionsS     : TStringList;
  slSectionsN     : TStringList;
begin
  Result := fvUnknown;
  if IsStrEmpty(FReportName) then
    Exit;
  if not OpenPrintJob then
    Exit;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;
  {Retrieve Section Codes}
  if not GetSectionCodes(FPrintJob, slSectionsN, slSectionsS, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        'GetFieldTypeFromName <GetSectionCodes>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;

  {Loop through the Sections}
  for nSection := 0 to (slSectionsS.Count - 1) do
  begin
    SectionCode := StrToInt(slSectionsN[nSection]);
    nObjects := FCrpeEngine.PEGetNObjectsInSection(FPrintJob, SectionCode);
    if nObjects = -1 then
    begin
      slSectionsN.Free;
      slSectionsS.Free;
      case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
          'GetFieldTypeFromName <PEGetNObjectsInSection>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
    for nObject := 0 to (nObjects - 1) do
    begin
      hObject := FCrpeEngine.PEGetNthObjectInSection(FPrintJob, SectionCode, nObject);
      if hObject = 0 then
      begin
        case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
            'GetFieldTypeFromName <PEGetObjectInfo>') of
          errIgnore : Continue;
          errAbort  :
            begin
              slSectionsN.Free;
              slSectionsS.Free;
              Abort;
            end;
          errRaise  :
            begin
              slSectionsN.Free;
              slSectionsS.Free;
              raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
            end;
        end;
      end;
      if not FCrpeEngine.PEGetObjectInfo(FPrintJob, hObject, objectInfo) then
      begin
        case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
            'GetFieldTypeFromName <PEGetObjectInfo>') of
          errIgnore : Continue;
          errAbort  :
            begin
              slSectionsN.Free;
              slSectionsS.Free;
              Abort;
            end;
          errRaise  :
            begin
              slSectionsN.Free;
              slSectionsS.Free;
              raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
            end;
        end;
      end;
      int1 := Ord(otField);
      if objectInfo.objectType = int1 then
      begin
        if not FCrpeEngine.PEGetFieldObjectInfo(FPrintJob, hObject, fieldObjectInfo) then
        begin
          case GetErrorMsg(FPrintJob,errFormula,errEngine,'',
              'GetFieldTypeFromName <PEGetFieldObjectInfo>') of
            errIgnore : Continue;
            errAbort  :
              begin
                slSectionsN.Free;
                slSectionsS.Free;
                Abort;
              end;
            errRaise  :
              begin
                slSectionsN.Free;
                slSectionsS.Free;
                raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
              end;
          end;
        end;
        if CompareStr(FieldName, fieldObjectInfo.fieldName) = 0 then
        begin
          if fieldObjectInfo.fieldType = PE_FVT_UNKNOWNFIELD then
            Result := fvUnknown
          else
            Result := TCrFieldValueType(fieldObjectInfo.fieldType);
          slSectionsS.Free;
          slSectionsN.Free;
          Exit;
        end;
      end;
    end;
  end;

  {Object search failed, try Table.Fields: field might not be on the Report}
  nGlobalField := FTables.FieldNames.IndexOf(FieldName);
  k := 0;
  x1 := FTables.ItemIndex;
  x2 := FTables.FItem.FFields.ItemIndex;
  for i := 0 to FTables.Count-1 do
  begin
    for j := 0 to FTables[i].FFields.Count-1 do
    begin
      k := k + FTables.FItem.FFields.Count;
      if k > nGlobalField then
      begin
        k := k - nGlobalField;
        k := FTables.FItem.FFields.Count - k;
        Result := FTables.FItem.FFields[k].FFieldType;
        {Reset indexes}
        FTables[x1].FFields[x2];
        slSectionsS.Free;
        slSectionsN.Free;
        Exit;
      end;
    end;
  end;
  {Reset indexes}
  FTables[x1].FFields[x2];
  {Check Special Fields also}
  if FieldName = 'PrintDate' then
    Result := fvDate
  else if FieldName = 'PrintTime' then
    Result := fvTime
  else if FieldName = 'ModificationDate' then
    Result := fvDate
  else if FieldName = 'ModificationTime' then
    Result := fvTime
  else if FieldName = 'DataDate' then
    Result := fvDate
  else if FieldName = 'DataTime' then
    Result := fvTime
  else if FieldName = 'RecordNumber' then
    Result := fvInt32u
  else if FieldName = 'PageNumber' then
    Result := fvInt32u
  else if FieldName = 'GroupNumber' then
    Result := fvInt32u
  else if FieldName = 'TotalPageCount' then
    Result := fvInt32u
  else if FieldName = 'ReportTitle' then
    Result := fvString
  else if FieldName = 'ReportComments' then
    Result := fvString
  else if FieldName = 'RecordSelection' then
    Result := fvString
  else if FieldName = 'GroupSelection' then
    Result := fvString
  else if FieldName = 'FileName' then
    Result := fvString
  else if FieldName = 'FileAuthor' then
    Result := fvString
  else if FieldName = 'FileCreationDate' then
    Result := fvDate
  else if FieldName = 'PageNofM' then
    Result := fvString;
  slSectionsS.Free;
  slSectionsN.Free;
end;

{------------------------------------------------------------------------------}
{ PrintJobs                                                                    }
{------------------------------------------------------------------------------}
function TCrpe.PrintJobs (ReportNumber: integer): Smallint;
begin
  Result := 0;
  if (ReportNumber < FPrintJobs.Count) then
  begin
    if IsNumeric(FPrintJobs[ReportNumber]) then
      Result := StrToInt(FPrintJobs[ReportNumber]);
  end;
end;

{------------------------------------------------------------------------------}
{ StatusIsGo                                                                   }
{------------------------------------------------------------------------------}
function TCrpe.StatusIsGo (nIndex: integer): Boolean;
begin
  Result := False;
  if (csLoading in ComponentState) then Exit;
  if IsStrEmpty(FReportName) or (not FileExists(FReportName)) then Exit;
  if nIndex < 0 then Exit;
  if not OpenPrintJob then Exit;
  Result := True;
end;

{------------------------------------------------------------------------------}
{ SectionCodeToStringEx                                                        }
{------------------------------------------------------------------------------}
function TCrpe.SectionCodeToStringEx (SectionCode: Smallint; bArea: boolean): string;
var
  s     : string;
  aCode : Smallint;
  i     : Smallint;
begin
  if bArea then
    Result := AreaCodeToStr(SectionCode)
  else
  begin
    s := SectionCodeToStr(SectionCode);
    Result := s;
    if not IsStrEmpty(s) then
    begin
      if (s[Length(s)] = 'a') and (Pos('aa', s) = 0) then
      begin
        aCode := PE_AREA_CODE(PE_SECTION_TYPE(SectionCode), PE_GROUP_N(SectionCode));
        i := FCrpeEngine.PEGetNSectionsInArea(FPrintJob, aCode);
        if i = 1 then
          Result := Copy(s, 1, Length(s)-1);
      end;
    end;
  end;
end;

{------------------------------------------------------------------------------}
{ SendOutput                                                                   }
{------------------------------------------------------------------------------}
function TCrpe.SendOutput : Boolean;
var
  nLeft, nTop,
  nWidth, nHeight : DWord;
  xHandle         : hWnd;
begin
  Result := False;
  if IsStrEmpty(FReportName) then
    Exit;
  if not OpenPrintJob then
    Exit;

  case FOutput of
    toWindow :
      begin
        {Left}
        if FWindowSize.FLeft = -1 then
          nLeft := CW_USEDEFAULT
        else
          nLeft := FWindowSize.FLeft;
        {Top}
        if FWindowSize.FTop = -1 then
          nTop := CW_USEDEFAULT
        else
          nTop := FWindowSize.FTop;
        {Width}
        if FWindowSize.FWidth = -1 then
          nWidth := CW_USEDEFAULT
        else
          nWidth := FWindowSize.FWidth;
        {Height}
        if FWindowSize.FHeight = -1 then
          nHeight := CW_USEDEFAULT
        else
          nHeight := FWindowSize.FHeight;

        {WindowHandle}
        GetWindowParent;
        if FWindowParent = nil then
          xHandle := 0
        else
        begin
          xHandle := FWindowParent.Handle;

          {Check MDIChild}
          if (FWindowParent is TForm) then
          begin
            if TForm(FWindowParent).FormStyle = fsMDIForm then
            begin
              FWindowStyle.FMDIForm := TForm.Create(Self);
              FWindowStyle.FMDIForm.FormStyle := fsMDIChild;
              FWindowStyle.FMDIForm.Caption := FWindowStyle.FTitle;
              FWindowStyle.FMDIForm.OnResize := FWindowStyle.OnMDIResize;
              FWindowStyle.FMDIForm.OnClose := FWindowStyle.OnMDIClose;
              xHandle := FWindowStyle.FMDIForm.Handle;
            end;
          end;
        end;
        {Send Output}
        if not FCrpeEngine.PEOutPutToWindow(FPrintJob, PChar(FWindowStyle.FTitle),
          nLeft, nTop, nWidth, nHeight, PreviewWindowStyle, xHandle) then
        begin
          case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
              'SendOutput <PEOutputToWindow>') of
            errIgnore : Exit;
            errAbort  : Abort;
            errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
          end;
        end;
        Result := True;
      end; {toWindow}

    toPrinter:
      begin
        if not FCrpeEngine.PEOutPutToPrinter(FPrintJob, FPrintOptions.Copies) then
        begin
          case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
              'SendOutput <PEOutputToPrinter>') of
            errIgnore : Exit;
            errAbort  : Abort;
            errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
          end;
        end;
        Result := True;
      end; {toPrinter}

    toExport:
      begin
        if FExportOptions.Send then
          Result := True;
      end;
  end; {Case Output}
end;

{------------------------------------------------------------------------------}
{ PreviewWindowStyle                                                           }
{------------------------------------------------------------------------------}
function TCrpe.PreviewWindowStyle: Integer;
var
  xBorderStyle : TCrFormBorderStyle;
begin
  xBorderStyle := FWindowStyle.FBorderStyle;
  Result := WS_VISIBLE;  {Window is always visible anyway?}
  {Check WindowParent}
  if (FWindowParent <> nil) then
  begin
    Result := Result or (WS_CLIPSIBLINGS or WS_CLIPCHILDREN);
    if (FWindowParent is TForm) then
    begin
      if TForm(FWindowParent).FormStyle = fsMDIForm then
        xBorderStyle := bsNone;
    end;
  end;

  {Check BorderStyle}
  case xBorderStyle of
    {No Sizeable Frame, No Buttons, No SystemMenu, No TitleBar}
    bsNone:
      begin
        Result := Result and (not WS_SYSMENU);
        Result := Result and (not WS_MAXIMIZEBOX);
        Result := Result and (not WS_MINIMIZEBOX);
      end;
    {No Sizeable Frame}
    bsSingle:
      Result := Result or (WS_CAPTION or WS_BORDER);
    {Sizeable Frame}
    bsSizeable:
      Result := Result or (WS_CAPTION or WS_THICKFRAME);
    {No Sizeable Frame, No Min/Max buttons}
    bsDialog:
      begin
        Result := Result or (WS_CAPTION or WS_DLGFRAME);
        Result := Result or WS_SYSMENU;
        Result := Result and (not WS_MAXIMIZEBOX);
        Result := Result and (not WS_MINIMIZEBOX);
      end;
  end;

  {Single and Sizeable can be minimized/maximized or have these control buttons}
  if xBorderStyle in [bsSingle, bsSizeable] then
  begin
    if (FWindowStyle.FSystemMenu = True) then
    begin
      if (FWindowStyle.FMinButton = True) then
        Result := Result or WS_MINIMIZEBOX;
      if (FWindowStyle.FMaxButton = True) then
        Result := Result or WS_MAXIMIZEBOX;
    end;
    if FWindowState = wsMinimized then
      Result := Result or WS_MINIMIZE
    else if FWindowState = wsMaximized then
      Result := Result or WS_MAXIMIZE;
  end
  else
    FWindowState := wsNormal;

  {System Menu}
  if xBorderStyle <> bsNone then
  begin
    if FWindowStyle.FSystemMenu = True then
      Result := Result or WS_SYSMENU;
  end;

  {Disabled}
  if FWindowStyle.FDisabled = True then
    Result := Result or WS_DISABLED;
end;

{------------------------------------------------------------------------------}
{ GetWindowState                                                               }
{------------------------------------------------------------------------------}
function TCrpe.GetWindowState : TWindowState;
begin
  if ReportWindowHandle > 0 then
  begin
    if IsIconic(ReportWindowHandle) then
      FWindowState := wsMinimized
    else if IsZoomed(ReportWindowHandle) then
      FWindowState := wsMaximized
    else
      FWindowState := wsNormal;
  end;
  Result := FWindowState;
end;
{------------------------------------------------------------------------------}
{ SetWindowState                                                               }
{------------------------------------------------------------------------------}
procedure TCrpe.SetWindowState(const Value : TWindowState);
const
  ShowCommands: array[TWindowState] of Integer =
    (SW_SHOWNORMAL, SW_MINIMIZE, SW_SHOWMAXIMIZED);
begin
  FWindowState := Value;
  if ReportWindowHandle > 0 then
    Windows.ShowWindow(ReportWindowHandle, ShowCommands[Value]);
end;

{------------------------------------------------------------------------------}
{ Execute                                                                      }
{------------------------------------------------------------------------------}
function TCrpe.Execute: Boolean;
var
  IsCanceled  : Boolean;
  EventInfo   : PEEnableEventInfo;
  nIndex      : integer;
  nSub        : integer;
  nRpt        : integer;
  RunMain     : Boolean;
  sAppName    : string;
  sFileName   : string;

  {Local procedure WindowCallback}
  function WindowCallback(eventID: Smallint;
    pEvent: pointer; Cr: TCrpe): LongBool stdcall;
  var
    Cancel           : Boolean;
    GeneralInfo      : PEGeneralPrintWindowEventInfo;
    ZoomInfo         : PEZoomLevelChangingEventInfo;
    GroupTreeInfo    : PEGroupTreeButtonClickedEventInfo;
    CloseButtonInfo  : PECloseButtonClickedEventInfo;
    SearchButtonInfo : PESearchButtonClickedEventInfo;
    ShowGroupInfo    : PEShowGroupEventInfo;
    DrillGroupInfo   : PEDrillOnGroupEventInfo;
    DrillDetailInfo  : PEDrillOnDetailEventInfo;
    ReadingInfo      : PEReadingRecordsEventInfo;
    StartInfo        : PEStartEventInfo;
    StopInfo         : PEStopEventInfo;
    MouseClickInfo   : PEMouseClickEventInfo;
    MouseInfo        : TCrMouseInfo;
    FieldType        : TCrParamFieldType;
    sTmp             : string;
    sCode            : string;
    bTmp1, bTmp2     : Boolean;
    Destination      : TCrStartEventDestination;
    JobStatus        : TCrStopEventJobStatus;
    slGroups         : TStringList;
    slFieldNames     : TStringList;
    slFieldValues    : TStringList;
    DrillType        : TCrDrillDownType;
    FieldValueInfo   : PEFieldValueInfo;
    HyperLinkInfo    : PEHyperlinkEventInfo;
    HyperLinkText    : string;
    LaunchAnalysis   : PELaunchSeagateAnalysisEventInfo;
    FilePath         : string;
    cnt1             : integer;
  begin
    Result := True;
    Cancel := False;
    Cr.FCrpeState := crsInit;
    case eventID of
      PE_CLOSE_PRINT_WINDOW_EVENT :
        begin
          if Assigned(Cr.FwOnCloseWindow) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
              Cr.FwOnCloseWindow(GeneralInfo.windowHandle, Cancel);
            Result := not Cancel;
          end;
        end;
      PE_ACTIVATE_PRINT_WINDOW_EVENT :
        begin
          if Assigned(Cr.FwOnActivateWindow) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnActivateWindow(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_DEACTIVATE_PRINT_WINDOW_EVENT :
        begin
          if Assigned(Cr.FwOnDeActivateWindow) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnDeActivateWindow(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_PRINT_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnPrintBtnClick) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnPrintBtnClick(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_EXPORT_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnExportBtnClick) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnExportBtnClick(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_ZOOM_CONTROL_SELECTED_EVENT :
        begin
          if Assigned(Cr.FwOnZoomLevelChange) then
          begin
            ZoomInfo := PEZoomLevelChangingEventInfo(pEvent^);
            if (ZoomInfo.structSize = SizeOf(PEZoomLevelChangingEventInfo)) then
            begin
              Cr.FwOnZoomLevelChange(ZoomInfo.windowHandle,
                ZoomInfo.zoomLevel, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_FIRST_PAGE_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnFirstPageBtnClick) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnFirstPageBtnClick(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_PREVIOUS_PAGE_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnPreviousPageBtnClick) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnPreviousPageBtnClick(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_NEXT_PAGE_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnNextPageBtnClick) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnNextPageBtnClick(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_LAST_PAGE_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnLastPageBtnClick) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnLastPageBtnClick(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_CANCEL_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnCancelBtnClick) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnCancelBtnClick(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_CLOSE_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnCloseBtnClick) then
          begin
            CloseButtonInfo := PECloseButtonClickedEventInfo(pEvent^);
            if (CloseButtonInfo.structSize = SizeOf(PECloseButtonClickedEventInfo)) then
            begin
              Cr.FwOnCloseBtnClick(CloseButtonInfo.windowHandle,
                CloseButtonInfo.viewIndex, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_SEARCH_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnSearchBtnClick) then
          begin
            SearchButtonInfo := PESearchButtonClickedEventInfo(pEvent^);
            if SearchButtonInfo.structSize = SizeOf(PESearchButtonClickedEventInfo) then
            begin
              sTmp := WideCharToString((SearchButtonInfo.searchString));
              Cr.FwOnSearchBtnClick(SearchButtonInfo.windowHandle, sTmp, Cancel);
              if not Cancel then
                StringToWideChar(sTmp, SearchButtonInfo.searchString, 128);
              Result := not Cancel;
            end;
          end;
        end;
      PE_GROUPTREE_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnGroupTreeBtnClick) then
          begin
            GroupTreeInfo := PEGroupTreeButtonClickedEventInfo(pEvent^);
            if (GroupTreeInfo.structSize = SizeOf(PEGroupTreeButtonClickedEventInfo)) then
            begin
              bTmp1 := False;
              case GroupTreeInfo.visible of
                0: bTmp1 := False;
                1: bTmp1 := True;
              end;
              Cr.FwOnGroupTreeBtnClick(GroupTreeInfo.windowHandle,
                bTmp1, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_PRINT_SETUP_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnPrintSetupBtnClick) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnPrintSetupBtnClick(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_REFRESH_BUTTON_CLICKED_EVENT :
        begin
          if Assigned(Cr.FwOnRefreshBtnClick) then
          begin
            GeneralInfo := PEGeneralPrintWindowEventInfo(pEvent^);
            if (GeneralInfo.structSize = SizeOf(PEGeneralPrintWindowEventInfo)) then
            begin
              Cr.FwOnRefreshBtnClick(GeneralInfo.windowHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_SHOW_GROUP_EVENT :
        begin
          if Assigned(Cr.FwOnShowGroup) then
          begin
            ShowGroupInfo := PEShowGroupEventInfo(pEvent^);
            if (ShowGroupInfo.structSize = SizeOf(PEShowGroupEventInfo)) then
            begin
              slGroups := TStringList.Create;
              {If Range Checking is on, turn it off}
              {$IFOPT R+}
                {$DEFINE CKRANGE}
                {$R-}
              {$ENDIF}
              for cnt1 := 0 to ShowGroupInfo.groupLevel - 1 do
              begin
                slGroups.Add(WideCharToString(ShowGroupInfo.groupList^[cnt1]));
              end;
              {$IFDEF CKRANGE}
                {$UNDEF CKRANGE}
                {$R+}
              {$ENDIF}
              Cr.FwOnShowGroup(ShowGroupInfo.windowHandle, ShowGroupInfo.groupLevel,
                slGroups, Cancel);
              slGroups.Free;
              Result := not Cancel;
            end;
          end;
        end;
      PE_DRILL_ON_GROUP_EVENT :
        begin
          if Assigned(Cr.FwOnDrillGroup) then
          begin
            DrillGroupInfo := PEDrillOnGroupEventInfo(pEvent^);
            if (DrillGroupInfo.structSize = SizeOf(PEDrillOnGroupEventInfo)) then
            begin
              slGroups := TStringList.Create;
              {If Range Checking is on, turn it off}
              {$IFOPT R+}
                {$DEFINE CKRANGE}
                {$R-}
              {$ENDIF}
              for cnt1 := 0 to DrillGroupInfo.groupLevel - 1 do
              begin
                slGroups.Add(WideCharToString(DrillGroupInfo.groupList^[cnt1]));
              end;
              {$IFDEF CKRANGE}
                {$UNDEF CKRANGE}
                {$R+}
              {$ENDIF}
              DrillType := TCrDrillDownType(DrillGroupInfo.drillType);
              Cr.FwOnDrillGroup(DrillGroupInfo.windowHandle,
                DrillGroupInfo.groupLevel, DrillType, slGroups, Cancel);
              slGroups.Free;
              Result := not Cancel;
            end;
          end;
        end;
      PE_DRILL_ON_DETAIL_EVENT :
        begin
          if Assigned(Cr.FwOnDrillDetail) then
          begin
            DrillDetailInfo := PEDrillOnDetailEventInfo(pEvent^);
            if (DrillDetailInfo.structSize = SizeOf(PEDrillOnDetailEventInfo)) then
            begin
              slFieldNames := TStringList.Create;
              slFieldValues := TStringList.Create;
              {If Range Checking is on, turn it off}
              {$IFOPT R+}
                {$DEFINE CKRANGE}
                {$R-}
              {$ENDIF}
              if DrillDetailInfo.selectedFieldIndex <> -1 then
              begin
                for cnt1 := 0 to (DrillDetailInfo.nFieldValue - 1) do
                begin
                  FieldValueInfo := (DrillDetailInfo.fieldValueList^[cnt1])^;
                  if FieldValueInfo.structSize = SizeOf(PEFieldValueInfo) then
                  begin
                    slFieldNames.Add(WideCharToString(FieldValueInfo.fieldName));
                    with FieldValueInfo.fieldValue do
                    begin
                      case valueType of
                        PE_VI_NUMBER   : begin
                                           Str(viNumber:0:2, sTmp);
                                           slFieldValues.Add(sTmp);
                                         end;
                        PE_VI_CURRENCY : begin
                                           Str(viCurrency:0:2, sTmp);
                                           slFieldValues.Add(sTmp);
                                         end;
                        PE_VI_BOOLEAN  : slFieldValues.Add(CrBooleanToStr(viBoolean, False));
                        PE_VI_DATE     : slFieldValues.Add(IntToStr(viDate[0]) + ',' +
                                           IntToStr(viDate[1]) + ',' + IntToStr(viDate[2]));
                        PE_VI_STRING   : slFieldValues.Add(viString);
                        PE_VI_DATETIME : slFieldValues.Add(IntToStr(viDateTime[0]) + ',' +
                                           IntToStr(viDateTime[1]) + ',' + IntToStr(viDateTime[2]) + ' ' +
                                           IntToStr(viDateTime[3]) + ':' + IntToStr(viDateTime[4]) + ':' +
                                           IntToStr(viDateTime[5]));
                        PE_VI_TIME     : slFieldValues.Add(IntToStr(viTime[0]) + ':' +
                                           IntToStr(viTime[1]) + ':' + IntToStr(viTime[2]));
                        PE_VI_INTEGER  : slFieldValues.Add(IntToStr(viInteger));
                        PE_VI_COLOR    : slFieldValues.Add(IntToStr(viColor));
                        PE_VI_CHAR     : slFieldValues.Add(viC);
                        PE_VI_LONG     : slFieldValues.Add(IntToStr(viLong));
                        PE_VI_NOVALUE  : slFieldValues.Add('');
                      end;
                    end;
                  end;
                end;
              end;
              {$IFDEF CKRANGE}
                {$UNDEF CKRANGE}
                {$R+}
              {$ENDIF}
              Cr.FwOnDrillDetail(DrillDetailInfo.windowHandle,
                DrillDetailInfo.selectedFieldIndex, DrillDetailInfo.nFieldValue,
                slFieldNames, slFieldValues, Cancel);
              slFieldNames.Free;
              slFieldValues.Free;
              Result := not Cancel;
            end;
          end;
        end;
      PE_READING_RECORDS_EVENT :
        begin
          if Assigned(Cr.FwOnReadingRecords) then
          begin
            ReadingInfo := PEReadingRecordsEventInfo(pEvent^);
            if (ReadingInfo.structSize = SizeOf(PEReadingRecordsEventInfo)) then
            begin
              bTmp1 := False;
              bTmp2 := False;
              case ReadingInfo.cancelled of
                0: bTmp1 := False;
                1: bTmp1 := True;
              end;
              case ReadingInfo.done of
                0: bTmp2 := False;
                1: bTmp2 := True;
              end;
              Cr.FwOnReadingRecords(bTmp1, ReadingInfo.recordsRead,
                ReadingInfo.recordsSelected, bTmp2, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_START_EVENT :
        begin
          if Assigned(Cr.FwOnStartEvent) then
          begin
            StartInfo := PEStartEventInfo(pEvent^);
            if (StartInfo.structSize = SizeOf(PEStartEventInfo)) then
            begin
              Destination := TCrStartEventDestination(StartInfo.destination);
              Cr.FwOnStartEvent(Destination, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_STOP_EVENT :
        begin
          if Assigned(Cr.FwOnStopEvent) then
          begin
            StopInfo := PEStopEventInfo(pEvent^);
            if (StopInfo.structSize = SizeOf(PEStopEventInfo)) then
            begin
              Destination := TCrStartEventDestination(StopInfo.destination);
              JobStatus := TCrStopEventJobStatus(StopInfo.jobStatus);
              Cr.FwOnStopEvent(Destination, JobStatus, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_RIGHT_CLICK_EVENT,
      PE_LEFT_CLICK_EVENT,
      PE_MIDDLE_CLICK_EVENT:
        begin
          if Assigned(Cr.FwOnMouseClick) then
          begin
            MouseClickInfo := PEMouseClickEventInfo(pEvent^);
            if (MouseClickInfo.structSize = SizeOf(PEMouseClickEventInfo)) then
            begin
              MouseInfo.Action := TCrMouseClickAction(MouseClickInfo.clickAction);
              if (MouseClickInfo.clickFlags and PE_CF_NONE) = PE_CF_NONE then
              begin
                MouseInfo.ShiftKey := False;
                MouseInfo.ControlKey := False;
                MouseInfo.Button := mcNone;
              end;
              if (MouseClickInfo.clickFlags and PE_CF_SHIFTKEY) = PE_CF_SHIFTKEY then
                MouseInfo.ShiftKey := True;
              if (MouseClickInfo.clickFlags and PE_CF_CONTROLKEY) = PE_CF_CONTROLKEY then
                MouseInfo.ControlKey := True;
              if (MouseClickInfo.clickFlags and PE_CF_LBUTTON) = PE_CF_LBUTTON then
                MouseInfo.Button := mcLeft;
              if (MouseClickInfo.clickFlags and PE_CF_RBUTTON) = PE_CF_RBUTTON then
                MouseInfo.Button := mcRight;
              if (MouseClickInfo.clickFlags and PE_CF_MBUTTON) = PE_CF_MBUTTON then
                MouseInfo.Button := mcMiddle;
              MouseInfo.x := MouseClickInfo.xOffset;
              MouseInfo.y := MouseClickInfo.yOffset;
              sTmp := DrillValueInfoToStr(MouseClickInfo.fieldValue);
              if MouseClickInfo.fieldValue.valueType = PE_VI_NOVALUE then
                FieldType := pfNoValue
              else
                FieldType := TCrParamFieldType(MouseClickInfo.fieldValue.valueType);
              {Convert Section Code to String, 'GH1a', etc.}
              sCode := Cr.SectionCodeToStringEx(MouseClickInfo.sectionCode, False);
              {Do the OnMouseClick event}
              Cr.FwOnMouseClick(MouseClickInfo.windowHandle, MouseInfo,
                sTmp, FieldType, sCode, MouseClickInfo.objectHandle, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_DRILL_ON_HYPERLINK_EVENT:
        begin
          if Assigned(Cr.FwOnDrillHyperLink) then
          begin
            HyperLinkInfo := PEHyperlinkEventInfo(pEvent^);
            if (HyperLinkInfo.structSize = SizeOf(PEHyperlinkEventInfo)) then
            begin
              HyperLinkText := WideCharToString(HyperLinkInfo.hyperlinkText);
              Cr.FwOnDrillHyperLink(HyperLinkInfo.windowHandle, HyperLinkText, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
      PE_LAUNCH_SEAGATE_ANALYSIS_EVENT:
        begin
          if Assigned(Cr.FwOnLaunchSeagateAnalysis) then
          begin
            LaunchAnalysis := PELaunchSeagateAnalysisEventInfo(pEvent^);
            if (LaunchAnalysis.structSize = SizeOf(PELaunchSeagateAnalysisEventInfo)) then
            begin
              FilePath := WideCharToString(LaunchAnalysis.pathFile);
              Cr.FwOnLaunchSeagateAnalysis(LaunchAnalysis.windowHandle, FilePath, Cancel);
              Result := not Cancel;
            end;
          end;
        end;
    end; //CASE eventID
    Cr.FCrpeState := crsSetup;
  end;

{Main procedure: TCrpe.Execute}
begin
  Result := False;
  {Check the Init State}
  if (FCrpeState = crsInit) then
    Exit;

  {Check the PromptOnOverwrite property}
  if (FOutput = toExport) and
     (FExportOptions.FPromptOnOverwrite = True) and
     (FExportOptions.FFileType <> ODBCTable) and
     ((FExportOptions.FDestination = toFile) or (FExportOptions.FDestination = toApplication)) then
  begin
    if FileExists(FExportOptions.FFileName) then
    begin
      if MessageBox(0, 'Export FileName already exists.  Overwrite?', 'Export Warning',
      mb_OKCancel + mb_DefButton1 + mb_IconQuestion + mb_TaskModal) <> IDOK then
        Exit;
    end;
  end;

  {Check that the PrintJob is open}
  if not OpenPrintJob then
    Exit;

  {Store current Report Number}
  nSub := FSubreports.FIndex;
  {Determine if a Subreport is being executed}
  RunMain := True;
  if (nSub > 0) and (FSubreports.FSubExecute = True) then
    RunMain := False;

  IsCanceled := False;
  {Do the OnExecute event}
  if not (csDesigning in ComponentState) then
  begin
    FCrpeState := crsInit;
    if Assigned(FOnExecuteBegin) then
      FOnExecuteBegin(Self, IsCanceled);
    FCrpeState := crsSetup;
    if IsCanceled then
      Result := False;
  end;

  if not IsCanceled then
  begin
    {If SubExecute is set to False}
    if RunMain then
    begin
      {Start with Main Report}
      FSubreports.SetIndex(0);
      nRpt := (FSubreports.Count - 1);
    end
    else
      nRpt := 0;

    for nIndex := nRpt downto 0 do
    begin
      {Update the Report Info pointer}
      if RunMain then
        FSubreports.SetIndex(nIndex);

      {These properties are set for the Main Report only,
       or for the Subreport if SubExecute is True}
      if nIndex = 0 then
      begin
        {DialogParent}
        SetDialogParent(FDialogParent);
        {WindowButtonBar}
        if (FOutput = toWindow) then
        begin
          FWindowButtonBar.Send;
          FWindowCursor.Send;
        end
        else
        begin
          {ProgressDialog}
          SetProgressDialog(FProgressDialog);
        end;
        {Printer}
        FPrinter.Send;
        {Output}
        if not SendOutput then
        begin
          FSubreports.SetIndex(nSub);
          Exit;
        end;
        {PrintDate}
        with FPrintDate do
        begin
          if FYear > 0 then
            SetYear(FYear);
          if FMonth > 0 then
            SetMonth(FMonth);
          if FDay > 0 then
            SetDay(FDay);
        end;
      end;
    end;

    {Enable WindowEvents}
    if (FOutput = toWindow) and (FWindowEvents = True) then
    begin
      {Set EventInfo items off}
      EventInfo.startStopEvent := 0;
      EventInfo.readingRecordEvent := 0;
      EventInfo.printWindowButtonEvent := 0;
      EventInfo.drillEvent := 0;
      EventInfo.closePrintWindowEvent := 0;
      EventInfo.activatePrintWindowEvent := 0;
      EventInfo.fieldMappingEvent := 0;
      EventInfo.mouseClickEvent := 0;
      EventInfo.hyperlinkEvent := 0;
      EventInfo.launchSeagateAnalysisEvent := 0;

      {Set applicable EventInfo items on}
      if Assigned(FwOnCloseWindow) then
      begin
        EventInfo.closePrintWindowEvent := 1;
        EventInfo.activatePrintWindowEvent := 1;
      end;
      if Assigned(FwOnActivateWindow) or
         Assigned(FwOnDeActivateWindow) then
      begin
        EventInfo.activatePrintWindowEvent := 1;
      end;
      if Assigned(FwOnPrintBtnClick) or
         Assigned(FwOnExportBtnClick) or
         Assigned(FwOnExportBtnClick) or
         Assigned(FwOnFirstPageBtnClick) or
         Assigned(FwOnPreviousPageBtnClick) or
         Assigned(FwOnNextPageBtnClick) or
         Assigned(FwOnLastPageBtnClick) or
         Assigned(FwOnCancelBtnClick) or
         Assigned(FwOnSearchBtnClick) or
         Assigned(FwOnGroupTreeBtnClick) or
         Assigned(FwOnRefreshBtnClick) then
      begin
        EventInfo.startStopEvent := 1;
        EventInfo.printWindowButtonEvent := 1;
      end;
      if Assigned(FwOnZoomLevelChange) or
         Assigned(FwOnCloseBtnClick) or
         Assigned(FwOnPrintSetupBtnClick) then
      begin
        EventInfo.printWindowButtonEvent := 1;
      end;
      if Assigned(FwOnShowGroup) or
         Assigned(FwOnDrillGroup) then
      begin
        EventInfo.startStopEvent := 1;
        EventInfo.drillEvent := 1;
      end;
      if Assigned(FwOnDrillDetail) then
        EventInfo.drillEvent := 1;
      if Assigned(FwOnReadingRecords) then
        EventInfo.readingRecordEvent := 1;
      if Assigned(FwOnStartEvent) or
         Assigned(FwOnStopEvent) then
      begin
        EventInfo.startStopEvent := 1;
      end;
      if Assigned(FwOnMouseClick) then
        EventInfo.mouseClickEvent := 1;
      if Assigned(FwOnDrillHyperLink) then
        EventInfo.hyperlinkEvent := 1;
      if Assigned(FwOnLaunchSeagateAnalysis) then
        EventInfo.launchSeagateAnalysisEvent := 1;

      {Enable Events}
      if not FCrpeEngine.PEEnableEvent(FPrintJob, EventInfo) then
      begin
        case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
            'Execute <PEEnableEvent>') of
          errIgnore : {Ignore};
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
        end;
      end;

      {Set Event Callback function}
      if not FCrpeEngine.PESetEventCallback(FPrintJob, Addr(WindowCallback), Self) then
      begin
        case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
            'Execute <PESetEventCallback>') of
          errIgnore : {Ignore};
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
        end;
      end;
    end;

    if not (csDesigning in ComponentState) then
    begin
      {Check the OnExecuteDoneSend Event}
      FCrpeState := crsInit;
      if Assigned(FOnExecuteDoneSend) then
        FOnExecuteDoneSend(Self, IsCanceled);
      FCrpeState := crsSetup;
      if IsCanceled then
      begin
        if (FPrintJob > 0) then
          FSubreports.SetIndex(nSub);
        Exit;
      end;
    end;

    {StartPrintJob}
    if not FCrpeEngine.PEStartPrintJob(FPrintJob, True) then
    begin
      case GetErrorMsg(FPrintJob,errCancelDialog,errEngine,'',
          'Execute <PEStartPrintJob>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
    Result := True;

    {WindowZoom}
    if (FOutput = toWindow) then
    begin
      if FWindowZoom.FMagnification = -1 then
      begin
        if FWindowZoom.FPreview <> pwDefault then
          FWindowZoom.SetPreview(FWindowZoom.FPreview);
      end
      else
        FWindowZoom.SetMagnification(FWindowZoom.FMagnification);
    end;

    if not (csDesigning in ComponentState) then
    begin
      {Check the OnExecuteEnd Event}
      FCrpeState := crsInit;
      if Assigned(FOnExecuteEnd) then
        FOnExecuteEnd(Self);
      FCrpeState := crsSetup;

      {Check the OnPrintEnded Event}
      if Assigned(FOnPrintEnded) then
      begin
        if (FOutput <> toWindow) then
        begin
          while not PrintEnded do
            Application.HandleMessage;
          FCrpeState := crsInit;
          FOnPrintEnded(Self);
          FCrpeState := crsSetup;
        end;
      end;

      {Check the OnWindowClose Event}
      if Assigned(FOnWindowClose) then
      begin
        if ReportWindowHandle > 0 then
        begin
          while ReportWindowHandle > 0 do
            Application.HandleMessage;
          FCrpeState := crsInit;
          FOnWindowClose(Self);
          FCrpeState := crsSetup;
        end;
      end;
    end;

    {Export to Application}
    if (FOutput = toExport) and (FExportOptions.FDestination = toApplication) then
    begin
      if not (IsStrEmpty(FExportOptions.FAppName)) then
      begin
        sAppName := Trim(FExportOptions.FAppName);
        sFileName := Trim(FExportOptions.FFileName);
        {Make sure Report is finished processing}
        while not PrintEnded do
          Application.HandleMessage;
        {Run Application}
        ShellExecute(0, 'open', PChar(sAppName), PChar(sFileName), nil, SW_SHOWNORMAL);
      end;
    end;
  end;
  {Reset Subreport Index: making sure the number is still valid,
   ie., CloseJob wasn't called in an event}
  if (FPrintJob > 0) and (nSub < FSubreports.Count) then
    FSubreports.SetIndex(nSub);
  FCrpeState := crsSetup;
end; { Member Execute }

{------------------------------------------------------------------------------}
{ Show                                                                         }
{------------------------------------------------------------------------------}
function TCrpe.Show : Boolean;
begin
  FOutput := toWindow;
  Result := Execute;
end;
{------------------------------------------------------------------------------}
{ Print                                                                        }
{------------------------------------------------------------------------------}
function TCrpe.Print : Boolean;
begin
  FOutput := toPrinter;
  Result := Execute;
end;
{------------------------------------------------------------------------------}
{ Export                                                                       }
{------------------------------------------------------------------------------}
function TCrpe.Export : Boolean;
begin
  FOutput := toExport;
  Result := Execute;
end;

{------------------------------------------------------------------------------}
{ Refresh                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpe.Refresh;
var
  b: Bool;
begin
  if (FPrintJob = 0) then Exit;
  b := True;
  FCrpeEngine.PESetRefreshData(FPrintJob, b);
end;

{------------------------------------------------------------------------------}
{ LogOnPrivateInfo                                                             }
{------------------------------------------------------------------------------}
function TCrpe.LogOnPrivateInfo(DllName: string; PrivateInfo: pointer): Boolean;
begin
  Result := False;
  if not OpenPrintEngine then Exit;
  Result := FCrpeEngine.PELogOnSQLServerWithPrivateInfo(PChar(DllName), PrivateInfo);
end;

{------------------------------------------------------------------------------}
{ HasSavedData                                                                 }
{------------------------------------------------------------------------------}
function TCrpe.HasSavedData : Boolean;
var
  bSavedData : Bool;
begin
  {Use True as default: assume Rpt has Saved Data}
  Result := True;
  if IsStrEmpty(FReportName) then Exit;
  if not OpenPrintJob then Exit;

  if not FCrpeEngine.PEHasSavedData(FPrintJob, bSavedData) then
  begin
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
        'HasSavedData <PEHasSavedData>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  Result := Boolean(bSavedData);
end;
{------------------------------------------------------------------------------}
{ DiscardSavedData                                                             }
{------------------------------------------------------------------------------}
function TCrpe.DiscardSavedData : Boolean;
begin
  Result := False;
  if IsStrEmpty(FReportName) then Exit;
  if not OpenPrintJob then Exit;

  if not FCrpeEngine.PEDiscardSavedData(PrintJobs(0)) then
  begin
    case GetErrorMsg(PrintJobs(0),errNoOption,errEngine,'',
        'DiscardData <PEDiscardSavedData>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  Result := True;
end;

{------------------------------------------------------------------------------}
{ SetTempPath                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpe.SetTempPath (TempPath: string);
var
  sPath : string;
begin
  {We need to be careful here, we don't want to automatically
  set this property to the default Temp path unless the user
  passes in a valid value}
  FTempPath := TempPath;
  sPath := CrGetTempPath;
  if IsStrEmpty(TempPath) then Exit;
  if not DirectoryExists(TempPath) then Exit;
  if not EngineOpen then Exit;
  if CompareText(FTempPath, sPath) <> 0 then
    FCrpeEngine.PESetTempFilePath(PChar(FTempPath));
end;

{------------------------------------------------------------------------------}
{ FormulaByName                                                                }
{------------------------------------------------------------------------------}
function TCrpe.FormulaByName (FormulaName: string): TCrpeFormulasItem;
begin
  Result := FFormulas.ByName(FormulaName);
end;
{------------------------------------------------------------------------------}
{ ParamByName                                                                  }
{------------------------------------------------------------------------------}
function TCrpe.ParamByName (ParamFieldName: string; ReportName: string): TCrpeParamFieldsItem;
begin
  Result := FParamFields.ByName(ParamFieldName, ReportName);
end;
{------------------------------------------------------------------------------}
{ RunningTotalByName                                                           }
{------------------------------------------------------------------------------}
function TCrpe.RunningTotalByName (RunningTotalName: string): TCrpeRunningTotalsItem;
begin
  Result := FRunningTotals.ByName(RunningTotalName);
end;
{------------------------------------------------------------------------------}
{ SQLExpressionByName                                                          }
{------------------------------------------------------------------------------}
function TCrpe.SQLExpressionByName (ExpressionName: string): TCrpeSQLExpressionsItem;
begin
  Result := FSQLExpressions.ByName(ExpressionName);
end;
{------------------------------------------------------------------------------}
{ SubreportByName                                                              }
{------------------------------------------------------------------------------}
function TCrpe.SubreportByName (SubreportName: string): TCrpeSubreportsItem;
begin
  Result := FSubreports.ByName(SubreportName);
end;
{------------------------------------------------------------------------------}
{ TableByName                                                                  }
{------------------------------------------------------------------------------}
function TCrpe.TableByName (AliasName: string): TCrpeTablesItem;
begin
  Result := FTables.ByName(AliasName);
end;
{------------------------------------------------------------------------------}
{ SectionFormatByName                                                          }
{------------------------------------------------------------------------------}
function TCrpe.SectionFormatByName (SectionName: string): TCrpeSectionFormatItem;
begin
  Result := FSectionFormat.ByName(SectionName);
end;
{------------------------------------------------------------------------------}
{ AreaFormatByName                                                             }
{------------------------------------------------------------------------------}
function TCrpe.AreaFormatByName (AreaName: string): TCrpeAreaFormatItem;
begin
  Result := FAreaFormat.ByName(AreaName);
end;

{------------------------------------------------------------------------------}
{ SetProgressDialog                                                            }
{------------------------------------------------------------------------------}
procedure TCrpe.SetProgressDialog(const Value: Boolean);
begin
  FProgressDialog := Value;
  if IsStrEmpty(FReportName) then Exit;
  if not OpenPrintJob then Exit;
  {Send ProgressDialog setting}
  if not FCrpeEngine.PEEnableProgressDialog(FPrintJob, FProgressDialog) then
  begin
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
         'SetProgressDialog <PEEnableProgressDialog>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
end;

{------------------------------------------------------------------------------}
{ ConvertFormulaName                                                           }
{------------------------------------------------------------------------------}
function TCrpe.ConvertFormulaName (FName: TCrFormatFormulaName): Smallint;
begin
  Result := PE_FFN_FONT_COLOR;
  case FName of
    {Number/Currency}
    ffnSuppressIfZero           : Result := PE_FFN_SUPPRESS_IF_ZERO;
    ffnNegativeFormat           : Result := PE_FFN_NEGATIVE_TYPE;
    ffnUseThousandsSeparators   : Result := PE_FFN_USE_THOUSANDS_SEPARATORS;
    ffnUseLeadingZero           : Result := PE_FFN_USE_LEADING_ZERO;
    ffnDecimalPlaces            : Result := PE_FFN_N_DECIMAL_PLACES;
    ffnRoundingFormat           : Result := PE_FFN_ROUNDING_TYPE;
    ffnCurrencySymbolFormat     : Result := PE_FFN_CURRENCY_SYMBOL_TYPE;
    ffnOneCurrencySymbolPerPage : Result := PE_FFN_USE_ONE_CURRENCY_SYMBOL_PER_PAGE;
    ffnCurrencySymbolPosition   : Result := PE_FFN_CURRENCY_POSITION_TYPE;
    ffnThousandSymbol           : Result := PE_FFN_THOUSAND_SYMBOL;
    ffnDecimalSymbol            : Result := PE_FFN_DECIMAL_SYMBOL;
    ffnCurrencySymbol           : Result := PE_FFN_CURRENCY_SYMBOL;
      {reverse sign for number/currency display}
    ffnReverseSignForDisplay    : Result := PE_FFN_REVERSE_SIGN_FOR_DISPLAY;
    {FieldClipping}
    ffnAllowFieldClipping       : Result := PE_FFN_ALLOW_FIELD_CLIPPING;
    {Boolean}
    ffnBooleanType              : Result := PE_FFN_BOOLEAN_OUTPUT_TYPE;
    {Date}
    ffnDateType                 : Result := PE_FFN_DATE_WINDOWS_DEFAULT_TYPE;
    ffnDateOrder                : Result := PE_FFN_DATE_ORDER;
    ffnYearFormat               : Result := PE_FFN_YEAR_TYPE;
    ffnMonthFormat              : Result := PE_FFN_MONTH_TYPE;
    ffnDayFormat                : Result := PE_FFN_DAY_TYPE;
    ffnFirstDateSeparator       : Result := PE_FFN_DATE_FIRST_SEPARATOR;
    ffnSecondDateSeparator      : Result := PE_FFN_DATE_SECOND_SEPARATOR;
    ffnDayOfWeekType            : Result := PE_FFN_DAY_OF_WEEK_TYPE;
    ffnDayOfWeekSeparator       : Result := PE_FFN_DAY_OF_WEEK_SEPARATOR;
    ffnDayOfWeekPosition        : Result := PE_FFN_DAY_OF_WEEK_POSITION;
    ffnDateEraFormat            : Result := PE_FFN_DATE_ERA_TYPE;
    ffnCalendarType             : Result := PE_FFN_DATE_CALENDAR_TYPE;
    ffnPrefixSeparator          : Result := PE_FFN_DATE_PREFIX_SEPARATOR;
    ffnSuffixSeparator          : Result := PE_FFN_DATE_SUFFIX_SEPARATOR;
    ffnDayOfWeekEnclosure       : Result := PE_FFN_DAY_OF_WEEK_ENCLOSURE;
    {Time}
    ffnTimeBase                 : Result := PE_FFN_TIME_BASE;
    ffnAmPmPosition             : Result := PE_FFN_AM_PM_TYPE;
    ffnHourType                 : Result := PE_FFN_HOUR_TYPE;
    ffnMinuteType               : Result := PE_FFN_MINUTE_TYPE;
    ffnSecondType               : Result := PE_FFN_SECOND_TYPE;
    ffnHourMinSeparator         : Result := PE_FFN_HOUR_MINUTE_SEPARATOR;
    ffnMinSecSeparator          : Result := PE_FFN_MINUTE_SECOND_SEPARATOR;
    ffnAMString                 : Result := PE_FFN_AM_STRING;
    ffnPMString                 : Result := PE_FFN_PM_STRING;
    {DateTime}
    ffnDateTimeOrder            : Result := PE_FFN_DATE_TIME_ORDER;
    ffnDateTimeSeparator        : Result := PE_FFN_DATE_TIME_SEPARATOR_STRING;
    {Paragraph - first 3 not used in 5.x}
    ffnFirstLineIndent          : Result := PE_FFN_FIRST_LINE_INDENT;
    ffnLeftIndent               : Result := PE_FFN_LEFT_INDENT;
    ffnRightIndent              : Result := PE_FFN_RIGHT_INDENT;
    ffnMaxNLines                : Result := PE_FFN_MAX_N_LINES;
      {Text interpretation of string & memo database fields}
    ffnTextInterpretation       : Result := PE_FFN_TEXT_INTERPRETATION;
    ffnFontColor                : Result := PE_FFN_FONT_COLOR;
  end;
end;

{------------------------------------------------------------------------------}
{ ReportWindowHandle                                                           }
{------------------------------------------------------------------------------}
function TCrpe.ReportWindowHandle: hWnd;
begin
  Result := 0;
  if not FEngineOpened then Exit;
  Result := FCrpeEngine.PEGetWindowHandle(FPrintJob);
end; { ReportWindowHandle }

{------------------------------------------------------------------------------}
{ ShowWindow                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpe.ShowWindow;
begin
  if ReportWindowHandle > 0 then
    Windows.ShowWindow(ReportWindowHandle, SW_SHOWNORMAL);
end; { ShowWindow }

{------------------------------------------------------------------------------}
{ Search                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpe.Search (SearchText: string);
var
  xWnd : HWnd;

  function CheckName : boolean;
  var
    a1 : array[0..255] of Char;
  begin
    GetClassName(xWnd, a1, 256);
    Result := (StrIComp(a1, PChar('Edit')) = 0);
  end;

begin
  if ReportWindowHandle > 0 then
  begin
    xWnd := ReportWindowHandle;
    {AfxWnd42 - The first child frame} {CR 6 uses AfxWnd42s}
    xWnd := GetWindow(xWnd, GW_CHILD);
    {Get Toolbar}
    xWnd := GetWindow(xWnd, GW_HWNDNEXT);
    {Static Text - Page N of N}
    xWnd := GetWindow(xWnd, GW_CHILD);
    {Static Text - Zoom Combo Box}
    xWnd := GetWindow(xWnd, GW_HWNDNEXT);
    {Static Text - Search Edit Control}
    xWnd := GetWindow(xWnd, GW_HWNDNEXT);
    if not CheckName then Exit;
    {Send the Text}
    SendMessage(xWnd, WM_SETTEXT, 0, Integer(PChar(SearchText)));
    {Send the Enter key}
    SendMessage(xWnd, WM_CHAR, 13, 0);
  end;
end; { Search }

{------------------------------------------------------------------------------}
{ HideWindow                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpe.HideWindow;
begin
  if ReportWindowHandle > 0 then
    Windows.ShowWindow(ReportWindowHandle, SW_HIDE);
end; { HideWindow }

{------------------------------------------------------------------------------}
{ CloseWindow                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpe.CloseWindow;
begin
  if ReportWindowHandle > 0 then
    FCrpeEngine.PECloseWindow(FPrintJob);
end; { CloseWindow }

{------------------------------------------------------------------------------}
{ Focused                                                                      }
{------------------------------------------------------------------------------}
function TCrpe.Focused: Boolean;
begin
  Result := False;
  if GetActiveWindow = ReportWindowHandle then
    Result := True;
end; { Focused }

{------------------------------------------------------------------------------}
{ SetFocus                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpe.SetFocus;
begin
  if ReportWindowHandle > 0 then
    Windows.SetFocus(ReportWindowHandle);
end; { SetFocus }

{------------------------------------------------------------------------------}
{ PrintWindow                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpe.PrintWindow;
var
  bWait: Bool;
begin
  if ReportWindowHandle > 0 then
  begin
    bWait := True;
    if not FCrpeEngine.PEPrintWindow(FPrintJob, bWait) then
    begin
      case GetErrorMsg(FPrintJob,errCancelDialog,errEngine,'',
          'PrintWindow <PEPrintWindow>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
  end;
end; { PrintWindow }

{------------------------------------------------------------------------------}
{ ExportWindow                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpe.ExportWindow (bMail: Boolean);
begin
  if ReportWindowHandle > 0 then
  begin
    if not FCrpeEngine.PEExportPrintWindow(FPrintJob, BOOL(bMail), True) then
    begin
      case GetErrorMsg(FPrintJob,errCancelDialog,errEngine,'',
          'ExportWindow <PEExportPrintWindow>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
  end;
end; { ExportWindow }

{------------------------------------------------------------------------------}
{ GetWindowParent                                                              }
{------------------------------------------------------------------------------}
function TCrpe.GetWindowParent : TCrWinControl;
begin
  if FWindowParent <> nil then
  begin
    try
      if not IsWindow(FWindowParent.Handle) then
        FWindowParent := nil;
    except
      FWindowParent := nil;
    end;
  end;
  Result := FWindowParent;
end;
{------------------------------------------------------------------------------}
{ SetWindowParent                                                              }
{------------------------------------------------------------------------------}
procedure TCrpe.SetWindowParent (const Value: TCrWinControl);
begin
  if Value <> FWindowParent then
  begin
    FWindowParent := Value;
    if Value <> nil then Value.FreeNotification(Self);
  end;
end;

{------------------------------------------------------------------------------}
{ GetDialogParent                                                              }
{------------------------------------------------------------------------------}
function TCrpe.GetDialogParent: TCrWinControl;
begin
  if FDialogParent <> nil then
  begin
    try
      if not IsWindow(FDialogParent.Handle) then
        FDialogParent := nil;
    except
      FDialogParent := nil;
    end;
  end;
  Result := FDialogParent;
end;
{------------------------------------------------------------------------------}
{ SetDialogParent                                                              }
{------------------------------------------------------------------------------}
procedure TCrpe.SetDialogParent (const Value: TCrWinControl);
var
  xHandle : HWnd;
begin
  if Value <> FDialogParent then
  begin
    FDialogParent := Value;
    if FDialogParent <> nil then
    begin
      Value.FreeNotification(Self);
      if IsStrEmpty(FReportName) then
        Exit;
      if not OpenPrintJob then
        Exit;

      xHandle := FDialogParent.Handle;
      {Send the Dialog handle}
      if not FCrpeEngine.PESetDialogParentWindow(FPrintJob, xHandle) then
      begin
        case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
            'SetDialogParent <PESetDialogParentWindow>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
        end;
      end;
    end;
  end;
end;

{------------------------------------------------------------------------------}
{ GetReportTitle                                                               }
{------------------------------------------------------------------------------}
function TCrpe.GetReportTitle: string;
var
  hTitle : HWnd;
  nTitle : Smallint;
  pTitle : PChar;
begin
  Result := FReportTitle;
  if IsStrEmpty(FReportName) or (not FileExists(FReportName)) then Exit;
  if csLoading in ComponentState then Exit;
  if not OpenPrintJob then Exit;

  {Get ReportTitle}
  if not FCrpeEngine.PEGetReportTitle(FPrintJob, hTitle, nTitle) then
  begin
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
        'GetReportTitle <PEGetReportTitle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  {Get the ReportTitle text}
  pTitle := StrAlloc(nTitle);
  if not FCrpeEngine.PEGetHandleString(hTitle, pTitle, nTitle) then
  begin
    StrDispose(pTitle);
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
        'GetReportTitle <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  FReportTitle := String(pTitle);
  StrDispose(pTitle);
  Result := FReportTitle;
end;
{------------------------------------------------------------------------------}
{ SetReportTitle                                                               }
{------------------------------------------------------------------------------}
procedure TCrpe.SetReportTitle(const Value: string);
var
  hTitle : HWnd;
  nTitle : Smallint;
  pTitle : PChar;
  sTitle : string;
begin
  FReportTitle := Value;
  if IsStrEmpty(FReportName) then Exit;
  if not OpenPrintJob then Exit;

  {Get ReportTitle}
  if not FCrpeEngine.PEGetReportTitle(FPrintJob, hTitle, nTitle) then
  begin
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
        'SetReportTitle <PEGetReportTitle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  {Get the ReportTitle text}
  pTitle := StrAlloc(nTitle);
  if not FCrpeEngine.PEGetHandleString(hTitle, pTitle, nTitle) then
  begin
    StrDispose(pTitle);
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
        'SetReportTitle <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;
  sTitle := String(pTitle);
  StrDispose(pTitle);

  {Set ReportTitle}
  if CompareStr(FReportTitle, sTitle) <> 0 then
  begin
    if not FCrpeEngine.PESetReportTitle(FPrintJob, PChar(FReportTitle)) then
    begin
      case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
          'SetReportTitle <PESetReportTitle>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
  end;
end;

{------------------------------------------------------------------------------}
{ GetDetailCopies                                                              }
{------------------------------------------------------------------------------}
function TCrpe.GetDetailCopies : Smallint;
begin
  Result := FDetailCopies;
  if FPrintJob > 0 then
  begin
    if not FCrpeEngine.PEGetNDetailCopies(FPrintJob, FDetailCopies) then
    begin
      case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
          'RetrieveDetailCopies <PEGetNDetailCopies>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
  end;
  Result := FDetailCopies;
end;
{------------------------------------------------------------------------------}
{ SetDetailCopies                                                              }
{------------------------------------------------------------------------------}
procedure TCrpe.SetDetailCopies(const Value: Smallint);
var
  rptDCopies : Smallint;
begin
  FDetailCopies := Value;
  if IsStrEmpty(FReportName) then Exit;
  if not OpenPrintJob then Exit;

  {Get DetailCopies from Report}
  if not FCrpeEngine.PEGetNDetailCopies(FPrintJob, rptDCopies) then
  begin
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
       'SetDetailCopies <PEGetNDetailCopies>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;

  {Send DetailCopies to Report}
  if FDetailCopies <> rptDCopies then
  begin
    if not FCrpeEngine.PESetNDetailCopies(FPrintJob, FDetailCopies) then
    begin
      case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
         'SetDetailCopies <PESetNDetailCopies>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
  end;
end;

{------------------------------------------------------------------------------}
{ GetSectionCodes                                                              }
{------------------------------------------------------------------------------}
function TCrpe.GetSectionCodes(JobNum: Smallint; var slNCodes: TStringList;
  var slSCodes: TStringList; bArea: Boolean): Boolean;
const
  sCode : array[0..39] of string = ('a','b','c','d','e','f','g','h',
     'i','j', 'k','l','m','n','o','p','q','r','s','t','u','v','w',
     'x','y','z','aa','ab','ac','ad','ae','af','ag','ah','ai','aj',
     'ak','al','am','an');
var
  nCntGF, nMaxGF : integer;
  nIndex         : Smallint;
  SectionCode    : Smallint;
  cnt1           : Smallint;
  nSecNum        : integer;
  nSections      : integer;
begin
  Result := False;
  nCntGF := 0;
  nMaxGF := 0;

  {Get the # of Sections in the Report}
  nSections := FCrpeEngine.PEGetNSections(JobNum);
  if (nSections = -1) then
  begin
    case GetErrorMsg(JobNum,errNoOption,errEngine,'',
        'GetSectionCodes <PEGetNSections>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;

  {Get ReportHeader to Details}
  slNCodes.Clear;
  for nIndex := 0 to (nSections - 1) do
  begin
    SectionCode := FCrpeEngine.PEGetSectionCode(JobNum, nIndex);
    {RH, PH, GH, D}
    if SectionCode div 1000 < 5 then
    begin
      {We only want unique values: the Print Engine has limits and
      will repeat numbers for Subsections over 40 or Groups over 25}
      if slNCodes.IndexOf(IntToStr(SectionCode)) = -1 then
      begin
        {If we are checking for Areas only}
        if bArea then
        begin
          {If SectionCode has remainder less than 25, it is an AreaCode}
          if SectionCode mod 1000 < 25 then
            slNCodes.Add(IntToStr(SectionCode));
        end
        else
          slNCodes.Add(IntToStr(SectionCode));
      end;
    end
    {GF}
    else
    begin
      {Group Footer: get index number and count}
      if SectionCode div 1000 = 5 then
      begin
        Inc(nCntGF);
        nMaxGF := nIndex;
      end;
    end;
  end;

  {Add GroupFooter items to Section list, in reverse order}
  slSCodes.Clear;
  Dec(nCntGF);
  for nIndex := nMaxGF downto (nMaxGF - nCntGF) do
  begin
    SectionCode := FCrpeEngine.PEGetSectionCode(JobNum, nIndex);
    if slSCodes.IndexOf(IntToStr(SectionCode)) = -1 then
    begin
      {If we are checking for Areas only}
      if bArea then
      begin
        {If SectionCode has remainder less than 25, it is an AreaCode}
        if SectionCode mod 1000 < 25 then
          slSCodes.Add(IntToStr(SectionCode));
      end
      else
        slSCodes.Add(IntToStr(SectionCode));
    end;
  end;
  for nIndex := (slSCodes.Count - 1) downto 0 do
    slNCodes.Add(slSCodes[nIndex]);
  slSCodes.Clear;

  {Add ReportFooter/PageFooter items to Section list}
  for nIndex := 0 to (nSections - 1) do
  begin
    SectionCode := FCrpeEngine.PEGetSectionCode(JobNum, nIndex);
    if SectionCode div 1000 > 5 then
    begin
      {If it doesn't already exist}
      if slNCodes.IndexOf(IntToStr(SectionCode)) = -1 then
      begin
        {If we are checking for Areas only}
        if bArea then
        begin
          {If SectionCode has remainder less than 25, it is an AreaCode}
          if SectionCode mod 1000 < 25 then
            slNCodes.Add(IntToStr(SectionCode));
        end
        else
          slNCodes.Add(IntToStr(SectionCode));
      end;
    end;
  end;

  {Change Section Codes: 3000, to strings: GH1a}
  for cnt1 := 0 to (slNCodes.Count - 1) do
  begin
    {Get Section Code number}
    nSecNum := StrToInt(slNCodes[cnt1]);
    {Get Section string}
    slSCodes.Add(SectionCodeToStringEx(nSecNum, bArea));
  end;

  Result := True;
end;

{------------------------------------------------------------------------------}
{ GetFormulaSyntax                                                             }
{------------------------------------------------------------------------------}
function TCrpe.GetFormulaSyntax : TCrFormulaSyntax;
var
  SyntaxType : PEFormulaSyntax;
begin
  Result := FFormulaSyntax;
  if FPrintJob > 0 then
  begin
    if not FCrpeEngine.PEGetFormulaSyntax(FPrintJob, SyntaxType) then
    begin
      case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
          'GetFormulaSyntax <PEGetFormulaSyntax>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
    case SyntaxType.formulaSyntax[0] of
      PE_FST_CRYSTAL : FFormulaSyntax := fsCrystal;
      PE_FST_BASIC   : FFormulaSyntax := fsBasic;
    end;
    Result := FFormulaSyntax;
  end;
end;
{------------------------------------------------------------------------------}
{ SetFormulaSyntax                                                             }
{------------------------------------------------------------------------------}
procedure TCrpe.SetFormulaSyntax(const Value: TCrFormulaSyntax);
var
  SyntaxType : PEFormulaSyntax;
begin
  FFormulaSyntax := Value;
  if IsStrEmpty(FReportName) then Exit;
  if not OpenPrintJob then Exit;

  if not FCrpeEngine.PEGetFormulaSyntax(FPrintJob, SyntaxType) then
  begin
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
        'SetFormulaSyntax <PEGetFormulaSyntax>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;

  {Compare}
  if Ord(FFormulaSyntax) <> SyntaxType.formulaSyntax[0] then
  begin
    SyntaxType.formulaSyntax[0] := Ord(FFormulaSyntax);
    SyntaxType.formulaSyntax[1] := Ord(FFormulaSyntax);
    {Send in changes}
    if not FCrpeEngine.PESetFormulaSyntax(FPrintJob, SyntaxType) then
    begin
      case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
          'SetFormulaSyntax <PESetFormulaSyntax>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
  end;
end;

{------------------------------------------------------------------------------}
{ GetReportStyle                                                               }
{------------------------------------------------------------------------------}
function TCrpe.GetReportStyle : TCrReportStyle;
var
  wStyle : Word;
begin
  Result := FReportStyle;
  if FPrintJob > 0 then
  begin
    wStyle := FCrpeEngine.PEGetReportStyle(FPrintJob);
    if wStyle > 10 then
    begin
      case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
          'GetReportStyle <PEGetReportStyle>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
    FReportStyle := TCrReportStyle(wStyle);
    Result := FReportStyle;
  end;
end;
{------------------------------------------------------------------------------}
{ SetReportStyle                                                               }
{------------------------------------------------------------------------------}
procedure TCrpe.SetReportStyle(const Value: TCrReportStyle);
var
  wStyle : Word;
  xInt   : integer;
begin
  FReportStyle := Value;
  if IsStrEmpty(FReportName) then Exit;
  if not OpenPrintJob then Exit;

  wStyle := FCrpeEngine.PEGetReportStyle(FPrintJob);
  if wStyle > 10 then
  begin
    case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
        'SetReportStyle <PEGetReportStyle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
    end;
  end;

  xInt := wStyle;
  if Ord(FReportStyle) <> xInt then
  begin
    wStyle := Ord(FReportStyle);
    {Send in changes}
    if not FCrpeEngine.PESetReportStyle (FPrintJob, wStyle) then
    begin
      case GetErrorMsg(FPrintJob,errNoOption,errEngine,'',
          'SetReportStyle <PESetReportStyle>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(FLastErrorNumber, FLastErrorString);
      end;
    end;
  end;
end;

{------------------------------------------------------------------------------}
{ FieldNameToFieldInfo                                                         }
{------------------------------------------------------------------------------}
function TCrpe.FieldNameToFieldInfo(FieldName: string): TCrFieldInfo;
var
  FieldInfo : TCrFieldInfo;
  s1        : string;
  iDot      : integer;
  iOpen     : integer;
  iClose    : integer;
begin
  {Initialize FieldInfo}
  FieldInfo.TableName   := '';
  FieldInfo.TableIndex  := -1;
  FieldInfo.FieldName   := '';
  FieldInfo.FieldIndex  := -1;
  FieldInfo.FieldType   := fvUnknown;
  FieldInfo.FieldLength := 0;
  Result := FieldInfo;

  {Check for empty string}
  if IsStrEmpty(FieldName) then Exit;
  s1 := Trim(FieldName);
  {Find position of Open Bracket}
  iOpen := Pos('{', s1);
  if iOpen = -1 then iOpen := 1;
  {Find position of Table/Field divider}
  iDot := Pos('.', s1);
  if iDot = -1 then Exit;
  {Find position of Close Bracket}
  iClose := Pos('}', s1);
  if iClose = -1 then iClose := Length(s1);
  {Look for opening fieldname bracket}
  FieldInfo.TableName := Copy(s1,iOpen+1,iDot-2);
  FieldInfo.FieldName := Copy(s1,iDot+1,iClose-iDot-1);
  Result := FieldInfo;
end;
{------------------------------------------------------------------------------}
{ FieldInfoToFieldName                                                         }
{------------------------------------------------------------------------------}
function TCrpe.FieldInfoToFieldName(FieldInfo: TCrFieldInfo): string;
begin
  Result := '{' + FieldInfo.TableName + '.' + FieldInfo.FieldName + '}';
end;


{**** Beginning of SubClass Definitions ****}
{******************************************************************************}
{ TCrpeWindowsVersion Class Definition                                         }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeWindowsVersion.Create;
begin
  inherited Create;
  FPlatform := '';
  FMajor    := 0;
  FMinor    := 0;
  FBuild    := '';
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeWindowsVersion.Clear;
begin
  FPlatform := '';
  FMajor    := 0;
  FMinor    := 0;
  FBuild    := '';
end;
{------------------------------------------------------------------------------}
{ GetPlatform                                                                  }
{------------------------------------------------------------------------------}
function TCrpeWindowsVersion.GetPlatform : string;
var
  OSInfo : TOSVersionInfo;
  sTmp   : string;
begin
  FPlatform := '';
  OSInfo.dwOSVersionInfoSize := SizeOf(TOSVERSIONINFO);
  if GetVersionEx(OSInfo) then
  begin
    case OSInfo.dwPlatformId of
      VER_PLATFORM_WIN32s        : FPlatform := '3.1';
      VER_PLATFORM_WIN32_WINDOWS : FPlatform := '95';
      VER_PLATFORM_WIN32_NT      : FPlatform := 'NT';
      else
        sTmp := 'Unknown';
    end;
    if (FPlatform = '95') and (OSInfo.dwMajorVersion = 4) and
      (OSInfo.dwMinorVersion > 9) then
      FPlatform := '98';
  end;
  Result := FPlatform;
end;
{------------------------------------------------------------------------------}
{ SetPlatform                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeWindowsVersion.SetPlatform(const Value: string);
begin
  {Read-only}
end;
{------------------------------------------------------------------------------}
{ GetMinor                                                                     }
{------------------------------------------------------------------------------}
function TCrpeWindowsVersion.GetMinor: DWord;
var
  OSInfo : TOSVersionInfo;
begin
  OSInfo.dwOSVersionInfoSize := SizeOf(TOSVERSIONINFO);
  if GetVersionEx(OSInfo) then
    FMinor := OSInfo.dwMinorVersion
  else
    FMinor := 0;
  Result := FMinor;
end;
{------------------------------------------------------------------------------}
{ SetMinor                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeWindowsVersion.SetMinor(const Value: DWord);
begin
  {Read-only}
end;
{------------------------------------------------------------------------------}
{ GetMajor                                                                     }
{------------------------------------------------------------------------------}
function TCrpeWindowsVersion.GetMajor: DWord;
var
  OSInfo : TOSVersionInfo;
begin
  {Get Windows version}
  OSInfo.dwOSVersionInfoSize := SizeOf(TOSVERSIONINFO);
  if GetVersionEx(OSInfo) then
    FMajor := OSInfo.dwMajorVersion
  else
    FMajor := 0;
  Result := FMajor;
end;
{------------------------------------------------------------------------------}
{ SetMajor                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeWindowsVersion.SetMajor(const Value: DWord);
begin
  {Read-only}
end;
{------------------------------------------------------------------------------}
{ GetBuild                                                                     }
{------------------------------------------------------------------------------}
function TCrpeWindowsVersion.GetBuild : string;
var
  OSInfo : TOSVersionInfo;
begin
  OSInfo.dwOSVersionInfoSize := SizeOf(TOSVERSIONINFO);
  if GetVersionEx(OSInfo) then
    FBuild := Format('%d', [LOWORD(OSInfo.dwBuildNumber)])
  else
    FBuild := '';
  Result := FBuild;
end;
{------------------------------------------------------------------------------}
{ SetBuild                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeWindowsVersion.SetBuild(const Value: string);
begin
  {Read-only}
end;

{******************************************************************************}
{ TCrpeReportVersion Class Definition                                          }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeReportVersion.Create;
begin
  inherited Create;
  FMajor  := 0;
  FMinor  := 0;
  FLetter := '';
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeReportVersion.Clear;
begin
  FMajor  := 0;
  FMinor  := 0;
  FLetter := '';
end;
{------------------------------------------------------------------------------}
{ GetMajor                                                                     }
{------------------------------------------------------------------------------}
function TCrpeReportVersion.GetMajor : Word;
var
  VersionInfo : PEVersionInfo;
begin
  Result := 0;
  if IsStrEmpty(Cr.FReportName) then Exit;
  if not FileExists(Cr.FReportName) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if not Cr.OpenPrintJob then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportVersion(Cr.FPrintJob, VersionInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Version.Report.GetMajor <PEGetReportVersion>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FMajor := VersionInfo.major;
  Result := FMajor;
end;
{------------------------------------------------------------------------------}
{ SetMajor                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeReportVersion.SetMajor(const Value: Word);
begin
  {Read-only}
end;
{------------------------------------------------------------------------------}
{ GetMinor                                                                     }
{------------------------------------------------------------------------------}
function TCrpeReportVersion.GetMinor: Word;
var
  VersionInfo : PEVersionInfo;
begin
  Result := 0;
  if IsStrEmpty(Cr.FReportName) then Exit;
  if not FileExists(Cr.FReportName) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if not Cr.OpenPrintJob then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportVersion(Cr.FPrintJob, VersionInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Version.Report.GetMinor <PEGetReportVersion>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FMinor := VersionInfo.minor;
  Result := FMinor;
end;
{------------------------------------------------------------------------------}
{ SetMinor                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeReportVersion.SetMinor(const Value: Word);
begin
  {Read-only}
end;
{------------------------------------------------------------------------------}
{ GetLetter                                                                    }
{------------------------------------------------------------------------------}
function TCrpeReportVersion.GetLetter: string;
var
  VersionInfo : PEVersionInfo;
begin
  Result := Chr(0);
  if IsStrEmpty(Cr.FReportName) then Exit;
  if not FileExists(Cr.FReportName) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if not Cr.OpenPrintJob then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportVersion(Cr.FPrintJob, VersionInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Version.Report.GetLetter <PEGetReportVersion>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FLetter := VersionInfo.letter;
  Result := FLetter;
end;
{------------------------------------------------------------------------------}
{ SetLetter                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeReportVersion.SetLetter(const Value: string);
begin
  {Read-only}
end;

{******************************************************************************}
{ TCrpeEngineVersion Class Definition                                          }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeEngineVersion.Create;
begin
  inherited Create;
  {Set Defaults}
  FDLL         := '';
  FEngine      := '';
  FFileVersion := '';
  FMajor       := 0;
  FMinor       := 0;
  FRelease     := 0;
  FBuild       := 0;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeEngineVersion.Clear;
begin
  FDLL         := '';
  FEngine      := '';
  FFileVersion := '';
  FMajor       := 0;
  FMinor       := 0;
  FRelease     := 0;
  FBuild       := 0;
end;
{------------------------------------------------------------------------------}
{ GetDLL                                                                       }
{------------------------------------------------------------------------------}
function TCrpeEngineVersion.GetDLL : string;
var
  iDLL : Smallint;
begin
  FDLL := '';
  Result := FDLL;
  if (Cr = nil) then Exit;
  if Cr.hDLL = 0 then Exit;
  {Get CRPE version}
  
  iDLL := Cr.FCrpeEngine.PEGetVersion(PE_GV_DLL);

  FDLL := Format('%d.%d', [Hi(iDLL), Lo(iDLL)]);
  Result := FDLL;
end;
{------------------------------------------------------------------------------}
{ SetDLL                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeEngineVersion.SetDLL(const Value : string);
begin
  {Read-only}
end;
{------------------------------------------------------------------------------}
{ GetEngine                                                                    }
{------------------------------------------------------------------------------}
function TCrpeEngineVersion.GetEngine : string;
var
  iEng : Smallint;
begin
  FEngine := '';
  Result := FEngine;
  if (Cr = nil) then Exit;
  if Cr.hDLL = 0 then Exit;
  {Get CRPE version}
  
  iEng := Cr.FCrpeEngine.PEGetVersion(PE_GV_ENGINE);
  FEngine := Format('%d.%d', [Hi(iEng), Lo(iEng)]);
  Result := FEngine;
end;
{------------------------------------------------------------------------------}
{ SetEngine                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeEngineVersion.SetEngine(const Value : string);
begin
  {Read-only}
end;
{------------------------------------------------------------------------------}
{ GetFileVersion                                                               }
{------------------------------------------------------------------------------}
function TCrpeEngineVersion.GetFileVersion : string;
begin
  FFileVersion := '';
  Result := FFileVersion;
  if (Cr = nil) then Exit;
  if Cr.hDLL = 0 then Exit;
  if IsStrEmpty(FFileVersion) then
    Cr.GetCRPEVersion;
  Result := FFileVersion;
end;
{------------------------------------------------------------------------------}
{ SetFileVersion                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeEngineVersion.SetFileVersion(const Value : string);
begin
  {Read-only}
end;
{------------------------------------------------------------------------------}
{ GetMajor                                                                     }
{------------------------------------------------------------------------------}
function TCrpeEngineVersion.GetMajor : integer;
begin
  Result := FMajor;
  if (Cr = nil) then Exit;
  if Cr.hDLL = 0 then Exit;
  if FMajor < 5 then
    Cr.GetCRPEVersion;
  Result := FMajor;
end;
{------------------------------------------------------------------------------}
{ SetMajor                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeEngineVersion.SetMajor(const Value : integer);
begin
  {Read-only}
end;
{------------------------------------------------------------------------------}
{ GetMinor                                                                     }
{------------------------------------------------------------------------------}
function TCrpeEngineVersion.GetMinor : integer;
begin
  Result := FMinor;
  if (Cr = nil) then Exit;
  if Cr.hDLL = 0 then Exit;
  if FMajor < 5 then
    Cr.GetCRPEVersion;
  Result := FMinor;
end;
{------------------------------------------------------------------------------}
{ SetMinor                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeEngineVersion.SetMinor(const Value : integer);
begin
  {Read-only}
end;
{------------------------------------------------------------------------------}
{ GetRelease                                                                   }
{------------------------------------------------------------------------------}
function TCrpeEngineVersion.GetRelease : integer;
begin
  Result := FRelease;
  if (Cr = nil) then Exit;
  if Cr.hDLL = 0 then Exit;
  if FMajor < 5 then
    Cr.GetCRPEVersion;
  Result := FRelease;
end;
{------------------------------------------------------------------------------}
{ SetRelease                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeEngineVersion.SetRelease(const Value : integer);
begin
  {Read-only}
end;
{------------------------------------------------------------------------------}
{ GetBuild                                                                     }
{------------------------------------------------------------------------------}
function TCrpeEngineVersion.GetBuild : integer;
begin
  Result := FBuild;
  if (Cr = nil) then Exit;
  if Cr.hDLL = 0 then Exit;
  if FMajor < 5 then
    Cr.GetCRPEVersion;
  Result := FBuild;
end;
{------------------------------------------------------------------------------}
{ SetBuild                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeEngineVersion.SetBuild(const Value : integer);
begin
  {Read-only}
end;

{******************************************************************************}
{ TCrpeVersion Class Definition                                                }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeVersion.Create;
begin
  inherited Create;
  FCrpe    := TCrpeEngineVersion.Create;
  FSubClassList.Add(FCrpe);
  FReport  := TCrpeReportVersion.Create;
  FSubClassList.Add(FReport);
  FWindows := TCrpeWindowsVersion.Create;
  FSubClassList.Add(FWindows);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeVersion.Destroy;
begin
  FCrpe.Free;
  FReport.Free;
  FWindows.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeVersion.Clear;
begin
  FCrpe.Clear;
  FReport.Clear;
  FWindows.Clear;
end;


{******************************************************************************}
{ TCrpeWindowSize Class Definition                                             }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeWindowSize.Create;
begin
  inherited Create;
  {Set Defaults}
  FTop    := -1;
  FLeft   := -1;
  FWidth  := -1;
  FHeight := -1;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeWindowSize.Clear;
begin
  SetTop(-1);
  SetLeft(-1);
  SetWidth(-1);
  SetHeight(-1);
end;
{------------------------------------------------------------------------------}
{ GetTop                                                                       }
{------------------------------------------------------------------------------}
function TCrpeWindowSize.GetTop : Smallint;
var
  rSize   : TRect;
  wHandle : hWnd;
begin
  Result := FTop;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;
  wHandle := Cr.ReportWindowHandle;
  if wHandle = 0 then Exit;
  if Cr.FWindowParent = nil then
  begin
    if GetWindowRect(wHandle, rSize) then
      FTop := rSize.Top;
  end;
  Result := FTop;
end;
{------------------------------------------------------------------------------}
{ SetTop                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeWindowSize.SetTop(const Value: Smallint);
var
  curTop    : Integer;
  curLeft   : Integer;
  curWidth  : Integer;
  curHeight : Integer;
  rSize     : TRect;
  wHandle   : hWnd;
begin
  FTop := Value;
  if (Cr = nil) then Exit;
  wHandle := Cr.ReportWindowHandle;
  if wHandle = 0 then Exit;
  if GetWindowRect(wHandle, rSize) then
  begin
    curTop := rSize.Top;
    curHeight := rSize.Bottom - rSize.Top;
    curLeft := rSize.Left;
    curWidth := rSize.Right - rSize.Left;
    {Compare for changes}
    if (FTop > -1) and (FTop <> curTop) then
    begin
      curTop := FTop;
      {Set Window size and position}
      SetWindowPos(Cr.ReportWindowHandle, HWND_TOP, curLeft, curTop,
        curWidth, curHeight, SWP_NOZORDER);
    end;
  end;
end; { SetTop }
{------------------------------------------------------------------------------}
{ GetLeft                                                                      }
{------------------------------------------------------------------------------}
function TCrpeWindowSize.GetLeft : Smallint;
var
  rSize   : TRect;
  wHandle : hWnd;
begin
  Result := FLeft;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;
  wHandle := Cr.ReportWindowHandle;
  if wHandle = 0 then Exit;
  if Cr.FWindowParent = nil then
  begin
    if GetWindowRect(wHandle, rSize) then
      FLeft := rSize.Left;
  end;
  Result := FLeft;
end;
{------------------------------------------------------------------------------}
{ SetLeft                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeWindowSize.SetLeft(const Value : Smallint);
var
  curTop    : Integer;
  curLeft   : Integer;
  curWidth  : Integer;
  curHeight : Integer;
  rSize     : TRect;
  wHandle   : hWnd;
begin
  FLeft := Value;
  if (Cr = nil) then Exit;
  wHandle := Cr.ReportWindowHandle;
  if wHandle = 0 then Exit;
  if GetWindowRect(wHandle, rSize) then
  begin
    curTop := rSize.Top;
    curHeight := rSize.Bottom - rSize.Top;
    curLeft := rSize.Left;
    curWidth := rSize.Right - rSize.Left;
    {Compare for changes}
    if (FLeft > -1) and (FLeft <> curLeft) then
    begin
      curLeft := FLeft;
      {Set Window size and position}
      SetWindowPos(Cr.ReportWindowHandle, HWND_TOP, curLeft, curTop,
        curWidth, curHeight, SWP_NOZORDER);
    end;
  end;
end; { SetLeft }
{------------------------------------------------------------------------------}
{ GetWidth                                                                     }
{------------------------------------------------------------------------------}
function TCrpeWindowSize.GetWidth : Smallint;
var
  rSize   : TRect;
  wHandle : hWnd;
begin
  Result := FWidth;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;
  wHandle := Cr.ReportWindowHandle;
  if wHandle = 0 then Exit;
  if Cr.FWindowParent = nil then
  begin
    if GetWindowRect(wHandle, rSize) then
      FWidth := rSize.Right - rSize.Left;
  end;
  Result := FWidth;
end;
{------------------------------------------------------------------------------}
{ SetWidth                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeWindowSize.SetWidth(const Value: Smallint);
var
  curTop    : Integer;
  curLeft   : Integer;
  curWidth  : Integer;
  curHeight : Integer;
  rSize     : TRect;
  wHandle   : hWnd;
begin
  FWidth := Value;
  if (Cr = nil) then Exit;
  wHandle := Cr.ReportWindowHandle;
  if wHandle = 0 then Exit;
  if GetWindowRect(wHandle, rSize) then
  begin
    curTop := rSize.Top;
    curHeight := rSize.Bottom - rSize.Top;
    curLeft := rSize.Left;
    curWidth := rSize.Right - rSize.Left;
    {Compare for changes}
    if (FWidth > -1) and (FWidth <> curWidth) then
    begin
      curWidth := FWidth;
      {Set Window size and position}
      SetWindowPos(Cr.ReportWindowHandle, HWND_TOP, curLeft, curTop,
        curWidth, curHeight, SWP_NOZORDER);
    end;
  end;
end; { SetWidth }
{------------------------------------------------------------------------------}
{ GetHeight                                                                    }
{------------------------------------------------------------------------------}
function TCrpeWindowSize.GetHeight : Smallint;
var
  rSize   : TRect;
  wHandle : hWnd;
begin
  Result := FHeight;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;
  wHandle := Cr.ReportWindowHandle;
  if wHandle = 0 then Exit;
  if Cr.FWindowParent = nil then
  begin
    if GetWindowRect(wHandle, rSize) then
      FHeight := rSize.Bottom - rSize.Top;
  end;
  Result := FHeight;
end;
{------------------------------------------------------------------------------}
{ SetHeight                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeWindowSize.SetHeight(const Value : Smallint);
var
  curTop    : Integer;
  curLeft   : Integer;
  curWidth  : Integer;
  curHeight : Integer;
  rSize     : TRect;
  wHandle   : hWnd;
begin
  FHeight := Value;
  if (Cr = nil) then Exit;
  wHandle := Cr.ReportWindowHandle;
  if wHandle = 0 then Exit;
  if GetWindowRect(wHandle, rSize) then
  begin
    curTop := rSize.Top;
    curHeight := rSize.Bottom - rSize.Top;
    curLeft := rSize.Left;
    curWidth := rSize.Right - rSize.Left;
    {Compare for changes}
    if (FHeight > -1) and (FHeight <> curHeight) then
    begin
      curHeight := FHeight;
      {Set Window size and position}
      SetWindowPos(Cr.ReportWindowHandle, HWND_TOP, curLeft, curTop,
        curWidth, curHeight, SWP_NOZORDER);
    end;
  end;
end; { SetHeight }


{******************************************************************************}
{ TCrpeWindowZoom Class Definition                                             }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeWindowZoom.Create;
begin
  inherited Create;
  FPreview := pwDefault;
  FMagnification := -1;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeWindowZoom.Clear;
begin
  SetPreview(pwDefault);
  SetMagnification(-1);
end;
{------------------------------------------------------------------------------}
{ NextLevel                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeWindowZoom.NextLevel;
begin
  case FPreview of
    pwDefault   : FPreview := pwNormal;
    pwNormal    : FPreview := pwPageWidth;
    pwPageWidth : FPreview := pwWholePage;
    pwWholePage : FPreview := pwNormal;
  end;
  if (Cr = nil) then Exit;
  if Cr.ReportWindowHandle = 0 then Exit;

  
  if not Cr.FCrpeEngine.PENextPrintWindowMagnification(Cr.FPrintJob) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'WindowZoom.NextLevel <PENextPrintWindowMagnification>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetPreview                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeWindowZoom.SetPreview(const Value: TCrZoomPreview);
var
  iZoom : integer;
begin
  FPreview := Value;
  if FPreview = pwDefault then Exit;
  FMagnification := Ord(Value);
  if (Cr = nil) then Exit;
  {If Window is open...}
  if Cr.ReportWindowHandle > 0 then
  begin
    iZoom := Ord(FPreview);
    
    if not Cr.FCrpeEngine.PEZoomPreviewWindow(Cr.FPrintJob, iZoom) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowZoom.SetPreview <PEZoomPreviewWindow>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetMagnification                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeWindowZoom.SetMagnification(const Value: TCrZoomMagnification);
begin
  FMagnification := Value;
  if (Cr = nil) then Exit;
  case Value of
    -1      : {Default: do nothing};
    0..2    : SetPreview(TCrZoomPreview(Value));
    3..24   : SetPreview(pwDefault); {ignored}
    25..400 : {Set Zoom Level}
    begin
      {If Window is open...}
      if Cr.ReportWindowHandle > 0 then
      begin
        {Set Zoom Level}
        
        if not Cr.FCrpeEngine.PEZoomPreviewWindow(Cr.FPrintJob, FMagnification) then
        begin
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'WindowZoom.SetMagnification <PEZoomPreviewWindow>') of
            errIgnore : Exit;
            errAbort  : Abort;
            errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
      end;
    end;
  end;
end;


{******************************************************************************}
{ TCrpeWindowStyle Class Definition                                            }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeWindowStyle.Create;
begin
  inherited Create;
  {Set Defaults}
  FTitle       := '';
  FSystemMenu  := True;
  FMaxButton   := True;
  FMinButton   := True;
  FBorderStyle := bsSizeable;
  FDisabled    := False;
  FMDIForm     := nil;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeWindowStyle.Clear;
begin
  SetTitle('');
  FSystemMenu := True;
  FMaxButton := True;
  FMinButton := True;
  FBorderStyle := bsSizeable;
  SetDisabled(False);
  if FMDIForm <> nil then
  begin
    FMDIForm.Free;
    FMDIForm := nil;
  end;
end;
{------------------------------------------------------------------------------}
{ SetTitle                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeWindowStyle.SetTitle(const Value: string);
begin
  FTitle := Value;
  if (Cr = nil) then Exit;
  if Cr.ReportWindowHandle > 0 then
  begin
    if (FMDIForm <> nil) and (FMDIForm is TForm) then
      FMDIForm.Caption := FTitle
    else
      SetWindowText(Cr.ReportWindowHandle, PChar(FTitle));
  end;
end;
{------------------------------------------------------------------------------}
{ SetDisabled                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeWindowStyle.SetDisabled(const Value: Boolean);
var
  bTmp: Bool;
begin
  FDisabled := Value;
  bTmp := not FDisabled;
  if (Cr = nil) then Exit;
  if Cr.ReportWindowHandle > 0 then
    EnableWindow(Cr.ReportWindowHandle, bTmp);
end;
{------------------------------------------------------------------------------}
{ Procedure OnMDIResize                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeWindowStyle.OnMDIResize(Sender: TObject);
begin
  if (Cr = nil) then Exit;
  if Cr.ReportWindowHandle > 0 then
  begin
    SetWindowPos(Cr.ReportWindowHandle, HWND_TOP, 0, 0,
      FMDIForm.ClientWidth, FMDIForm.ClientHeight, SWP_NOZORDER);
  end;
end;
{------------------------------------------------------------------------------}
{ Procedure OnMDIClose                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeWindowStyle.OnMDIClose(Sender: TObject; var Action: TCloseAction);
begin
  if (FMDIForm <> nil) and (FMDIForm is TForm) then
  begin
    if (Cr <> nil) then
      Cr.CloseWindow;
    FMDIForm.Release;
    FMDIForm := nil;
  end;
end;


{******************************************************************************}
{ TCrpeWindowButtonBar Class Definition                                        }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeWindowButtonBar.Create;
begin
  inherited Create;
  FVisible        := True;
  FAllowDrillDown := False;
  FCancelBtn      := False;
  FCloseBtn       := False;
  FExportBtn      := True;
  FGroupTree      := False;
  FNavigationCtls := True;
  FPrintBtn       := True;
  FPrintSetupBtn  := False;
  FProgressCtls   := True;
  FRefreshBtn     := False;
  FSearchBtn      := False;
  FZoomCtl        := True;
  FToolbarTips    := True;
  FDocumentTips   := False;
  FLaunchBtn      := False;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.Clear;
begin
  SetVisible(True);
  SetAllowDrillDown(False);
  SetCancelBtn(False);
  SetCloseBtn(False);
  SetExportBtn(True);
  SetGroupTree(False);
  SetNavigationCtls(True);
  SetPrintBtn(True);
  SetPrintSetupBtn(False);
  SetProgressCtls(True);
  SetRefreshBtn(False);
  SetSearchBtn(False);
  SetZoomCtl(True);
  SetToolbarTips(True);
  SetDocumentTips(False);
  SetLaunchBtn(False);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.ActivateAll;
begin
  SetVisible(True);
  SetAllowDrillDown(True);
  SetCancelBtn(True);
  SetCloseBtn(True);
  SetExportBtn(True);
  SetGroupTree(True);
  SetNavigationCtls(True);
  SetPrintBtn(True);
  SetPrintSetupBtn(True);
  SetProgressCtls(True);
  SetRefreshBtn(True);
  SetSearchBtn(True);
  SetZoomCtl(True);
  SetToolbarTips(True);
  SetDocumentTips(True);
  SetLaunchBtn(True);
end;
{------------------------------------------------------------------------------}
{ Send                                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.Send;
begin
  SetVisible(FVisible);
  SetAllowDrillDown(FAllowDrillDown);
  SetCancelBtn(FCancelBtn);
  SetCloseBtn(FCloseBtn);
  SetExportBtn(FExportBtn);
  SetGroupTree(FGroupTree);
  SetNavigationCtls(FNavigationCtls);
  SetPrintBtn(FPrintBtn);
  SetPrintSetupBtn(FPrintSetupBtn);
  SetProgressCtls(FProgressCtls);
  SetRefreshBtn(FRefreshBtn);
  SetSearchBtn(FSearchBtn);
  SetZoomCtl(FZoomCtl);
  SetToolbarTips(FToolbarTips);
  SetDocumentTips(FDocumentTips);
  SetLaunchBtn(FLaunchBtn);
end;
{------------------------------------------------------------------------------}
{ GetVisible                                                                   }
{------------------------------------------------------------------------------}
function TCrpeWindowButtonBar.GetVisible : Boolean;
var
  bShow : LongBool;  //WinAPI: BOOL
begin
  Result := FVisible;
  if (Cr = nil) then Exit;
  {If the Window is open...}
  if Cr.ReportWindowHandle > 0 then
  begin
    
    {Check if ButtonBar is Visible}
    if not Cr.FCrpeEngine.PEPrintControlsShowing(Cr.FPrintJob, bShow) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.GetVisible <PEPrintControlsShowing>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    FVisible := Boolean(bShow);
    Result := FVisible;
  end;
end;
{------------------------------------------------------------------------------}
{ SetVisible                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.SetVisible(const Value: Boolean);
begin
  FVisible := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {ButtonBar Visible}
  
  if not Cr.FCrpeEngine.PEShowPrintControls(Cr.FPrintJob, BOOL(FVisible)) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'WindowButtonBar.SetVisible <PEShowPrintControls>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetAllowDrillDown                                                            }
{------------------------------------------------------------------------------}
function TCrpeWindowButtonBar.GetAllowDrillDown : Boolean;
var
  WindowOptions : PEWindowOptions;
begin
  Result := FAllowDrillDown;
  if (Cr = nil) then Exit;
  {Only if the Window is open...}
  if Cr.ReportWindowHandle = 0 then Exit;

  {Check which Buttons are showing}
  
  if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'WindowButtonBar.GetAllowDrillDown <PEGetWindowOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FAllowDrillDown := Boolean(WindowOptions.CanDrillDown);
  Result := FAllowDrillDown;
end;
{------------------------------------------------------------------------------}
{ SetAllowDrillDown                                                            }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.SetAllowDrillDown(const Value: Boolean);
var
  WindowOptions   : PEWindowOptions;
  bAllowDrillDown : Boolean;
  Changed         : Boolean;
begin
  FAllowDrillDown := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  Changed := True;

  {If the Window is open...}
  if Cr.ReportWindowHandle > 0 then
  begin
    Changed := False;
    {Check which Buttons are showing}
    
    if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetAllowDrillDown <PEGetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    bAllowDrillDown := Boolean(WindowOptions.CanDrillDown);
    if FAllowDrillDown <> bAllowDrillDown then
    begin
      WindowOptions.CanDrillDown := Smallint(FAllowDrillDown);
      Changed := True;
    end;
  end
  else
  begin
    WindowOptions.hasGroupTree := Smallint(FGroupTree);
    WindowOptions.CanDrillDown := Smallint(FAllowDrillDown);
    WindowOptions.hasNavigationControls := Smallint(FNavigationCtls);
    WindowOptions.hasCancelButton := Smallint(FCancelBtn);
    WindowOptions.hasPrintButton := Smallint(FPrintBtn);
    WindowOptions.hasExportButton := Smallint(FExportBtn);
    WindowOptions.hasZoomControl := Smallint(FZoomCtl);
    WindowOptions.hasCloseButton := Smallint(FCloseBtn);
    WindowOptions.hasProgressControls := Smallint(FProgressCtls);
    WindowOptions.hasSearchButton := Smallint(FSearchBtn);
    WindowOptions.hasPrintSetupButton := Smallint(FPrintSetupBtn);
    WindowOptions.hasRefreshButton := Smallint(FRefreshBtn);
    WindowOptions.showToolbarTips := Smallint(FToolbarTips);
    WindowOptions.showDocumentTips := Smallint(FDocumentTips);
    WindowOptions.hasLaunchButton := Smallint(FLaunchBtn);
  end;

  if Changed then
  begin
    {Set Window Options}
    
    if not Cr.FCrpeEngine.PESetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetAllowDrillDown <PESetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetCancelBtn                                                                 }
{------------------------------------------------------------------------------}
function TCrpeWindowButtonBar.GetCancelBtn : Boolean;
var
  WindowOptions : PEWindowOptions;
begin
  Result := FCancelBtn;
  if (Cr = nil) then Exit;
  if Cr.ReportWindowHandle = 0 then Exit;

  {Check which Buttons are showing}
  
  if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'WindowButtonBar.GetCancelBtn <PEGetWindowOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FCancelBtn := Boolean(WindowOptions.hasCancelButton);
  Result := FCancelBtn;
end;
{------------------------------------------------------------------------------}
{ SetCancelBtn                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.SetCancelBtn(const Value: Boolean);
var
  WindowOptions : PEWindowOptions;
  bCancelBtn    : Boolean;
  Changed       : Boolean;
begin
  FCancelBtn := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  Changed := True;

  {If the Window is open...}
  if Cr.ReportWindowHandle > 0 then
  begin
    Changed := False;
    {Check which Buttons are showing}
    
    if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetCancelBtn <PEGetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    bCancelBtn := Boolean(WindowOptions.hasCancelButton);
    if FCancelBtn <> bCancelBtn then
    begin
      WindowOptions.hasCancelButton := Smallint(FCancelBtn);
      Changed := True;
    end;
  end
  else
  begin
    WindowOptions.hasGroupTree := Smallint(FGroupTree);
    WindowOptions.CanDrillDown := Smallint(FAllowDrillDown);
    WindowOptions.hasNavigationControls := Smallint(FNavigationCtls);
    WindowOptions.hasCancelButton := Smallint(FCancelBtn);
    WindowOptions.hasPrintButton := Smallint(FPrintBtn);
    WindowOptions.hasExportButton := Smallint(FExportBtn);
    WindowOptions.hasZoomControl := Smallint(FZoomCtl);
    WindowOptions.hasCloseButton := Smallint(FCloseBtn);
    WindowOptions.hasProgressControls := Smallint(FProgressCtls);
    WindowOptions.hasSearchButton := Smallint(FSearchBtn);
    WindowOptions.hasPrintSetupButton := Smallint(FPrintSetupBtn);
    WindowOptions.hasRefreshButton := Smallint(FRefreshBtn);
    WindowOptions.showToolbarTips := Smallint(FToolbarTips);
    WindowOptions.showDocumentTips := Smallint(FDocumentTips);
    WindowOptions.hasLaunchButton := Smallint(FLaunchBtn);
  end;

  if Changed then
  begin
    
    if not Cr.FCrpeEngine.PESetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetCancelBtn <PESetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetCloseBtn                                                                  }
{------------------------------------------------------------------------------}
function TCrpeWindowButtonBar.GetCloseBtn : Boolean;
var
  WindowOptions : PEWindowOptions;
begin
  Result := FCloseBtn;
  if (Cr = nil) then Exit;
  if Cr.ReportWindowHandle = 0 then Exit;

  {Check which Buttons are showing}
  
  if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'WindowButtonBar.GetCloseBtn <PEGetWindowOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FCloseBtn := Boolean(WindowOptions.hasCloseButton);
  Result := FCloseBtn;
end;
{------------------------------------------------------------------------------}
{ SetCloseBtn                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.SetCloseBtn(const Value: Boolean);
var
  WindowOptions : PEWindowOptions;
  bCloseBtn     : Boolean;
  Changed       : Boolean;
begin
  FCloseBtn := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  Changed := True;

  {If the Window is open...}
  if Cr.ReportWindowHandle > 0 then
  begin
    Changed := False;
    {Check which Buttons are showing}
    
    if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetCloseBtn <PEGetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    bCloseBtn := Boolean(WindowOptions.hasCloseButton);
    if FCloseBtn <> bCloseBtn then
    begin
      WindowOptions.hasCloseButton := Smallint(FCloseBtn);
      Changed := True;
    end;
  end
  else
  begin
    WindowOptions.hasGroupTree := Smallint(FGroupTree);
    WindowOptions.CanDrillDown := Smallint(FAllowDrillDown);
    WindowOptions.hasNavigationControls := Smallint(FNavigationCtls);
    WindowOptions.hasCancelButton := Smallint(FCancelBtn);
    WindowOptions.hasPrintButton := Smallint(FPrintBtn);
    WindowOptions.hasExportButton := Smallint(FExportBtn);
    WindowOptions.hasZoomControl := Smallint(FZoomCtl);
    WindowOptions.hasCloseButton := Smallint(FCloseBtn);
    WindowOptions.hasProgressControls := Smallint(FProgressCtls);
    WindowOptions.hasSearchButton := Smallint(FSearchBtn);
    WindowOptions.hasPrintSetupButton := Smallint(FPrintSetupBtn);
    WindowOptions.hasRefreshButton := Smallint(FRefreshBtn);
    WindowOptions.showToolbarTips := Smallint(FToolbarTips);
    WindowOptions.showDocumentTips := Smallint(FDocumentTips);
    WindowOptions.hasLaunchButton := Smallint(FLaunchBtn);
  end;

  if Changed then
  begin
    
    if not Cr.FCrpeEngine.PESetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetCloseBtn <PESetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetExportBtn                                                                 }
{------------------------------------------------------------------------------}
function TCrpeWindowButtonBar.GetExportBtn : Boolean;
var
  WindowOptions : PEWindowOptions;
begin
  Result := FExportBtn;
  if (Cr = nil) then Exit;
  {If the Window is open...}
  if (Cr.ReportWindowHandle = 0) then Exit;

  {Check which Buttons are showing}
  
  if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'WindowButtonBar.GetExportBtn <PEGetWindowOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FExportBtn := Boolean(WindowOptions.hasExportButton);
  Result := FExportBtn;
end;
{------------------------------------------------------------------------------}
{ SetExportBtn                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.SetExportBtn(const Value: Boolean);
var
  WindowOptions : PEWindowOptions;
  bExportBtn    : Boolean;
  Changed       : Boolean;
begin
  FExportBtn := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  Changed := True;

  {If the Window is open...}
  if Cr.ReportWindowHandle > 0 then
  begin
    Changed := False;
    {Check which Buttons are showing}
    
    if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetExportBtn <PEGetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    bExportBtn := Boolean(WindowOptions.hasExportButton);
    if FExportBtn <> bExportBtn then
    begin
      WindowOptions.hasExportButton := Smallint(FExportBtn);
      Changed := True;
    end;
  end
  else
  begin
    WindowOptions.hasGroupTree := Smallint(FGroupTree);
    WindowOptions.CanDrillDown := Smallint(FAllowDrillDown);
    WindowOptions.hasNavigationControls := Smallint(FNavigationCtls);
    WindowOptions.hasCancelButton := Smallint(FCancelBtn);
    WindowOptions.hasPrintButton := Smallint(FPrintBtn);
    WindowOptions.hasExportButton := Smallint(FExportBtn);
    WindowOptions.hasZoomControl := Smallint(FZoomCtl);
    WindowOptions.hasCloseButton := Smallint(FCloseBtn);
    WindowOptions.hasProgressControls := Smallint(FProgressCtls);
    WindowOptions.hasSearchButton := Smallint(FSearchBtn);
    WindowOptions.hasPrintSetupButton := Smallint(FPrintSetupBtn);
    WindowOptions.hasRefreshButton := Smallint(FRefreshBtn);
    WindowOptions.showToolbarTips := Smallint(FToolbarTips);
    WindowOptions.showDocumentTips := Smallint(FDocumentTips);
    WindowOptions.hasLaunchButton := Smallint(FLaunchBtn);
  end;

  if Changed then
  begin
    
    if not Cr.FCrpeEngine.PESetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetExportBtn <PESetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetGroupTree                                                                 }
{------------------------------------------------------------------------------}
function TCrpeWindowButtonBar.GetGroupTree : Boolean;
var
  WindowOptions : PEWindowOptions;
begin
  Result := FGroupTree;
  if (Cr = nil) then Exit;
  if (Cr.ReportWindowHandle = 0) then Exit;

  {Check which Buttons are showing}
  
  if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'WindowButtonBar.GetGroupTree <PEGetWindowOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FGroupTree := Boolean(WindowOptions.hasGroupTree);
  Result := FGroupTree;
end;
{------------------------------------------------------------------------------}
{ SetGroupTree                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.SetGroupTree(const Value: Boolean);
var
  WindowOptions : PEWindowOptions;
  bGroupTree    : Boolean;
  Changed       : Boolean;
begin
  FGroupTree := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  Changed := True;

  {If the Window is open...}
  if Cr.ReportWindowHandle > 0 then
  begin
    Changed := False;
    {Check which Buttons are showing}
    
    if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetGroupTree <PEGetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    bGroupTree := Boolean(WindowOptions.hasGroupTree);
    if FGroupTree <> bGroupTree then
    begin
      WindowOptions.hasGroupTree := Smallint(FGroupTree);
      Changed := True;
    end;
  end
  else
  begin
    WindowOptions.hasGroupTree := Smallint(FGroupTree);
    WindowOptions.CanDrillDown := Smallint(FAllowDrillDown);
    WindowOptions.hasNavigationControls := Smallint(FNavigationCtls);
    WindowOptions.hasCancelButton := Smallint(FCancelBtn);
    WindowOptions.hasPrintButton := Smallint(FPrintBtn);
    WindowOptions.hasExportButton := Smallint(FExportBtn);
    WindowOptions.hasZoomControl := Smallint(FZoomCtl);
    WindowOptions.hasCloseButton := Smallint(FCloseBtn);
    WindowOptions.hasProgressControls := Smallint(FProgressCtls);
    WindowOptions.hasSearchButton := Smallint(FSearchBtn);
    WindowOptions.hasPrintSetupButton := Smallint(FPrintSetupBtn);
    WindowOptions.hasRefreshButton := Smallint(FRefreshBtn);
    WindowOptions.showToolbarTips := Smallint(FToolbarTips);
    WindowOptions.showDocumentTips := Smallint(FDocumentTips);
    WindowOptions.hasLaunchButton := Smallint(FLaunchBtn);
  end;

  if Changed then
  begin
    
    if not Cr.FCrpeEngine.PESetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetGroupTree <PESetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetNavigationCtls                                                            }
{------------------------------------------------------------------------------}
function TCrpeWindowButtonBar.GetNavigationCtls : Boolean;
var
  WindowOptions : PEWindowOptions;
begin
  Result := FNavigationCtls;
  if (Cr = nil) then Exit;
  if (Cr.ReportWindowHandle = 0) then Exit;

  {Check which Buttons are showing}
  
  if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'WindowButtonBar.GetNavigationCtls <PEGetWindowOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FNavigationCtls := Boolean(WindowOptions.hasNavigationControls);
  Result := FNavigationCtls;
end;
{------------------------------------------------------------------------------}
{ SetNavigationCtls                                                            }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.SetNavigationCtls(const Value: Boolean);
var
  WindowOptions   : PEWindowOptions;
  bNavigationCtls : Boolean;
  Changed         : Boolean;
begin
  FNavigationCtls := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  Changed := True;

  {If the Window is open...}
  if Cr.ReportWindowHandle > 0 then
  begin
    Changed := False;
    {Check which Buttons are showing}
    
    if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetNavigationCtls <PEGetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    bNavigationCtls := Boolean(WindowOptions.hasNavigationControls);
    if FNavigationCtls <> bNavigationCtls then
    begin
      WindowOptions.hasNavigationControls := Smallint(FNavigationCtls);
      Changed := True;
    end;
  end
  else
  begin
    WindowOptions.hasGroupTree := Smallint(FGroupTree);
    WindowOptions.CanDrillDown := Smallint(FAllowDrillDown);
    WindowOptions.hasNavigationControls := Smallint(FNavigationCtls);
    WindowOptions.hasCancelButton := Smallint(FCancelBtn);
    WindowOptions.hasPrintButton := Smallint(FPrintBtn);
    WindowOptions.hasExportButton := Smallint(FExportBtn);
    WindowOptions.hasZoomControl := Smallint(FZoomCtl);
    WindowOptions.hasCloseButton := Smallint(FCloseBtn);
    WindowOptions.hasProgressControls := Smallint(FProgressCtls);
    WindowOptions.hasSearchButton := Smallint(FSearchBtn);
    WindowOptions.hasPrintSetupButton := Smallint(FPrintSetupBtn);
    WindowOptions.hasRefreshButton := Smallint(FRefreshBtn);
    WindowOptions.showToolbarTips := Smallint(FToolbarTips);
    WindowOptions.showDocumentTips := Smallint(FDocumentTips);
    WindowOptions.hasLaunchButton := Smallint(FLaunchBtn);
  end;

  if Changed then
  begin
    
    if not Cr.FCrpeEngine.PESetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetNavigationCtls <PESetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetPrintBtn                                                                  }
{------------------------------------------------------------------------------}
function TCrpeWindowButtonBar.GetPrintBtn : Boolean;
var
  WindowOptions : PEWindowOptions;
begin
  Result := FPrintBtn;
  if (Cr = nil) then Exit;
  if (Cr.ReportWindowHandle = 0) then Exit;

  {Check which Buttons are showing}
  
  if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'WindowButtonBar.GetPrintBtn <PEGetWindowOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FPrintBtn := Boolean(WindowOptions.hasPrintButton);
  Result := FPrintBtn;
end;
{------------------------------------------------------------------------------}
{ SetPrintBtn                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.SetPrintBtn(const Value: Boolean);
var
  WindowOptions : PEWindowOptions;
  bPrintBtn     : Boolean;
  Changed       : Boolean;
begin
  FPrintBtn := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  Changed := True;

  {If the Window is open...}
  if Cr.ReportWindowHandle > 0 then
  begin
    Changed := False;
    
    {Check which Buttons are showing}
    if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetPrintBtn <PEGetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    bPrintBtn := Boolean(WindowOptions.hasPrintButton);
    if FPrintBtn <> bPrintBtn then
    begin
      WindowOptions.hasPrintButton := Smallint(FPrintBtn);
      Changed := True;
    end;
  end
  else
  begin
    WindowOptions.hasGroupTree := Smallint(FGroupTree);
    WindowOptions.CanDrillDown := Smallint(FAllowDrillDown);
    WindowOptions.hasNavigationControls := Smallint(FNavigationCtls);
    WindowOptions.hasCancelButton := Smallint(FCancelBtn);
    WindowOptions.hasPrintButton := Smallint(FPrintBtn);
    WindowOptions.hasExportButton := Smallint(FExportBtn);
    WindowOptions.hasZoomControl := Smallint(FZoomCtl);
    WindowOptions.hasCloseButton := Smallint(FCloseBtn);
    WindowOptions.hasProgressControls := Smallint(FProgressCtls);
    WindowOptions.hasSearchButton := Smallint(FSearchBtn);
    WindowOptions.hasPrintSetupButton := Smallint(FPrintSetupBtn);
    WindowOptions.hasRefreshButton := Smallint(FRefreshBtn);
    WindowOptions.showToolbarTips := Smallint(FToolbarTips);
    WindowOptions.showDocumentTips := Smallint(FDocumentTips);
    WindowOptions.hasLaunchButton := Smallint(FLaunchBtn);
  end;

  if Changed then
  begin
    
    if not Cr.FCrpeEngine.PESetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetPrintBtn <PESetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetPrintSetupBtn                                                             }
{------------------------------------------------------------------------------}
function TCrpeWindowButtonBar.GetPrintSetupBtn : Boolean;
var
  WindowOptions : PEWindowOptions;
begin
  Result := FPrintSetupBtn;
  if (Cr = nil) then Exit;
  if (Cr.ReportWindowHandle = 0) then Exit;

  {Check which Buttons are showing}
  
  if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'WindowButtonBar.GetPrintSetupBtn <PEGetWindowOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FPrintSetupBtn := Boolean(WindowOptions.hasPrintSetupButton);
  Result := FPrintSetupBtn;
end;
{------------------------------------------------------------------------------}
{ SetPrintSetupBtn                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.SetPrintSetupBtn(const Value: Boolean);
var
  WindowOptions   : PEWindowOptions;
  bPrintSetupBtn  : Boolean;
  Changed         : Boolean;
begin
  FPrintSetupBtn := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  Changed := True;

  {If the Window is open...}
  if Cr.ReportWindowHandle > 0 then
  begin
    Changed := False;
    {Check which Buttons are showing}
    
    if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetPrintSetupBtn <PEGetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    bPrintSetupBtn := Boolean(WindowOptions.hasPrintSetupButton);
    if FPrintSetupBtn <> bPrintSetupBtn then
    begin
      WindowOptions.hasPrintSetupButton := Smallint(FPrintSetupBtn);
      Changed := True;
    end;
  end
  else
  begin
    WindowOptions.hasGroupTree := Smallint(FGroupTree);
    WindowOptions.CanDrillDown := Smallint(FAllowDrillDown);
    WindowOptions.hasNavigationControls := Smallint(FNavigationCtls);
    WindowOptions.hasCancelButton := Smallint(FCancelBtn);
    WindowOptions.hasPrintButton := Smallint(FPrintBtn);
    WindowOptions.hasExportButton := Smallint(FExportBtn);
    WindowOptions.hasZoomControl := Smallint(FZoomCtl);
    WindowOptions.hasCloseButton := Smallint(FCloseBtn);
    WindowOptions.hasProgressControls := Smallint(FProgressCtls);
    WindowOptions.hasSearchButton := Smallint(FSearchBtn);
    WindowOptions.hasPrintSetupButton := Smallint(FPrintSetupBtn);
    WindowOptions.hasRefreshButton := Smallint(FRefreshBtn);
    WindowOptions.showToolbarTips := Smallint(FToolbarTips);
    WindowOptions.showDocumentTips := Smallint(FDocumentTips);
    WindowOptions.hasLaunchButton := Smallint(FLaunchBtn);
  end;

  if Changed then
  begin
    
    if not Cr.FCrpeEngine.PESetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetPrintSetupBtn <PESetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetProgressCtls                                                              }
{------------------------------------------------------------------------------}
function TCrpeWindowButtonBar.GetProgressCtls : Boolean;
var
  WindowOptions : PEWindowOptions;
begin
  Result := FProgressCtls;
  if (Cr = nil) then Exit;
  {If the Window is open...}
  if (Cr.ReportWindowHandle = 0) then Exit;

  {Check which Buttons are showing}
  
  if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'WindowButtonBar.GetProgressCtls <PEGetWindowOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FProgressCtls := Boolean(WindowOptions.hasProgressControls);
  Result := FProgressCtls;
end;
{------------------------------------------------------------------------------}
{ SetProgressCtls                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.SetProgressCtls(const Value: Boolean);
var
  WindowOptions : PEWindowOptions;
  bProgressCtls : Boolean;
  Changed       : Boolean;
begin
  FProgressCtls := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  Changed := True;

  {If the Window is open...}
  if Cr.ReportWindowHandle > 0 then
  begin
    Changed := False;
    {Check which Buttons are showing}
    
    if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetProgressCtls <PEGetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    bProgressCtls := Boolean(WindowOptions.hasProgressControls);
    if FProgressCtls <> bProgressCtls then
    begin
      WindowOptions.hasProgressControls := Smallint(FProgressCtls);
      Changed := True;
    end;
  end
  else
  begin
    WindowOptions.hasGroupTree := Smallint(FGroupTree);
    WindowOptions.CanDrillDown := Smallint(FAllowDrillDown);
    WindowOptions.hasNavigationControls := Smallint(FNavigationCtls);
    WindowOptions.hasCancelButton := Smallint(FCancelBtn);
    WindowOptions.hasPrintButton := Smallint(FPrintBtn);
    WindowOptions.hasExportButton := Smallint(FExportBtn);
    WindowOptions.hasZoomControl := Smallint(FZoomCtl);
    WindowOptions.hasCloseButton := Smallint(FCloseBtn);
    WindowOptions.hasProgressControls := Smallint(FProgressCtls);
    WindowOptions.hasSearchButton := Smallint(FSearchBtn);
    WindowOptions.hasPrintSetupButton := Smallint(FPrintSetupBtn);
    WindowOptions.hasRefreshButton := Smallint(FRefreshBtn);
    WindowOptions.showToolbarTips := Smallint(FToolbarTips);
    WindowOptions.showDocumentTips := Smallint(FDocumentTips);
    WindowOptions.hasLaunchButton := Smallint(FLaunchBtn);
  end;

  if Changed then
  begin
    
    if not Cr.FCrpeEngine.PESetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetProgressCtls <PESetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetRefreshBtn                                                                }
{------------------------------------------------------------------------------}
function TCrpeWindowButtonBar.GetRefreshBtn : Boolean;
var
  WindowOptions : PEWindowOptions;
begin
  Result := FRefreshBtn;
  if (Cr = nil) then Exit;
  if (Cr.ReportWindowHandle = 0) then Exit;

  {Check which Buttons are showing}
  
  if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'WindowButtonBar.GetRefreshBtn <PEGetWindowOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FRefreshBtn := Boolean(WindowOptions.hasRefreshButton);
  Result := FRefreshBtn;
end;
{------------------------------------------------------------------------------}
{ SetRefreshBtn                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.SetRefreshBtn(const Value: Boolean);
var
  WindowOptions   : PEWindowOptions;
  bRefreshBtn     : Boolean;
  Changed         : Boolean;
begin
  FRefreshBtn := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  Changed := True;

  {If the Window is open...}
  if Cr.ReportWindowHandle > 0 then
  begin
    Changed := False;
    
    {Check which Buttons are showing}
    if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetRefreshBtn <PEGetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    bRefreshBtn := Boolean(WindowOptions.hasRefreshButton);

    if FRefreshBtn <> bRefreshBtn then
    begin
      WindowOptions.hasRefreshButton := Smallint(FRefreshBtn);
      Changed := True;
    end;
  end
  else
  begin
    WindowOptions.hasGroupTree := Smallint(FGroupTree);
    WindowOptions.CanDrillDown := Smallint(FAllowDrillDown);
    WindowOptions.hasNavigationControls := Smallint(FNavigationCtls);
    WindowOptions.hasCancelButton := Smallint(FCancelBtn);
    WindowOptions.hasPrintButton := Smallint(FPrintBtn);
    WindowOptions.hasExportButton := Smallint(FExportBtn);
    WindowOptions.hasZoomControl := Smallint(FZoomCtl);
    WindowOptions.hasCloseButton := Smallint(FCloseBtn);
    WindowOptions.hasProgressControls := Smallint(FProgressCtls);
    WindowOptions.hasSearchButton := Smallint(FSearchBtn);
    WindowOptions.hasPrintSetupButton := Smallint(FPrintSetupBtn);
    WindowOptions.hasRefreshButton := Smallint(FRefreshBtn);
    WindowOptions.showToolbarTips := Smallint(FToolbarTips);
    WindowOptions.showDocumentTips := Smallint(FDocumentTips);
    WindowOptions.hasLaunchButton := Smallint(FLaunchBtn);
  end;

  if Changed then
  begin
    
    if not Cr.FCrpeEngine.PESetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetRefreshBtn <PESetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetSearchBtn                                                                 }
{------------------------------------------------------------------------------}
function TCrpeWindowButtonBar.GetSearchBtn : Boolean;
var
  WindowOptions : PEWindowOptions;
begin
  Result := FSearchBtn;
  if (Cr = nil) then Exit;
  if (Cr.ReportWindowHandle = 0) then Exit;

  {Check which Buttons are showing}
  
  if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'WindowButtonBar.GetSearchBtn <PEGetWindowOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FSearchBtn := Boolean(WindowOptions.hasSearchButton);
  Result := FSearchBtn;
end;
{------------------------------------------------------------------------------}
{ SetSearchBtn                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.SetSearchBtn(const Value: Boolean);
var
  WindowOptions : PEWindowOptions;
  bSearchBtn    : Boolean;
  Changed       : Boolean;
begin
  FSearchBtn := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  Changed := True;

  {If the Window is open...}
  if Cr.ReportWindowHandle > 0 then
  begin
    Changed := False;
    
    {Check which Buttons are showing}
    if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetSearchBtn <PEGetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    bSearchBtn := Boolean(WindowOptions.hasSearchButton);
    if FSearchBtn <> bSearchBtn then
    begin
      WindowOptions.hasSearchButton := Smallint(FSearchBtn);
      Changed := True;
    end;
  end
  else
  begin
    WindowOptions.hasGroupTree := Smallint(FGroupTree);
    WindowOptions.CanDrillDown := Smallint(FAllowDrillDown);
    WindowOptions.hasNavigationControls := Smallint(FNavigationCtls);
    WindowOptions.hasCancelButton := Smallint(FCancelBtn);
    WindowOptions.hasPrintButton := Smallint(FPrintBtn);
    WindowOptions.hasExportButton := Smallint(FExportBtn);
    WindowOptions.hasZoomControl := Smallint(FZoomCtl);
    WindowOptions.hasCloseButton := Smallint(FCloseBtn);
    WindowOptions.hasProgressControls := Smallint(FProgressCtls);
    WindowOptions.hasSearchButton := Smallint(FSearchBtn);
    WindowOptions.hasPrintSetupButton := Smallint(FPrintSetupBtn);
    WindowOptions.hasRefreshButton := Smallint(FRefreshBtn);
    WindowOptions.showToolbarTips := Smallint(FToolbarTips);
    WindowOptions.showDocumentTips := Smallint(FDocumentTips);
    WindowOptions.hasLaunchButton := Smallint(FLaunchBtn);
  end;

  if Changed then
  begin
    
    if not Cr.FCrpeEngine.PESetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetSearchBtn <PESetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetZoomCtl                                                                   }
{------------------------------------------------------------------------------}
function TCrpeWindowButtonBar.GetZoomCtl : Boolean;
var
  WindowOptions : PEWindowOptions;
begin
  Result := FZoomCtl;
  if (Cr = nil) then Exit;
  if (Cr.ReportWindowHandle = 0) then Exit;

  {Check which Buttons are showing}
  
  if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'WindowButtonBar.GetZoomCtl <PEGetWindowOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FZoomCtl := Boolean(WindowOptions.hasZoomControl);
  Result := FZoomCtl;
end;
{------------------------------------------------------------------------------}
{ SetZoomCtl                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.SetZoomCtl(const Value: Boolean);
var
  WindowOptions : PEWindowOptions;
  bZoomCtl      : Boolean;
  Changed       : Boolean;
begin
  FZoomCtl := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  Changed := True;

  {If the Window is open...}
  if Cr.ReportWindowHandle > 0 then
  begin
    Changed := False;
    {Check which Buttons are showing}
    
    if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetZoomCtl <PEGetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    bZoomCtl := Boolean(WindowOptions.hasZoomControl);
    if FZoomCtl <> bZoomCtl then
    begin
      WindowOptions.hasZoomControl := Smallint(FZoomCtl);
      Changed := True;
    end;
  end
  else
  begin
    WindowOptions.hasGroupTree := Smallint(FGroupTree);
    WindowOptions.CanDrillDown := Smallint(FAllowDrillDown);
    WindowOptions.hasNavigationControls := Smallint(FNavigationCtls);
    WindowOptions.hasCancelButton := Smallint(FCancelBtn);
    WindowOptions.hasPrintButton := Smallint(FPrintBtn);
    WindowOptions.hasExportButton := Smallint(FExportBtn);
    WindowOptions.hasZoomControl := Smallint(FZoomCtl);
    WindowOptions.hasCloseButton := Smallint(FCloseBtn);
    WindowOptions.hasProgressControls := Smallint(FProgressCtls);
    WindowOptions.hasSearchButton := Smallint(FSearchBtn);
    WindowOptions.hasPrintSetupButton := Smallint(FPrintSetupBtn);
    WindowOptions.hasRefreshButton := Smallint(FRefreshBtn);
    WindowOptions.showToolbarTips := Smallint(FToolbarTips);
    WindowOptions.showDocumentTips := Smallint(FDocumentTips);
    WindowOptions.hasLaunchButton := Smallint(FLaunchBtn);
  end;

  if Changed then
  begin
    
    if not Cr.FCrpeEngine.PESetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetZoomCtl <PESetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetToolbarTips                                                               }
{------------------------------------------------------------------------------}
function TCrpeWindowButtonBar.GetToolbarTips : Boolean;
var
  WindowOptions : PEWindowOptions;
begin
  Result := FToolbarTips;
  if (Cr = nil) then Exit;
  if (Cr.ReportWindowHandle = 0) then Exit;

  {Check which Buttons are showing}
  
  if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'WindowButtonBar.GetToolbarTips <PEGetWindowOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FToolbarTips := Boolean(WindowOptions.showToolbarTips);
  Result := FToolbarTips;
end;
{------------------------------------------------------------------------------}
{ SetToolbarTips                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.SetToolbarTips(const Value: Boolean);
var
  WindowOptions : PEWindowOptions;
  bToolbarTips  : Boolean;
  Changed       : Boolean;
begin
  FToolbarTips := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then  Exit;
  Changed := True;

  {If the Window is open...}
  if Cr.ReportWindowHandle > 0 then
  begin
    Changed := False;
    {Check which Buttons are showing}
    
    if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetToolbarTips <PEGetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    bToolbarTips := Boolean(WindowOptions.showToolbarTips);

    if FToolbarTips <> bToolbarTips then
    begin
      WindowOptions.showToolbarTips := Smallint(FToolbarTips);
      Changed := True;
    end;
  end
  else
  begin
    WindowOptions.hasGroupTree := Smallint(FGroupTree);
    WindowOptions.CanDrillDown := Smallint(FAllowDrillDown);
    WindowOptions.hasNavigationControls := Smallint(FNavigationCtls);
    WindowOptions.hasCancelButton := Smallint(FCancelBtn);
    WindowOptions.hasPrintButton := Smallint(FPrintBtn);
    WindowOptions.hasExportButton := Smallint(FExportBtn);
    WindowOptions.hasZoomControl := Smallint(FZoomCtl);
    WindowOptions.hasCloseButton := Smallint(FCloseBtn);
    WindowOptions.hasProgressControls := Smallint(FProgressCtls);
    WindowOptions.hasSearchButton := Smallint(FSearchBtn);
    WindowOptions.hasPrintSetupButton := Smallint(FPrintSetupBtn);
    WindowOptions.hasRefreshButton := Smallint(FRefreshBtn);
    WindowOptions.showToolbarTips := Smallint(FToolbarTips);
    WindowOptions.showDocumentTips := Smallint(FDocumentTips);
    WindowOptions.hasLaunchButton := Smallint(FLaunchBtn);
  end;

  if Changed then
  begin
    
    if not Cr.FCrpeEngine.PESetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetToolbarTips <PESetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetDocumentTips                                                              }
{------------------------------------------------------------------------------}
function TCrpeWindowButtonBar.GetDocumentTips : Boolean;
var
  WindowOptions : PEWindowOptions;
begin
  Result := FDocumentTips;
  if (Cr = nil) then Exit;
  if (Cr.ReportWindowHandle = 0) then Exit;

  
  if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'WindowButtonBar.GetDocumentTips <PEGetWindowOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FDocumentTips := Boolean(WindowOptions.showDocumentTips);
  Result := FDocumentTips;
end;
{------------------------------------------------------------------------------}
{ SetDocumentTips                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.SetDocumentTips(const Value: Boolean);
var
  WindowOptions : PEWindowOptions;
  bDocumentTips : Boolean;
  Changed       : Boolean;
begin
  FDocumentTips := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  Changed := True;

  {If the Window is open...}
  if Cr.ReportWindowHandle > 0 then
  begin
    Changed := False;
    {Check which Buttons are showing}
    
    if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetDocumentTips <PEGetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    bDocumentTips := Boolean(WindowOptions.showDocumentTips);
    if FDocumentTips <> bDocumentTips then
    begin
      WindowOptions.showDocumentTips := Smallint(FDocumentTips);
      Changed := True;
    end;
  end
  else
  begin
    WindowOptions.hasGroupTree := Smallint(FGroupTree);
    WindowOptions.CanDrillDown := Smallint(FAllowDrillDown);
    WindowOptions.hasNavigationControls := Smallint(FNavigationCtls);
    WindowOptions.hasCancelButton := Smallint(FCancelBtn);
    WindowOptions.hasPrintButton := Smallint(FPrintBtn);
    WindowOptions.hasExportButton := Smallint(FExportBtn);
    WindowOptions.hasZoomControl := Smallint(FZoomCtl);
    WindowOptions.hasCloseButton := Smallint(FCloseBtn);
    WindowOptions.hasProgressControls := Smallint(FProgressCtls);
    WindowOptions.hasSearchButton := Smallint(FSearchBtn);
    WindowOptions.hasPrintSetupButton := Smallint(FPrintSetupBtn);
    WindowOptions.hasRefreshButton := Smallint(FRefreshBtn);
    WindowOptions.showToolbarTips := Smallint(FToolbarTips);
    WindowOptions.showDocumentTips := Smallint(FDocumentTips);
    WindowOptions.hasLaunchButton := Smallint(FLaunchBtn);
  end;

  if Changed then
  begin
    
    if not Cr.FCrpeEngine.PESetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetDocumentTips <PESetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetLaunchBtn                                                                 }
{------------------------------------------------------------------------------}
function TCrpeWindowButtonBar.GetLaunchBtn : Boolean;
var
  WindowOptions : PEWindowOptions;
begin
  Result := FLaunchBtn;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  if Cr.ReportWindowHandle = 0 then Exit;

  {Check which Buttons are showing}
  
  if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'WindowButtonBar.GetLaunchBtn <PEGetWindowOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  case WindowOptions.hasLaunchButton of
    0 : FLaunchBtn := False;
    1 : FLaunchBtn := True;
    else
      FLaunchBtn := False;
  end;
  Result := FLaunchBtn;
end;
{------------------------------------------------------------------------------}
{ SetLaunchBtn                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeWindowButtonBar.SetLaunchBtn (const Value: Boolean);
var
  WindowOptions : PEWindowOptions;
  bLaunchBtn    : Boolean;
  Changed       : Boolean;
begin
  FLaunchBtn := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  Changed := True;

  {If the Window is open...}
  if Cr.ReportWindowHandle > 0 then
  begin
    Changed := False;
    {Check which Buttons are showing}
    
    if not Cr.FCrpeEngine.PEGetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetLaunchBtn <PEGetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    case WindowOptions.hasLaunchButton of
      0 : bLaunchBtn := False;
      1 : bLaunchBtn := True;
      else
        bLaunchBtn := False;
    end;

    if FLaunchBtn <> bLaunchBtn then
    begin
      WindowOptions.hasLaunchButton := Smallint(FLaunchBtn);
      Changed := True;
    end;
  end
  else
  begin
    WindowOptions.hasGroupTree := Smallint(FGroupTree);
    WindowOptions.CanDrillDown := Smallint(FAllowDrillDown);
    WindowOptions.hasNavigationControls := Smallint(FNavigationCtls);
    WindowOptions.hasCancelButton := Smallint(FCancelBtn);
    WindowOptions.hasPrintButton := Smallint(FPrintBtn);
    WindowOptions.hasExportButton := Smallint(FExportBtn);
    WindowOptions.hasZoomControl := Smallint(FZoomCtl);
    WindowOptions.hasCloseButton := Smallint(FCloseBtn);
    WindowOptions.hasProgressControls := Smallint(FProgressCtls);
    WindowOptions.hasSearchButton := Smallint(FSearchBtn);
    WindowOptions.hasPrintSetupButton := Smallint(FPrintSetupBtn);
    WindowOptions.hasRefreshButton := Smallint(FRefreshBtn);
    WindowOptions.showToolbarTips := Smallint(FToolbarTips);
    WindowOptions.showDocumentTips := Smallint(FDocumentTips);
    WindowOptions.hasLaunchButton := Smallint(FLaunchBtn);
  end;

  if Changed then
  begin
    
    if not Cr.FCrpeEngine.PESetWindowOptions(Cr.FPrintJob, WindowOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowButtonBar.SetLaunchBtn <PESetWindowOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ TCrpeWindowCursor Class Definition                                           }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeWindowCursor.Create;
begin
  inherited Create;
  {Set Defaults}
  FGroupArea         := wcDefault;
  FGroupAreaField    := wcDefault;
  FDetailArea        := wcDefault;
  FDetailAreaField   := wcDefault;
  FGraph             := wcDefault;
  FOnDemandSubreport := wcMagnify;
  FHyperLink         := wcHand;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeWindowCursor.Clear;
begin
  SetGroupArea(wcDefault);
  SetGroupAreaField(wcDefault);
  SetDetailArea(wcDefault);
  SetDetailAreaField(wcDefault);
  SetGraph(wcDefault);
  SetOnDemandSubreport(wcMagnify);
  SetHyperLink(wcHand);
end;
{------------------------------------------------------------------------------}
{ Send                                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeWindowCursor.Send;
begin
  SetGroupArea(FGroupArea);
  SetGroupAreaField(FGroupAreaField);
  SetDetailArea(FDetailArea);
  SetDetailAreaField(FDetailAreaField);
  SetGraph(FGraph);
  SetOnDemandSubreport(FOnDemandSubreport);
  SetHyperLink(FHyperLink);
end;
{------------------------------------------------------------------------------}
{ ConvertCursorType                                                            }
{  - Local function to convert Cursor Type                                     }
{------------------------------------------------------------------------------}
function TCrpeWindowCursor.ConvertCursorType(rptCursor: Smallint): TCrWindowCursor;
var
  cnt : integer;
begin
  Result := wcDefault;
  for cnt := Ord(Low(PECursorTypes)) to Ord(High(PECursorTypes)) do
  begin
    if rptCursor = PECursorTypes[cnt] then
    begin
      Result := TCrWindowCursor(cnt);
      Exit;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetGroupArea                                                                 }
{------------------------------------------------------------------------------}
function TCrpeWindowCursor.GetGroupArea : TCrWindowCursor;
var
  CursorInfo : PETrackCursorInfo;
begin
  Result := FGroupArea;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  {Retrieve the Cursor info}
  
  if not Cr.FCrpeEngine.PEGetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'WindowCursor.GetGroupArea <PEGetTrackCursorInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FGroupArea := ConvertCursorType(CursorInfo.groupAreaCursor);
  Result := FGroupArea;
end;
{------------------------------------------------------------------------------}
{ SetGroupArea                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeWindowCursor.SetGroupArea (const Value: TCrWindowCursor);
var
  CursorInfo : PETrackCursorInfo;
  rGroupArea : TCrWindowCursor;
begin
  FGroupArea := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Retrieve the Cursor info}
  
  if not Cr.FCrpeEngine.PEGetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'WindowCursor.SetGroupArea <PEGetTrackCursorInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  rGroupArea := ConvertCursorType(CursorInfo.groupAreaCursor);

  {GroupArea}
  if FGroupArea <> rGroupArea then
  begin
    CursorInfo.groupAreaCursor := PECursorTypes[Ord(FGroupArea)];
    {Set TrackCursor}
    
    if not Cr.FCrpeEngine.PESetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowCursor.SetGroupArea <PESetTrackCursorInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetGroupAreaField                                                            }
{------------------------------------------------------------------------------}
function  TCrpeWindowCursor.GetGroupAreaField : TCrWindowCursor;
var
  CursorInfo : PETrackCursorInfo;
begin
  Result := FGroupAreaField;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  {Retrieve the Cursor info}
  
  if not Cr.FCrpeEngine.PEGetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'WindowCursor.GetGroupAreaField <PEGetTrackCursorInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FGroupAreaField := ConvertCursorType(CursorInfo.groupAreaFieldCursor);
  Result := FGroupAreaField;
end;
{------------------------------------------------------------------------------}
{ SetGroupAreaField                                                            }
{------------------------------------------------------------------------------}
procedure TCrpeWindowCursor.SetGroupAreaField (const Value: TCrWindowCursor);
var
  CursorInfo      : PETrackCursorInfo;
  rGroupAreaField : TCrWindowCursor;
begin
  FGroupAreaField := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Retrieve the Cursor info}
  
  if not Cr.FCrpeEngine.PEGetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'WindowCursor.SetGroupAreaField <PEGetTrackCursorInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  rGroupAreaField := ConvertCursorType(CursorInfo.groupAreaFieldCursor);

  {GroupAreaField}
  if FGroupAreaField <> rGroupAreaField then
  begin
    CursorInfo.groupAreaFieldCursor := PECursorTypes[Ord(FGroupAreaField)];
    {Set TrackCursor}
    
    if not Cr.FCrpeEngine.PESetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowCursor.SetGroupAreaField <PESetTrackCursorInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetDetailArea                                                                }
{------------------------------------------------------------------------------}
function  TCrpeWindowCursor.GetDetailArea : TCrWindowCursor;
var
  CursorInfo : PETrackCursorInfo;
begin
  Result := FDetailArea;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  {Retrieve the Cursor info}
  
  if not Cr.FCrpeEngine.PEGetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'WindowCursor.GetDetailArea <PEGetTrackCursorInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FDetailArea := ConvertCursorType(CursorInfo.detailAreaCursor);
  Result := FDetailArea;
end;
{------------------------------------------------------------------------------}
{ SetDetailArea                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeWindowCursor.SetDetailArea (const Value: TCrWindowCursor);
var
  CursorInfo  : PETrackCursorInfo;
  rDetailArea : TCrWindowCursor;
begin
  FDetailArea := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Retrieve the Cursor info}
  
  if not Cr.FCrpeEngine.PEGetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'WindowCursor.SetDetailArea <PEGetTrackCursorInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  rDetailArea := ConvertCursorType(CursorInfo.detailAreaCursor);

  {DetailArea}
  if FDetailArea <> rDetailArea then
  begin
    CursorInfo.detailAreaCursor := PECursorTypes[Ord(FDetailArea)];
    {Set TrackCursor}
    
    if not Cr.FCrpeEngine.PESetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowCursor.SetDetailArea <PESetTrackCursorInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetDetailAreaField                                                           }
{------------------------------------------------------------------------------}
function  TCrpeWindowCursor.GetDetailAreaField : TCrWindowCursor;
var
  CursorInfo : PETrackCursorInfo;
begin
  Result := FDetailAreaField;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  {Retrieve the Cursor info}
  
  if not Cr.FCrpeEngine.PEGetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'WindowCursor.GetDetailAreaField <PEGetTrackCursorInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FDetailAreaField := ConvertCursorType(CursorInfo.detailAreaFieldCursor);
  Result := FDetailAreaField;
end;
{------------------------------------------------------------------------------}
{ SetDetailAreaField                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeWindowCursor.SetDetailAreaField (const Value: TCrWindowCursor);
var
  CursorInfo       : PETrackCursorInfo;
  rDetailAreaField : TCrWindowCursor;
begin
  FDetailAreaField := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Retrieve the Cursor info}
  
  if not Cr.FCrpeEngine.PEGetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'WindowCursor.SetDetailAreaField <PEGetTrackCursorInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  rDetailAreaField := ConvertCursorType(CursorInfo.detailAreaFieldCursor);

  {DetailAreaField}
  if FDetailAreaField <> rDetailAreaField then
  begin
    CursorInfo.detailAreaFieldCursor := PECursorTypes[Ord(FDetailAreaField)];
    {Set TrackCursor}
    
    if not Cr.FCrpeEngine.PESetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowCursor.SetDetailAreaField <PESetTrackCursorInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetGraph                                                                     }
{------------------------------------------------------------------------------}
function TCrpeWindowCursor.GetGraph : TCrWindowCursor;
var
  CursorInfo : PETrackCursorInfo;
begin
  Result := FGraph;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  {Retrieve the Cursor info}
  
  if not Cr.FCrpeEngine.PEGetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'WindowCursor.GetGraph <PEGetTrackCursorInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FGraph := ConvertCursorType(CursorInfo.graphCursor);
  Result := FGraph;
end;
{------------------------------------------------------------------------------}
{ SetGraph                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeWindowCursor.SetGraph (const Value: TCrWindowCursor);
var
  CursorInfo : PETrackCursorInfo;
  rGraph     : TCrWindowCursor;
begin
  FGraph := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Retrieve the Cursor info}
  
  if not Cr.FCrpeEngine.PEGetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'WindowCursor.SetGraph <PEGetTrackCursorInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  rGraph := ConvertCursorType(CursorInfo.graphCursor);

  {Graph}
  if FGraph <> rGraph then
  begin
    CursorInfo.graphCursor := PECursorTypes[Ord(FGraph)];
    {Set TrackCursor}
    
    if not Cr.FCrpeEngine.PESetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowCursor.SetGraph <PESetTrackCursorInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetOnDemandSubreport                                                         }
{------------------------------------------------------------------------------}
function TCrpeWindowCursor.GetOnDemandSubreport : TCrWindowCursor;
var
  CursorInfo : PETrackCursorInfo;
begin
  Result := FOnDemandSubreport;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  {Retrieve the Cursor info}
  if not Cr.FCrpeEngine.PEGetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'WindowCursor.GetOnDemandSubreport <PEGetTrackCursorInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FOnDemandSubreport := ConvertCursorType(CursorInfo.onDemandSubreportCursor);
  Result := FOnDemandSubreport;
end;
{------------------------------------------------------------------------------}
{ SetOnDemandSubreport                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeWindowCursor.SetOnDemandSubreport (const Value: TCrWindowCursor);
var
  CursorInfo      : PETrackCursorInfo;
  rOnDemandSubRpt : TCrWindowCursor;
begin
  FOnDemandSubreport := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Retrieve the Cursor info}
  
  if not Cr.FCrpeEngine.PEGetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'WindowCursor.SetOnDemandSubreport <PEGetTrackCursorInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  rOnDemandSubRpt := ConvertCursorType(CursorInfo.ondemandSubreportCursor);

  {OnDemandSubreport}
  if FOnDemandSubreport <> rOnDemandSubRpt then
  begin
    CursorInfo.ondemandSubreportCursor := PECursorTypes[Ord(FOnDemandSubreport)];
    {Set TrackCursor}
    
    if not Cr.FCrpeEngine.PESetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowCursor.SetOnDemandSubreport <PESetTrackCursorInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetHyperLink                                                                 }
{------------------------------------------------------------------------------}
function TCrpeWindowCursor.GetHyperLink : TCrWindowCursor;
var
  CursorInfo : PETrackCursorInfo;
begin
  Result := FGraph;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  {Retrieve the Cursor info}
  
  if not Cr.FCrpeEngine.PEGetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'WindowCursor.GetHyperLink <PEGetTrackCursorInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FHyperLink := ConvertCursorType(CursorInfo.hyperLinkCursor);
  Result := FHyperLink;
end;
{------------------------------------------------------------------------------}
{ SetHyperLink                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeWindowCursor.SetHyperLink (const Value: TCrWindowCursor);
var
  CursorInfo : PETrackCursorInfo;
  rHyperLink : TCrWindowCursor;
begin
  FHyperLink := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Retrieve the Cursor info}
  
  if not Cr.FCrpeEngine.PEGetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'WindowCursor.SetHyperLink <PEGetTrackCursorInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  rHyperLink := ConvertCursorType(CursorInfo.hyperlinkCursor);

  {HyperLink}
  if FHyperLink <> rHyperLink then
  begin
    CursorInfo.hyperlinkCursor := PECursorTypes[Ord(FHyperLink)];
    {Set TrackCursor}
    
    if not Cr.FCrpeEngine.PESetTrackCursorInfo(Cr.FPrintJob, CursorInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'WindowCursor.SetHyperLink <PESetTrackCursorInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ TCrpePages Class Definition                                                  }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpePages.Create;
begin
  inherited Create;
end;
{------------------------------------------------------------------------------}
{ GetDisplayed                                                                 }
{------------------------------------------------------------------------------}
function TCrpePages.GetDisplayed : Word;
var
  JobInfo : PEJobInfo;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if (Cr.FPrintJob = 0) then Exit;
  
  Cr.FCrpeEngine.PEGetJobStatus(Cr.FPrintJob, JobInfo);
  Result := JobInfo.DisplayPageN;
end;
{------------------------------------------------------------------------------}
{ GetLatest                                                                    }
{------------------------------------------------------------------------------}
function TCrpePages.GetLatest: Word;
var
  JobInfo : PEJobInfo;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if (Cr.FPrintJob = 0) then Exit;
  
  Cr.FCrpeEngine.PEGetJobStatus(Cr.FPrintJob, JobInfo);
  Result := JobInfo.LatestPageN;
end;
{------------------------------------------------------------------------------}
{ GetStart                                                                     }
{------------------------------------------------------------------------------}
function TCrpePages.GetStart: Word;
var
  JobInfo : PEJobInfo;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if (Cr.FPrintJob = 0) then Exit;
  
  Cr.FCrpeEngine.PEGetJobStatus(Cr.FPrintJob, JobInfo);
  Result := JobInfo.StartPageN;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpePages.Count: Smallint;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if (Cr.FPrintJob = 0) then Exit;
  
  Result := Cr.FCrpeEngine.PEGetNPages(Cr.FPrintJob);
end; {Count}
{------------------------------------------------------------------------------}
{ First                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpePages.First;
begin
  if (Cr.FPrintJob = 0) then Exit;
  if (Cr = nil) then Exit;
  
  if not Cr.FCrpeEngine.PEShowFirstPage(Cr.FPrintJob) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Pages.First <PEShowFirstPage>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end; {First}
{------------------------------------------------------------------------------}
{ Next                                                                         }
{------------------------------------------------------------------------------}
procedure TCrpePages.Next;
begin
  if (Cr = nil) then Exit;
  if (Cr.FPrintJob = 0) then Exit;
  
  if not Cr.FCrpeEngine.PEShowNextPage(Cr.FPrintJob) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errPaging,errEngine,'',
        'Pages.Next <PEShowNextPage>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end; {Next}
{------------------------------------------------------------------------------}
{ Previous                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpePages.Previous;
begin
  if (Cr = nil) then Exit;
  if (Cr.FPrintJob = 0) then Exit;
  
  if not Cr.FCrpeEngine.PEShowPreviousPage(Cr.FPrintJob) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errPaging,errEngine,'',
       'Pages.Previous <PEShowPreviousPage>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end; {Previous}
{------------------------------------------------------------------------------}
{ Last                                                                         }
{------------------------------------------------------------------------------}
procedure TCrpePages.Last;
begin
  if (Cr = nil) then Exit;
  if (Cr.FPrintJob = 0) then Exit;
  
  if not Cr.FCrpeEngine.PEShowLastPage(Cr.FPrintJob) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Pages.Last <PEShowLastPage>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end; {Last}
{------------------------------------------------------------------------------}
{ GoToPage                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpePages.GoToPage(const Value : Smallint);
begin
  if (Cr = nil) then Exit;
  if (Cr.FPrintJob = 0) then Exit;
  
  if not Cr.FCrpeEngine.PEShowNthPage(Cr.FPrintJob, Value) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'Pages.GoToPage <PEShowNthPage>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end; {GoToPage}
{------------------------------------------------------------------------------}
{ GetStartPageNumber                                                           }
{------------------------------------------------------------------------------}
function TCrpePages.GetStartPageNumber : LongInt;
begin
  Result := FStartPageNumber;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  if not Cr.FCrpeEngine.PEGetStartPageNumber (Cr.FPrintJob, FStartPageNumber) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'Pages.GetStartPageNumber <PEGetStartPageNumber>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := FStartPageNumber;
end;
{------------------------------------------------------------------------------}
{ SetStartPageNumber                                                           }
{------------------------------------------------------------------------------}
procedure TCrpePages.SetStartPageNumber (const Value: LongInt);
begin
  FStartPageNumber := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  if not Cr.FCrpeEngine.PESetStartPageNumber (Cr.FPrintJob, FStartPageNumber) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'Pages.SetStartPageNumber <PESetStartPageNumber>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetIndex                                                                     }
{------------------------------------------------------------------------------}
function TCrpePages.GetIndex : integer;
begin
  Result := GetDisplayed;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpePages.SetIndex (nIndex: integer);
begin
  GoToPage(nIndex);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpePages.GetItem (nIndex: integer) : string;
begin
  SetIndex(nIndex);
  Result := '';
end;


{******************************************************************************}
{ TCrpeRecords Class Definition                                                }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Printed                                                                      }
{------------------------------------------------------------------------------}
function TCrpeRecords.Printed : LongInt;
var
  JobInfo : PEJobInfo;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if Cr.FPrintJob = 0 then Exit;
  
  Cr.FCrpeEngine.PEGetJobStatus(Cr.FPrintJob, JobInfo);
  Result := JobInfo.NumRecordsPrinted;
end;
{------------------------------------------------------------------------------}
{ Selected                                                                     }
{------------------------------------------------------------------------------}
function TCrpeRecords.Selected : LongInt;
var
  JobInfo : PEJobInfo;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if Cr.FPrintJob = 0 then
    Exit;
  
  Cr.FCrpeEngine.PEGetJobStatus(Cr.FPrintJob, JobInfo);
  Result := JobInfo.NumRecordsSelected;
end;
{------------------------------------------------------------------------------}
{ Read                                                                         }
{------------------------------------------------------------------------------}
function TCrpeRecords.Read : LongInt;
var
  JobInfo : PEJobInfo;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if Cr.FPrintJob = 0 then Exit;
  
  Cr.FCrpeEngine.PEGetJobStatus(Cr.FPrintJob, JobInfo);
  Result := JobInfo.NumRecordsRead;
end;
{------------------------------------------------------------------------------}
{ PercentRead                                                                  }
{------------------------------------------------------------------------------}
function TCrpeRecords.PercentRead : LongInt;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if Cr.FPrintJob = 0 then Exit;
  
  Result := Cr.FCrpeEngine.PEGetReadPercentCompleted (Cr.FPrintJob);
end;
{------------------------------------------------------------------------------}
{ PercentCompleted                                                             }
{------------------------------------------------------------------------------}
function TCrpeRecords.PercentCompleted : LongInt;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if Cr.FPrintJob = 0 then Exit;
  
  Result := Cr.FCrpeEngine.PEGetPercentCompleted (Cr.FPrintJob);
end;
{------------------------------------------------------------------------------}
{ SetRecordLimit                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeRecords.SetRecordLimit (const Value: LongInt);
begin
  if (Cr = nil) then Exit;
  if Cr.FPrintJob = 0 then Exit;
  
  if not Cr.FCrpeEngine.PESetReadRecordLimit (Cr.FPrintJob, Value) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Records.SetRecordLimit <PESetReadRecordLimit>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetTimeLimit                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeRecords.SetTimeLimit (const Value: LongInt); {in seconds}
begin
  if (Cr = nil) then Exit;
  if Cr.FPrintJob = 0 then Exit;
  
  if not Cr.FCrpeEngine.PESetTimeLimit (Cr.FPrintJob, Value) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Records.SetTimeLimit <PESetTimeLimit>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;


{******************************************************************************}
{ TCrpeSummaryInfo Class Definition                                            }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSummaryInfo.Create;
begin
  inherited Create;
  {Set Defaults}
  FAppName := '';
  FTitle := '';
  FSubject := '';
  FAuthor := '';
  FKeywords := '';
  FTemplate := '';
  FComments := TStringList.Create;
  TStringList(FComments).OnChange := OnChangeStrings;
  xComments := TStringList.Create;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSummaryInfo.Destroy;
begin
  TStringList(FComments).OnChange := nil;
  FComments.Free;
  xComments.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryInfo.Clear;
begin
  SetAppName('');
  SetTitle('');
  SetSubject('');
  SetAuthor('');
  SetKeywords('');
  SetTemplate('');
  {Comments}
  xComments.Clear;
  SetComments(xComments);
end;
{------------------------------------------------------------------------------}
{ OnChangeStrings                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryInfo.OnChangeStrings;
begin
  TStringList(FComments).OnChange := nil;
  xComments.Assign(FComments);
  SetComments(xComments);
  TStringList(FComments).OnChange := OnChangeStrings;
end;
{------------------------------------------------------------------------------}
{ GetTitle                                                                     }
{------------------------------------------------------------------------------}
function TCrpeSummaryInfo.GetTitle : string;
var
  SumInfo : PEReportSummaryInfo;
begin
  Result := FTitle;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
   { if not Cr.JobIsOpen then Exit; }

  
  if not Cr.FCrpeEngine.PEGetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'SummaryInfo.GetTitle <PEGetReportSummaryInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FTitle := String(SumInfo.title);
  Result := FTitle;
end;
{------------------------------------------------------------------------------}
{ SetTitle                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryInfo.SetTitle(const Value: string);
var
  SumInfo : PEReportSummaryInfo;
  sTitle  : string;
begin
  FTitle := Value;
  {Check Length}
  if Length(FTitle) > PE_SI_TITLE_LEN then
    FTitle := Copy(FTitle, 1, PE_SI_TITLE_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get SummaryInfo from Report: SummaryInfo only applies to main Report}
  
  if not Cr.FCrpeEngine.PEGetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'SummaryInfo.SetTitle <PEGetReportSummaryInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Title}
  sTitle := String(SumInfo.title);
  if CompareText(FTitle, sTitle) <> 0 then
  begin
    StrCopy(SumInfo.title, PChar(FTitle));
    {Set SummaryInfo}
    
    if not Cr.FCrpeEngine.PESetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
    begin
      case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
          'SummaryInfo.SetTitle <PESetReportSummaryInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetSubject                                                                   }
{------------------------------------------------------------------------------}
function TCrpeSummaryInfo.GetSubject : string;
var
  SumInfo : PEReportSummaryInfo;
begin
  Result := FSubject;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  { if not Cr.JobIsOpen then Exit; }

  
  if not Cr.FCrpeEngine.PEGetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'SummaryInfo.GetSubject <PEGetReportSummaryInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FSubject := String(SumInfo.subject);
  Result := FSubject;
end;
{------------------------------------------------------------------------------}
{ SetSubject                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryInfo.SetSubject(const Value: string);
var
  SumInfo  : PEReportSummaryInfo;
  sSubject : string;
begin
  FSubject := Value;
  {Check Length}
  if Length(FSubject) > PE_SI_SUBJECT_LEN then
    FSubject := Copy(FSubject, 1, PE_SI_SUBJECT_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get SummaryInfo from Report: SummaryInfo only applies to main Report}
  
  if not Cr.FCrpeEngine.PEGetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'SummaryInfo.SetSubject <PEGetReportSummaryInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Subject}
  sSubject := String(SumInfo.subject);
  if CompareText(FSubject, sSubject) <> 0 then
  begin
    StrCopy(SumInfo.subject, PChar(FSubject));
    {Set SummaryInfo}
    
    if not Cr.FCrpeEngine.PESetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
    begin
      case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
          'SummaryInfo.SetSubject <PESetReportSummaryInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetAuthor                                                                    }
{------------------------------------------------------------------------------}
function TCrpeSummaryInfo.GetAuthor : string;
var
  SumInfo : PEReportSummaryInfo;
begin
  Result := FAuthor;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'SummaryInfo.GetAuthor <PEGetReportSummaryInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FAuthor := String(SumInfo.author);
  Result := FAuthor;
end;
{------------------------------------------------------------------------------}
{ SetAuthor                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryInfo.SetAuthor(const Value: string);
var
  SumInfo : PEReportSummaryInfo;
  sAuthor : string;
begin
  FAuthor := Value;
  {Check Length}
  if Length(FAuthor) > PE_SI_AUTHOR_LEN then
    FAuthor := Copy(FAuthor, 1, PE_SI_AUTHOR_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get SummaryInfo from Report: SummaryInfo only applies to main Report}
  
  if not Cr.FCrpeEngine.PEGetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'SummaryInfo.SetAuthor <PEGetReportSummaryInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Author}
  sAuthor := String(SumInfo.author);
  if CompareText(FAuthor, sAuthor) <> 0 then
  begin
    StrCopy(SumInfo.author, PChar(FAuthor));
    {Set SummaryInfo}
    
    if not Cr.FCrpeEngine.PESetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
    begin
      case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
          'SummaryInfo.SetAuthor <PESetReportSummaryInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetKeywords                                                                  }
{------------------------------------------------------------------------------}
function TCrpeSummaryInfo.GetKeywords : string;
var
  SumInfo : PEReportSummaryInfo;
begin
  Result := FKeywords;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'SummaryInfo.GetKeywords <PEGetReportSummaryInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FKeywords := String(SumInfo.keywords);
  Result := FKeywords;
end;
{------------------------------------------------------------------------------}
{ SetKeywords                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryInfo.SetKeywords(const Value: string);
var
  SumInfo   : PEReportSummaryInfo;
  sKeywords : string;
begin
  FKeywords := Value;
  {Check Length}
  if Length(FKeywords) > PE_SI_KEYWORDS_LEN then
    FKeywords := Copy(FKeywords, 1, PE_SI_KEYWORDS_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get SummaryInfo from Report: SummaryInfo only applies to main Report}
  
  if not Cr.FCrpeEngine.PEGetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'SummaryInfo.SetKeywords <PEGetReportSummaryInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Keywords}
  sKeywords := String(SumInfo.keywords);
  if CompareText(FKeywords, sKeywords) <> 0 then
  begin
    StrCopy(SumInfo.keywords, PChar(FKeywords));
    {Set SummaryInfo}
    
    if not Cr.FCrpeEngine.PESetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
    begin
      case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
          'SummaryInfo.SetKeywords <PESetReportSummaryInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetComments                                                                  }
{------------------------------------------------------------------------------}
function TCrpeSummaryInfo.GetComments : TStrings;
var
  SumInfo : PEReportSummaryInfo;
begin
  Result := FComments;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'SummaryInfo.GetComments <PEGetReportSummaryInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FComments.SetText(SumInfo.comments);
  Result := FComments;
end;
{------------------------------------------------------------------------------}
{ SetComments                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryInfo.SetComments(ListVar: TStrings);
var
  SumInfo : PEReportSummaryInfo;
  sTmp    : string;
begin
  FComments.Assign(ListVar);
  {Check Length}
  sTmp := FComments.Text;
  if Length(sTmp) > PE_SI_COMMENTS_LEN then
  begin
    sTmp := Copy(sTmp, 1, PE_SI_COMMENTS_LEN);
    FComments.Text := sTmp;
  end;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get SummaryInfo from Report: SummaryInfo only applies to main Report}
  
  if not Cr.FCrpeEngine.PEGetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
  begin
    TStringList(FComments).OnChange := OnChangeStrings;
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'SummaryInfo.SetComments <PEGetReportSummaryInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Comments}
  sTmp := RTrimList(FComments);
  {Compare with Report}
  if StrComp(SumInfo.comments, PChar(sTmp)) <> 0 then
  begin
    StrCopy(SumInfo.comments, PChar(sTmp));
    {Set SummaryInfo}
    
    if not Cr.FCrpeEngine.PESetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
    begin
      TStringList(FComments).OnChange := OnChangeStrings;
      case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
          'SummaryInfo.SetComments <PESetReportSummaryInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetTemplate                                                                  }
{------------------------------------------------------------------------------}
function TCrpeSummaryInfo.GetTemplate : string;
var
  SumInfo : PEReportSummaryInfo;
begin
  Result := FTemplate;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'SummaryInfo.GetTemplate <PEGetReportSummaryInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FTemplate := String(SumInfo.reportTemplate);
  Result := FTemplate;
end;
{------------------------------------------------------------------------------}
{ SetTemplate                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryInfo.SetTemplate(const Value: string);
var
  SumInfo   : PEReportSummaryInfo;
  sTemplate : string;
begin
  FTemplate := Value;
  {Check Length}
  if Length(FTemplate) > PE_SI_REPORT_TEMPLATE_LEN then
    FTemplate := Copy(FTemplate, 1, PE_SI_REPORT_TEMPLATE_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get SummaryInfo from Report: SummaryInfo only applies to main Report}
  
  if not Cr.FCrpeEngine.PEGetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'SummaryInfo.SetTemplate <PEGetReportSummaryInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Template}
  sTemplate := String(SumInfo.reportTemplate);
  if CompareText(FTemplate, sTemplate) <> 0 then
  begin
    StrCopy(SumInfo.reportTemplate, PChar(FTemplate));
    {Set SummaryInfo}
    
    if not Cr.FCrpeEngine.PESetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
    begin
      case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
          'SummaryInfo.SetTemplate <PESetReportSummaryInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetAppName                                                                   }
{------------------------------------------------------------------------------}
function TCrpeSummaryInfo.GetAppName : string;
var
  SumInfo : PEReportSummaryInfo;
begin
  Result := FAppName;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'SummaryInfo.GetAppName <PEGetReportSummaryInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FAppName := String(SumInfo.applicationName);
  Result := FAppName;
end;
{------------------------------------------------------------------------------}
{ SetAppName                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryInfo.SetAppName(const Value : string);
begin
  {AppName is Read-only}
end;
{------------------------------------------------------------------------------}
{ GetSavePreviewPicture                                                        }
{------------------------------------------------------------------------------}
function TCrpeSummaryInfo.GetSavePreviewPicture : Boolean;
var
  SumInfo : PEReportSummaryInfo;
begin
  Result := FSavePreviewPicture;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'SummaryInfo.GetSavePreviewPicture <PEGetReportSummaryInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  case SumInfo.savePreviewPicture of
    0 : FSavePreviewPicture := False;
    1 : FSavePreviewPicture := True;
    else
      FSavePreviewPicture := False;
  end;
  Result := FSavePreviewPicture;
end;
{------------------------------------------------------------------------------}
{ SetSavePreviewPicture                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryInfo.SetSavePreviewPicture (const Value: Boolean);
var
  SumInfo   : PEReportSummaryInfo;
begin
  FSavePreviewPicture := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get SummaryInfo from Report: SummaryInfo only applies to main Report}
  
  if not Cr.FCrpeEngine.PEGetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'SummaryInfo.SetSavePreviewPicture <PEGetReportSummaryInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if SumInfo.savePreviewPicture <> Ord(FSavePreviewPicture) then
  begin
    SumInfo.savePreviewPicture := Ord(FSavePreviewPicture);
    {Set SummaryInfo}
    
    if not Cr.FCrpeEngine.PESetReportSummaryInfo(Cr.PrintJobs(0), SumInfo) then
    begin
      case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
          'SummaryInfo.SetSavePreviewPicture <PESetReportSummaryInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;

{******************************************************************************}
{ TCrpeGlobalOptions Class Definition                                          }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGlobalOptions.Create;
begin
  inherited Create;
  FMatchLogOnInfo                   := cDefault;
  FMorePrintEngineErrorMessages     := cDefault;
  FUse70TextCompatibility           := cDefault;
  FDisableThumbnailUpdates          := cDefault;
  FVerifyWhenDatabaseDriverUpgraded := cDefault;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGlobalOptions.Clear;
begin
  if IsStrEmpty(Cr.FReportName) or  (not FileExists(Cr.FReportName)) then
  begin
    FMatchLogOnInfo                   := cDefault;
    FMorePrintEngineErrorMessages     := cDefault;
    FUse70TextCompatibility           := cDefault;
    FDisableThumbnailUpdates          := cDefault;
    FVerifyWhenDatabaseDriverUpgraded := cDefault;
  end
  else
  begin
    SetMatchLogOnInfo(cDefault);
    SetMorePrintEngineErrorMessages(cDefault);
    SetUse70TextCompatibility(cDefault);
    SetDisableThumbnailUpdates(cDefault);
    SetVerifyWhenDatabaseDriverUpgraded(cDefault);
  end;
end;
{------------------------------------------------------------------------------}
{ GetDefault                                                                   }
{------------------------------------------------------------------------------}
function TCrpeGlobalOptions.GetDefault: TCrBoolean;
begin
  Result := cDefault;
end;
{------------------------------------------------------------------------------}
{ SetMorePrintEngineErrorMessages                                              }
{------------------------------------------------------------------------------}
procedure TCrpeGlobalOptions.SetMorePrintEngineErrorMessages(const Value: TCrBoolean);
var
  GlobalOptions : PEGlobalOptions;
begin
  if (Cr = nil) then Exit;
  if not Cr.OpenPrintEngine then Exit;

  GlobalOptions.morePrintEngineErrorMessages := Ord(Value);
  GlobalOptions.matchLogOnInfo := PE_UNCHANGED;
  GlobalOptions.use70TextCompatibility := PE_UNCHANGED;
  GlobalOptions.disableThumbnailUpdates := PE_UNCHANGED;
  GlobalOptions.verifyWhenDatabaseDriverUpgraded := PE_UNCHANGED;

  if not Cr.FCrpeEngine.PESetGlobalOptions(GlobalOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GlobalOptions.SetMorePrintEngineErrorMessages <PESetGlobalOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FMorePrintEngineErrorMessages := Value;
end;
{------------------------------------------------------------------------------}
{ SetMatchLogOnInfo                                                            }
{------------------------------------------------------------------------------}
procedure TCrpeGlobalOptions.SetMatchLogOnInfo(const Value: TCrBoolean);
var
  GlobalOptions : PEGlobalOptions;
begin
  if (Cr = nil) then Exit;
  if not Cr.OpenPrintEngine then Exit;

  GlobalOptions.morePrintEngineErrorMessages := PE_UNCHANGED;
  GlobalOptions.matchLogOnInfo := Ord(Value);
  GlobalOptions.use70TextCompatibility := PE_UNCHANGED;
  GlobalOptions.disableThumbnailUpdates := PE_UNCHANGED;
  GlobalOptions.verifyWhenDatabaseDriverUpgraded := PE_UNCHANGED;

  if not Cr.FCrpeEngine.PESetGlobalOptions(GlobalOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GlobalOptions.SetMatchLogOnInfo <PESetGlobalOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FMatchLogOnInfo := Value;
end;
{------------------------------------------------------------------------------}
{ SetUse70TextCompatibility                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeGlobalOptions.SetUse70TextCompatibility(const Value: TCrBoolean);
var
  GlobalOptions : PEGlobalOptions;
begin
  if (Cr = nil) then Exit;
  if not Cr.OpenPrintEngine then Exit;

  GlobalOptions.morePrintEngineErrorMessages := PE_UNCHANGED;
  GlobalOptions.matchLogOnInfo := PE_UNCHANGED;
  GlobalOptions.use70TextCompatibility := Ord(Value);
  GlobalOptions.disableThumbnailUpdates := PE_UNCHANGED;
  GlobalOptions.verifyWhenDatabaseDriverUpgraded := PE_UNCHANGED;

  if not Cr.FCrpeEngine.PESetGlobalOptions(GlobalOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GlobalOptions.SetUse70TextCompatibility <PESetGlobalOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FUse70TextCompatibility := Value;
end;
{------------------------------------------------------------------------------}
{ SetDisableThumbnailUpdates                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeGlobalOptions.SetDisableThumbnailUpdates(const Value: TCrBoolean);
var
  GlobalOptions : PEGlobalOptions;
begin
  if (Cr = nil) then Exit;
  if not Cr.OpenPrintEngine then Exit;

  GlobalOptions.morePrintEngineErrorMessages := PE_UNCHANGED;
  GlobalOptions.matchLogOnInfo := PE_UNCHANGED;
  GlobalOptions.use70TextCompatibility := PE_UNCHANGED;
  GlobalOptions.disableThumbnailUpdates := Ord(Value);
  GlobalOptions.verifyWhenDatabaseDriverUpgraded := PE_UNCHANGED;

  if not Cr.FCrpeEngine.PESetGlobalOptions(GlobalOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GlobalOptions.SetDisableThumbnailUpdates <PESetGlobalOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FDisableThumbnailUpdates := Value;
end;
{------------------------------------------------------------------------------}
{ SetVerifyWhenDatabaseDriverUpgraded                                          }
{------------------------------------------------------------------------------}
procedure TCrpeGlobalOptions.SetVerifyWhenDatabaseDriverUpgraded(const Value: TCrBoolean);
var
  GlobalOptions : PEGlobalOptions;
begin
  if (Cr = nil) then Exit;
  if not Cr.OpenPrintEngine then Exit;

  GlobalOptions.morePrintEngineErrorMessages := PE_UNCHANGED;
  GlobalOptions.matchLogOnInfo := PE_UNCHANGED;
  GlobalOptions.use70TextCompatibility := PE_UNCHANGED;
  GlobalOptions.disableThumbnailUpdates := PE_UNCHANGED;
  GlobalOptions.verifyWhenDatabaseDriverUpgraded := Ord(Value);

  if not Cr.FCrpeEngine.PESetGlobalOptions(GlobalOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GlobalOptions.SetVerifyWhenDatabaseDriverUpgraded <PESetGlobalOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FVerifyWhenDatabaseDriverUpgraded := Value;
end;

{******************************************************************************}
{ TCrpeReportOptions Class Definition                                          }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeReportOptions.Create;
begin
  inherited Create;
  {Set defaults}
  FSaveDataWithReport        := True;
  FSaveSummariesWithReport   := True;
  FUseIndexForSpeed          := True;
  FConvertNullFieldToDefault := False;
  FPrintEngineErrorMessages  := True;
  FCaseInsensitiveSQLData    := True;
  FVerifyOnEveryPrint        := False;
  FCreateGroupTree           := True;
  FNoDataForHiddenObjects    := False;
  FPerformGroupingOnServer   := False;
  FConvertDateTimeType       := ToDateTime;
  FZoomMode                  := pwNormal;
  FAsyncQuery                := False;
  {CR 8+}
  FPromptMode                := pmNormal;
  FSelectDistinctRecords     := False;
  {CR 8.5+}
  FAlwaysSortLocally         := True;
  FIsReadOnly                := False; {read-only}
  FCanSelectDistinctRecords  := True;  {read-only}
  {CR9}
  FUseDummyData               := False;
  FConvertOtherNullsToDefault := False;
  FVerifyStoredProcOnRefresh  := False;
  FRetainImageColourDepth     := False;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.Clear;
begin
  if IsStrEmpty(Cr.FReportName) or  (not FileExists(Cr.FReportName)) then
  begin
    {Set defaults}
    FSaveDataWithReport        := True;
    FSaveSummariesWithReport   := True;
    FUseIndexForSpeed          := True;
    FConvertNullFieldToDefault := False;
    FPrintEngineErrorMessages  := True;
    FCaseInsensitiveSQLData    := True;
    FVerifyOnEveryPrint        := False;
    FCreateGroupTree           := True;
    FNoDataForHiddenObjects    := False;
    FPerformGroupingOnServer   := False;
    FConvertDateTimeType       := ToDateTime;
    FZoomMode                  := pwNormal;
    FAsyncQuery                := False;
    {CR 8}
    FPromptMode                := pmNormal;
    FSelectDistinctRecords     := False;
    {CR 8.5+}
    FAlwaysSortLocally         := True;
    FIsReadOnly                := False; {read-only}
    FCanSelectDistinctRecords  := True;  {read-only}
    {CR9}
    FUseDummyData               := False;
    FConvertOtherNullsToDefault := False;
    FVerifyStoredProcOnRefresh  := False;
    FRetainImageColourDepth     := False;
  end
  else
  begin
    {Set defaults}
    SetSaveDataWithReport(True);
    SetSaveSummariesWithReport(True);
    SetUseIndexForSpeed(True);
    SetConvertNullFieldToDefault(False);
    SetPrintEngineErrorMessages(True);
    SetCaseInsensitiveSQLData(True);
    SetVerifyOnEveryPrint(False);
    SetCreateGroupTree(True);
    SetNoDataForHiddenObjects(False);
    SetPerformGroupingOnServer(False);
    SetConvertDateTimeType(ToDateTime);
    SetZoomMode(pwNormal);
    SetAsyncQuery(False);
    SetPromptMode(pmNormal);
    SetSelectDistinctRecords(False);
    SetAlwaysSortLocally(True);
    SetUseDummyData(False);
    SetConvertOtherNullsToDefault(False);
    SetVerifyStoredProcOnRefresh(False);
    SetRetainImageColourDepth(False);
  end;
end;
{------------------------------------------------------------------------------}
{ GetSaveDataWithReport                                                        }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetSaveDataWithReport : Boolean;
var
  ReportOptions : PEReportOptions;
begin
  Result := FSaveDataWithReport;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetSaveDataWithReport <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FSaveDataWithReport := Boolean(ReportOptions.saveDataWithReport);
  Result := FSaveDataWithReport;
end;
{------------------------------------------------------------------------------}
{ SetSaveDataWithReport                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetSaveDataWithReport(const Value: Boolean);
var
  ReportOptions : PEReportOptions;
begin
  FSaveDataWithReport := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get ReportOptions from Report}
  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ReportOptions.SetSaveDataWithReport <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {SaveDataWithReport}
  if Ord(FSaveDataWithReport) <> ReportOptions.saveDataWithReport then
  begin
    ReportOptions.saveDataWithReport := Ord(FSaveDataWithReport);
    {Set ReportOptions}
    
    if not Cr.FCrpeEngine.PESetReportOptions(Cr.FPrintJob, ReportOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'ReportOptions.SetSaveDataWithReport <PESetReportOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetSaveSummariesWithReport                                                   }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetSaveSummariesWithReport : Boolean;
var
  ReportOptions : PEReportOptions;
begin
  Result := FSaveSummariesWithReport;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetSaveSummariesWithReport <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FSaveSummariesWithReport := Boolean(ReportOptions.saveSummariesWithReport);
  Result := FSaveSummariesWithReport;
end;
{------------------------------------------------------------------------------}
{ SetSaveSummariesWithReport                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetSaveSummariesWithReport(const Value: Boolean);
var
  ReportOptions : PEReportOptions;
begin
  FSaveSummariesWithReport := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get ReportOptions from Report}
  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ReportOptions.SetSaveSummariesWithReport <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {SaveSummariesWithReport}
  if Ord(FSaveSummariesWithReport) <> ReportOptions.saveSummariesWithReport then
  begin
    ReportOptions.saveSummariesWithReport := Ord(FSaveSummariesWithReport);
    {Set ReportOptions}

    if not Cr.FCrpeEngine.PESetReportOptions(Cr.FPrintJob, ReportOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'ReportOptions.SetSaveSummariesWithReport <PESetReportOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetUseIndexForSpeed                                                          }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetUseIndexForSpeed : Boolean;
var
  ReportOptions : PEReportOptions;
begin
  Result := FUseIndexForSpeed;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetUseIndexForSpeed <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FUseIndexForSpeed := Boolean(ReportOptions.useIndexForSpeed);
  Result := FUseIndexForSpeed;
end;
{------------------------------------------------------------------------------}
{ SetUseIndexForSpeed                                                          }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetUseIndexForSpeed(const Value: Boolean);
var
  ReportOptions : PEReportOptions;
begin
  FUseIndexForSpeed := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get ReportOptions from Report}
  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ReportOptions.SetUseIndexForSpeed <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {UseIndexForSpeed}
  if Ord(FUseIndexForSpeed) <> ReportOptions.useIndexForSpeed then
  begin
    ReportOptions.UseIndexForSpeed := Ord(FUseIndexForSpeed);
    {Set ReportOptions}
    
    if not Cr.FCrpeEngine.PESetReportOptions(Cr.FPrintJob, ReportOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'ReportOptions.SetUseIndexForSpeed <PESetReportOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetConvertNullFieldToDefault                                                 }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetConvertNullFieldToDefault : Boolean;
var
  ReportOptions : PEReportOptions;
begin
  Result := FConvertNullFieldToDefault;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetConvertNullFieldToDefault <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FConvertNullFieldToDefault := Boolean(ReportOptions.convertNullFieldToDefault);
  Result := FConvertNullFieldToDefault;
end;
{------------------------------------------------------------------------------}
{ SetConvertNullFieldToDefault                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetConvertNullFieldToDefault(const Value: Boolean);
var
  ReportOptions : PEReportOptions;
begin
  FConvertNullFieldToDefault := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get ReportOptions from Report}

  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ReportOptions.SetConvertNullFieldToDefault <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {ConvertNullFieldToDefault}
  if Ord(FConvertNullFieldToDefault) <> ReportOptions.convertNullFieldToDefault then
  begin
    ReportOptions.convertNullFieldToDefault := Ord(FConvertNullFieldToDefault);
    {Set ReportOptions}

    if not Cr.FCrpeEngine.PESetReportOptions(Cr.FPrintJob, ReportOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'ReportOptions.SetConvertNullFieldToDefault <PESetReportOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetPrintEngineErrorMessages                                                  }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetPrintEngineErrorMessages : Boolean;
var
  ReportOptions : PEReportOptions;
begin
  Result := FPrintEngineErrorMessages;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetPrintEngineErrorMessages <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FPrintEngineErrorMessages := Boolean(ReportOptions.morePrintEngineErrorMessages);
  Result := FPrintEngineErrorMessages;
end;
{------------------------------------------------------------------------------}
{ SetPrintEngineErrorMessages                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetPrintEngineErrorMessages(const Value: Boolean);
var
  ReportOptions : PEReportOptions;
begin
  FPrintEngineErrorMessages := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get ReportOptions from Report}
  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ReportOptions.SetPrintEngineErrorMessages <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {PrintEngineErrorMessages}
  if Ord(FPrintEngineErrorMessages) <> ReportOptions.morePrintEngineErrorMessages then
  begin
    ReportOptions.morePrintEngineErrorMessages := Ord(FPrintEngineErrorMessages);
    {Set ReportOptions}
    
    if not Cr.FCrpeEngine.PESetReportOptions(Cr.FPrintJob, ReportOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'ReportOptions.SetPrintEngineErrorMessages <PESetReportOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetCaseInsensitiveSQLData                                                    }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetCaseInsensitiveSQLData : Boolean;
var
  ReportOptions : PEReportOptions;
begin
  Result := FCaseInsensitiveSQLData;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetCaseInsensitiveSQLData <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FCaseInsensitiveSQLData := Boolean(ReportOptions.caseInsensitiveSQLData);
  Result := FCaseInsensitiveSQLData;
end;
{------------------------------------------------------------------------------}
{ SetCaseInsensitiveSQLData                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetCaseInsensitiveSQLData(const Value: Boolean);
var
  ReportOptions : PEReportOptions;
begin
  FCaseInsensitiveSQLData := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get ReportOptions from Report}
  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ReportOptions.SetCaseInsensitiveSQLData <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {CaseInsensitiveSQLData}
  if Ord(FCaseInsensitiveSQLData) <> ReportOptions.caseInsensitiveSQLData then
  begin
    ReportOptions.caseInsensitiveSQLData := Ord(FCaseInsensitiveSQLData);
    {Set ReportOptions}
    
    if not Cr.FCrpeEngine.PESetReportOptions(Cr.FPrintJob, ReportOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'ReportOptions.SetCaseInsensitiveSQLData <PESetReportOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetVerifyOnEveryPrint                                                        }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetVerifyOnEveryPrint : Boolean;
var
  ReportOptions : PEReportOptions;
begin
  Result := FVerifyOnEveryPrint;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetVerifyOnEveryPrint <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FVerifyOnEveryPrint := Boolean(ReportOptions.verifyOnEveryPrint);
  Result := FVerifyOnEveryPrint;
end;
{------------------------------------------------------------------------------}
{ SetVerifyOnEveryPrint                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetVerifyOnEveryPrint(const Value: Boolean);
var
  ReportOptions : PEReportOptions;
begin
  FVerifyOnEveryPrint := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get ReportOptions from Report}
  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ReportOptions.SetVerifyOnEveryPrint <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {VerifyOnEveryPrint}
  if Ord(FVerifyOnEveryPrint) <> ReportOptions.verifyOnEveryPrint then
  begin
    ReportOptions.verifyOnEveryPrint := Ord(FVerifyOnEveryPrint);
    {Set ReportOptions}
    
    if not Cr.FCrpeEngine.PESetReportOptions(Cr.FPrintJob, ReportOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'ReportOptions.SetVerifyOnEveryPrint <PESetReportOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetCreateGroupTree                                                           }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetCreateGroupTree : Boolean;
var
  ReportOptions : PEReportOptions;
begin
  Result := FCreateGroupTree;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetCreateGroupTree <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FCreateGroupTree := Boolean(ReportOptions.hasGroupTree);
  Result := FCreateGroupTree;
end;
{------------------------------------------------------------------------------}
{ SetCreateGroupTree                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetCreateGroupTree(const Value: Boolean);
var
  ReportOptions : PEReportOptions;
begin
  FCreateGroupTree := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get ReportOptions from Report}
  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ReportOptions.SetCreateGroupTree <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {CreateGroupTree}
  if Ord(FCreateGroupTree) <> ReportOptions.hasGroupTree then
  begin
    ReportOptions.hasGroupTree := Ord(FCreateGroupTree);
    {Set ReportOptions}
    
    if not Cr.FCrpeEngine.PESetReportOptions(Cr.FPrintJob, ReportOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'ReportOptions.SetCreateGroupTree <PESetReportOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetNoDataForHiddenObjects                                                    }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetNoDataForHiddenObjects : Boolean;
var
  ReportOptions : PEReportOptions;
begin
  Result := FNoDataForHiddenObjects;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetNoDataForHiddenObjects <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FNoDataForHiddenObjects := Boolean(ReportOptions.dontGenerateDataForHiddenObjects);
  Result := FNoDataForHiddenObjects;
end;
{------------------------------------------------------------------------------}
{ SetNoDataForHiddenObjects                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetNoDataForHiddenObjects(const Value: Boolean);
var
  ReportOptions : PEReportOptions;
begin
  FNoDataForHiddenObjects := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get ReportOptions from Report}
  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ReportOptions.SetNoDataForHiddenObjects <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {NoDataForHiddenObjects}
  if Ord(FNoDataForHiddenObjects) <> ReportOptions.dontGenerateDataForHiddenObjects then
  begin
    ReportOptions.dontGenerateDataForHiddenObjects := Ord(FNoDataForHiddenObjects);
    {Set ReportOptions}

    if not Cr.FCrpeEngine.PESetReportOptions(Cr.FPrintJob, ReportOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'ReportOptions.SetNoDataForHiddenObjects <PESetReportOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetPerformGroupingOnServer                                                   }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetPerformGroupingOnServer : Boolean;
var
  ReportOptions : PEReportOptions;
begin
  Result := FPerformGroupingOnServer;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetPerformGroupingOnServer <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FPerformGroupingOnServer := Boolean(ReportOptions.performGroupingOnServer);
  Result := FPerformGroupingOnServer;
end;
{------------------------------------------------------------------------------}
{ SetPerformGroupingOnServer                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetPerformGroupingOnServer(const Value: Boolean);
var
  ReportOptions : PEReportOptions;
begin
  FPerformGroupingOnServer := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get ReportOptions from Report}
  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ReportOptions.SetPerformGroupingOnServer <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {FPerformGroupingOnServer}
  if Ord(FPerformGroupingOnServer) <> ReportOptions.performGroupingOnServer then
  begin
    ReportOptions.performGroupingOnServer := Ord(FPerformGroupingOnServer);
    {Set ReportOptions}
    
    if not Cr.FCrpeEngine.PESetReportOptions(Cr.FPrintJob, ReportOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'ReportOptions.SetPerformGroupingOnServer <PESetReportOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetConvertDateTimeType                                                       }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetConvertDateTimeType : TCrDateTimeType;
var
  ReportOptions : PEReportOptions;
begin
  Result := FConvertDateTimeType;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetConvertDateTimeType <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  case ReportOptions.convertDateTimeType of
    PE_RPTOPT_CVTDATETIMETOSTR : FConvertDateTimeType := ToString;
    PE_RPTOPT_CVTDATETIMETODATE: FConvertDateTimeType := ToDate;
    PE_RPTOPT_KEEPDATETIMETYPE : FConvertDateTimeType := ToDateTime;
    else
      FConvertDateTimeType := ToDateTime;
  end;
  Result := FConvertDateTimeType;
end;
{------------------------------------------------------------------------------}
{ SetConvertDateTimeType                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetConvertDateTimeType(const Value: TCrDateTimeType);
var
  ReportOptions : PEReportOptions;
begin
  FConvertDateTimeType := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get ReportOptions from Report}
  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ReportOptions.SetConvertDateTimeType <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {ConvertDateTimeType}
  if Ord(FConvertDateTimeType) <> ReportOptions.convertDateTimeType then
  begin
    ReportOptions.convertDateTimeType := Ord(FConvertDateTimeType);
    {Set ReportOptions}
    
    if not Cr.FCrpeEngine.PESetReportOptions(Cr.FPrintJob, ReportOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'ReportOptions.SetConvertDateTimeType <PESetReportOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetZoomMode                                                                  }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetZoomMode : TCrZoomPreview;
var
  ReportOptions : PEReportOptions;
begin
  Result := FZoomMode;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetZoomMode <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  case ReportOptions.zoomMode of
    PE_ZOOM_FULL_SIZE           : FZoomMode := pwNormal;
    PE_ZOOM_SIZE_FIT_ONE_SIDE   : FZoomMode := pwPageWidth;
    PE_ZOOM_SIZE_FIT_BOTH_SIDES : FZoomMode := pwWholePage;
    else
      FZoomMode := pwNormal;
  end;
  Result := FZoomMode;
end;
{------------------------------------------------------------------------------}
{ SetZoomMode                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetZoomMode(const Value: TCrZoomPreview);
var
  ReportOptions : PEReportOptions;
begin
  FZoomMode := Value;
  if FZoomMode = pwDefault then Exit;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get ReportOptions from Report}
  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ReportOptions.SetZoomMode <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {ZoomMode}
  if Ord(FZoomMode) <> ReportOptions.zoomMode then
  begin
    ReportOptions.zoomMode := Ord(FZoomMode);
    {Set ReportOptions}
    
    if not Cr.FCrpeEngine.PESetReportOptions(Cr.FPrintJob, ReportOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'ReportOptions.SetZoomMode <PESetReportOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetAsyncQuery                                                                }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetAsyncQuery : Boolean;
var
  ReportOptions : PEReportOptions;
begin
  Result := FAsyncQuery;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetAsyncQuery <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FAsyncQuery := Boolean(ReportOptions.doAsyncQuery);
  Result := FAsyncQuery;
end;
{------------------------------------------------------------------------------}
{ SetAsyncQuery                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetAsyncQuery(const Value: Boolean);
var
  ReportOptions : PEReportOptions;
begin
  FAsyncQuery := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get ReportOptions from Report}
  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ReportOptions.SetAsyncQuery <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {AsyncQuery}
  if Ord(FAsyncQuery) <> ReportOptions.doAsyncQuery then
  begin
    ReportOptions.doAsyncQuery := Ord(FAsyncQuery);
    {Set ReportOptions}
    
    if not Cr.FCrpeEngine.PESetReportOptions(Cr.FPrintJob, ReportOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'ReportOptions.SetAsyncQuery <PESetReportOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetPromptMode                                                                }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetPromptMode : TCrPromptMode;
var
  ReportOptions : PEReportOptions;
begin
  Result := FPromptMode;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetPromptMode <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  case ReportOptions.promptMode of
    PE_RPTOPT_PROMPT_NONE   : FPromptMode := pmNone;
    PE_RPTOPT_PROMPT_NORMAL : FPromptMode := pmNormal;
    PE_RPTOPT_PROMPT_ALWAYS : FPromptMode := pmAlways;
  end;
  Result := FPromptMode;
end;
{------------------------------------------------------------------------------}
{ SetPromptMode                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetPromptMode(const Value: TCrPromptMode);
var
  ReportOptions : PEReportOptions;
begin
  FPromptMode := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get ReportOptions from Report}
  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ReportOptions.SetPromptMode <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {PromptMode}
  if Ord(FPromptMode) <> ReportOptions.promptMode then
  begin
    ReportOptions.promptMode := Ord(FPromptMode);
    {Set ReportOptions}
    
    if not Cr.FCrpeEngine.PESetReportOptions(Cr.FPrintJob, ReportOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'ReportOptions.SetPromptMode <PESetReportOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetSelectDistinctRecords                                                     }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetSelectDistinctRecords : Boolean;
var
  ReportOptions : PEReportOptions;
begin
  Result := FSelectDistinctRecords;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetSelectDistinctRecords <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FSelectDistinctRecords := Boolean(ReportOptions.selectDistinctRecords);
  Result := FSelectDistinctRecords;
end;
{------------------------------------------------------------------------------}
{ SetSelectDistinctRecords                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetSelectDistinctRecords(const Value: Boolean);
var
  ReportOptions : PEReportOptions;
begin
  FSelectDistinctRecords := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get ReportOptions from Report}
  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ReportOptions.SetSelectDistinctRecords <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {SelectDistinctRecords}
  if Ord(FSelectDistinctRecords) <> ReportOptions.selectDistinctRecords then
  begin
    ReportOptions.selectDistinctRecords := Ord(FSelectDistinctRecords);
    {Set ReportOptions}
    
    if not Cr.FCrpeEngine.PESetReportOptions(Cr.FPrintJob, ReportOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'ReportOptions.SetSelectDistinctRecords <PESetReportOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetAlwaysSortLocally                                                         }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetAlwaysSortLocally : Boolean;
var
  ReportOptions : PEReportOptions;
begin
  Result := FAlwaysSortLocally;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetAlwaysSortLocally <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FAlwaysSortLocally := Boolean(ReportOptions.alwaysSortLocally);
  Result := FAlwaysSortLocally;
end;
{------------------------------------------------------------------------------}
{ SetAlwaysSortLocally                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetAlwaysSortLocally(const Value: Boolean);
var
  ReportOptions : PEReportOptions;
begin
  FAlwaysSortLocally := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get ReportOptions from Report}
  
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ReportOptions.SetAlwaysSortLocally <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {SelectDistinctRecords}
  if Ord(FAlwaysSortLocally) <> ReportOptions.alwaysSortLocally then
  begin
    ReportOptions.alwaysSortLocally := Ord(FAlwaysSortLocally);
    {Set ReportOptions}
    
    if not Cr.FCrpeEngine.PESetReportOptions(Cr.FPrintJob, ReportOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'ReportOptions.SetAlwaysSortLocally <PESetReportOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetIsReadOnly                                                                }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetIsReadOnly : Boolean;
var
  ReportOptions : PEReportOptions;
begin
  Result := FSelectDistinctRecords;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;


  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetIsReadOnly <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FIsReadOnly := Boolean(ReportOptions.isReadOnly);
  Result := FIsReadOnly;
end;
{------------------------------------------------------------------------------}
{ SetIsReadOnly                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetIsReadOnly(const Value: Boolean);
begin
  {Read-only}
end;
{------------------------------------------------------------------------------}
{ GetCanSelectDistinctRecords                                                  }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetCanSelectDistinctRecords : Boolean;
var
  ReportOptions : PEReportOptions;
begin
  Result := FCanSelectDistinctRecords;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;


  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetCanSelectDistinctRecords <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FCanSelectDistinctRecords := Boolean(ReportOptions.canSelectDistinctRecords);
  Result := FCanSelectDistinctRecords;
end;
{------------------------------------------------------------------------------}
{ SetCanSelectDistinctRecords                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetCanSelectDistinctRecords(const Value: Boolean);
begin
  {Read-only}
end;
{------------------------------------------------------------------------------}
{ GetUseDummyData                                                              }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetUseDummyData : Boolean;
var
  ReportOptions : PEReportOptions;
begin
  Result := FUseDummyData;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetUseDummyData <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FUseDummyData := Boolean(ReportOptions.useDummyData);
  Result := FUseDummyData;
end;
{------------------------------------------------------------------------------}
{ SetUseDummyData                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetUseDummyData(const Value: Boolean);
var
  ReportOptions : PEReportOptions;
begin
  FUseDummyData := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get ReportOptions from Report}

  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ReportOptions.SetUseDummyData <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {UseDummyData}
  if Ord(FUseDummyData) <> ReportOptions.useDummyData then
  begin
    ReportOptions.useDummyData := Ord(FUseDummyData);
    {Set ReportOptions}
    if not Cr.FCrpeEngine.PESetReportOptions(Cr.FPrintJob, ReportOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'ReportOptions.SetUseDummyData <PESetReportOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetConvertOtherNullsToDefault                                                }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetConvertOtherNullsToDefault : Boolean;
var
  ReportOptions : PEReportOptions;
begin
  Result := FConvertOtherNullsToDefault;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetConvertOtherNullsToDefault <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FConvertOtherNullsToDefault := Boolean(ReportOptions.convertOtherNullsToDefault);
  Result := FConvertOtherNullsToDefault;
end;
{------------------------------------------------------------------------------}
{ SetConvertOtherNullsToDefault                                                }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetConvertOtherNullsToDefault(const Value: Boolean);
var
  ReportOptions : PEReportOptions;
begin
  FConvertOtherNullsToDefault := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get ReportOptions from Report}
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ReportOptions.SetConvertOtherNullsToDefault <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {SelectDistinctRecords}
  if Ord(FConvertOtherNullsToDefault) <> ReportOptions.convertOtherNullsToDefault then
  begin
    ReportOptions.convertOtherNullsToDefault := Ord(FConvertOtherNullsToDefault);
    {Set ReportOptions}
    if not Cr.FCrpeEngine.PESetReportOptions(Cr.FPrintJob, ReportOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'ReportOptions.SetConvertOtherNullsToDefault <PESetReportOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetVerifyStoredProcOnRefresh                                                 }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetVerifyStoredProcOnRefresh : Boolean;
var
  ReportOptions : PEReportOptions;
begin
  Result := FVerifyStoredProcOnRefresh;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetVerifyStoredProcOnRefresh <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FVerifyStoredProcOnRefresh := Boolean(ReportOptions.verifyStoredProceduresOnFirstRefresh);
  Result := FVerifyStoredProcOnRefresh;
end;
{------------------------------------------------------------------------------}
{ SetVerifyStoredProcOnRefresh                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetVerifyStoredProcOnRefresh(const Value: Boolean);
var
  ReportOptions : PEReportOptions;
begin
  FVerifyStoredProcOnRefresh := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get ReportOptions from Report}
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ReportOptions.SetVerifyStoredProcOnRefresh <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {SelectDistinctRecords}
  if Ord(FVerifyStoredProcOnRefresh) <> ReportOptions.verifyStoredProceduresOnFirstRefresh then
  begin
    ReportOptions.verifyStoredProceduresOnFirstRefresh := Ord(FVerifyStoredProcOnRefresh);
    {Set ReportOptions}
    if not Cr.FCrpeEngine.PESetReportOptions(Cr.FPrintJob, ReportOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'ReportOptions.SetVerifyStoredProcOnRefresh <PESetReportOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetRetainImageColourDepth                                                    }
{------------------------------------------------------------------------------}
function TCrpeReportOptions.GetRetainImageColourDepth : Boolean;
var
  ReportOptions : PEReportOptions;
begin
  Result := FRetainImageColourDepth;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ReportOptions.GetRetainImageColourDepth <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FRetainImageColourDepth := Boolean(ReportOptions.keepImageColourDepth);
  Result := FRetainImageColourDepth;
end;
{------------------------------------------------------------------------------}
{ SetRetainImageColourDepth                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeReportOptions.SetRetainImageColourDepth(const Value: Boolean);
var
  ReportOptions : PEReportOptions;
begin
  FRetainImageColourDepth := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get ReportOptions from Report}
  if not Cr.FCrpeEngine.PEGetReportOptions(Cr.FPrintJob, ReportOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ReportOptions.SetRetainImageColourDepth <PEGetReportOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {SelectDistinctRecords}
  if Ord(FRetainImageColourDepth) <> ReportOptions.keepImageColourDepth then
  begin
    ReportOptions.keepImageColourDepth := Ord(FRetainImageColourDepth);
    {Set ReportOptions}
    if not Cr.FCrpeEngine.PESetReportOptions(Cr.FPrintJob, ReportOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'ReportOptions.SetRetainImageColourDepth <PESetReportOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ TCrpeMargins Class Definition                                                }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeMargins.Create;
begin
  inherited Create;
  {Set defaults}
  FLeft   := -1;
  FRight  := -1;
  FTop    := -1;
  FBottom := -1;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeMargins.Clear;
begin
  SetLeft(-1);
  SetRight(-1);
  SetTop(-1);
  SetBottom(-1);
end;
{------------------------------------------------------------------------------}
{ GetLeft                                                                      }
{------------------------------------------------------------------------------}
function TCrpeMargins.GetLeft : Smallint;
var
  nLeft,
  nRight,
  nTop,
  nBottom : Word;
begin
  Result := FLeft;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;
  {Get Margins}
  
  if not Cr.FCrpeEngine.PEGetMargins(Cr.FPrintJob, nLeft, nRight, nTop, nBottom) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Margins.GetLeft <PEGetMargins>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FLeft := nLeft;
  Result := FLeft;
end;
{------------------------------------------------------------------------------}
{ SetLeft                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeMargins.SetLeft (const Value: Smallint);
var
  nLeft   : Word;
  nRight  : Word;
  nTop    : Word;
  nBottom : Word;
  rMrg    : integer;
begin
  FLeft := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get Margins from Report}
  
  if not Cr.FCrpeEngine.PEGetMargins(Cr.FPrintJob, nLeft, nRight, nTop, nBottom) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Margins.SetLeft <PEGetMargins>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Compare Margins}
  rMrg := nLeft;
  if FLeft <> rMrg then
  begin
    {Use default margin settings for current printer}
    if (FLeft < 0) then
      nLeft := PE_SM_DEFAULT {32768}
    {Use new value passed in}
    else if (FLeft > -1) then
      nLeft := FLeft;

    {Set Margins}
    
    if not Cr.FCrpeEngine.PESetMargins(Cr.FPrintJob, nLeft, nRight, nTop, nBottom) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Margins.SetLeft <PESetMargins>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetRight                                                                     }
{------------------------------------------------------------------------------}
function TCrpeMargins.GetRight : Smallint;
var
  nLeft,
  nRight,
  nTop,
  nBottom : Word;
begin
  Result := FRight;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;
  {Get Margins}
  
  if not Cr.FCrpeEngine.PEGetMargins(Cr.FPrintJob, nLeft, nRight, nTop, nBottom) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Margins.GetRight <PEGetMargins>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FRight := nRight;
  Result := FRight;
end;
{------------------------------------------------------------------------------}
{ SetRight                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeMargins.SetRight (const Value: Smallint);
var
  nLeft,
  nRight,
  nTop,
  nBottom : Word;
  rMrg   : integer;
begin
  FRight := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get Margins from Report}
  
  if not Cr.FCrpeEngine.PEGetMargins(Cr.FPrintJob, nLeft, nRight, nTop, nBottom) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Margins.SetRight <PEGetMargins>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Compare Margins}
  rMrg := nRight;
  if FRight <> rMrg then
  begin
    {Use default margin settings for current printer}
    if (FRight < 0) then
      nRight := PE_SM_DEFAULT {32768}
    {Use new value passed in}
    else if (FRight > -1) then
      nRight := FRight;

    {Set Margins}
    
    if not Cr.FCrpeEngine.PESetMargins(Cr.FPrintJob, nLeft, nRight, nTop, nBottom) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Margins.SetRight <PESetMargins>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetTop                                                                       }
{------------------------------------------------------------------------------}
function TCrpeMargins.GetTop : Smallint;
var
  nLeft,
  nRight,
  nTop,
  nBottom : Word;
begin
  Result := FTop;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;
  {Get Margins}
  
  if not Cr.FCrpeEngine.PEGetMargins(Cr.FPrintJob, nLeft, nRight, nTop, nBottom) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Margins.GetTop <PEGetMargins>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FTop := nTop;
  Result := FTop;
end;
{------------------------------------------------------------------------------}
{ SetTop                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeMargins.SetTop (const Value: Smallint);
var
  nLeft,
  nRight,
  nTop,
  nBottom : Word;
  rMrg    : integer;
begin
  FTop := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get Margins from Report}
  
  if not Cr.FCrpeEngine.PEGetMargins(Cr.FPrintJob, nLeft, nRight, nTop, nBottom) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Margins.SetTop <PEGetMargins>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Compare Margins}
  rMrg := nTop;
  if FTop <> rMrg then
  begin
    {Use default margin settings for current printer}
    if (FTop < 0) then
      nTop := PE_SM_DEFAULT {32768}
    {Use new value passed in}
    else if (FTop > -1) then
      nTop := FTop;

    {Set Margins}
    
    if not Cr.FCrpeEngine.PESetMargins(Cr.FPrintJob, nLeft, nRight, nTop, nBottom) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Margins.SetTop <PESetMargins>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetBottom                                                                    }
{------------------------------------------------------------------------------}
function TCrpeMargins.GetBottom : Smallint;
var
  nLeft,
  nRight,
  nTop,
  nBottom : Word;
begin
  Result := FBottom;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;
  {Get Margins}
  
  if not Cr.FCrpeEngine.PEGetMargins(Cr.FPrintJob, nLeft, nRight, nTop, nBottom) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Margins.GetBottom <PEGetMargins>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FBottom := nBottom;
  Result := FBottom;
end;
{------------------------------------------------------------------------------}
{ SetBottom                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeMargins.SetBottom (const Value: Smallint);
var
  nLeft,
  nRight,
  nTop,
  nBottom : Word;
  rMrg    : integer;
begin
  FBottom := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  {Get Margins from Report}
  
  if not Cr.FCrpeEngine.PEGetMargins(Cr.FPrintJob, nLeft, nRight, nTop, nBottom) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Margins.SetBottom <PEGetMargins>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Compare Margins}
  rMrg := nBottom;
  if FBottom <> rMrg then
  begin
    {Use default margin settings for current printer}
    if (FBottom < 0) then
      nBottom := PE_SM_DEFAULT {32768}
    {Use new value passed in}
    else if (FBottom > -1) then
      nBottom := FBottom;

    {Set Margins}
    
    if not Cr.FCrpeEngine.PESetMargins(Cr.FPrintJob, nLeft, nRight, nTop, nBottom) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Margins.SetBottom <PESetMargins>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ TCrpePrintDate Class Definition                                              }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpePrintDate.Create;
begin
  inherited Create;
  {Set defaults}
  FDay   := 0;
  FMonth := 0;
  FYear  := 0;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpePrintDate.Clear;
begin
  SetDay(0);
  SetMonth(0);
  SetYear(0);
end;
{------------------------------------------------------------------------------}
{ GetDay                                                                       }
{------------------------------------------------------------------------------}
function TCrpePrintDate.GetDay : Smallint;
var
  rptYear  : Smallint;
  rptMonth : Smallint;
  rptDay   : Smallint;
begin
  Result := FDay;
  if (Cr = nil) then Exit;
  if Cr.PrintJobs(0) > 0 then
  begin
    {Retrieve PrintDate}
    
    if not Cr.FCrpeEngine.PEGetPrintDate(Cr.PrintJobs(0), rptYear, rptMonth, rptDay) then
    begin
      case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
          'PrintDate.GetDay <PEGetPrintDate>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    FDay := rptDay;
    Result := FDay;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDay                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpePrintDate.SetDay (const Value: Smallint);
var
  rptYear  : Smallint;
  rptMonth : Smallint;
  rptDay   : Smallint;
begin
  FDay := Value;
  if FDay = 0 then Exit;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Retrieve PrintDate from Report}
  
  if not Cr.FCrpeEngine.PEGetPrintDate(Cr.PrintJobs(0), rptYear, rptMonth, rptDay) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'PrintDate.SetDay <PEGetPrintDate>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Check Day}
  if FDay <> rptDay then
  begin
    rptDay := FDay;
    {Set PrintDate}
    
    if not Cr.FCrpeEngine.PESetPrintDate(Cr.PrintJobs(0), rptYear, rptMonth, rptDay) then
    begin
      case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
          'PrintDate.SetDay <PESetPrintDate>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetMonth                                                                     }
{------------------------------------------------------------------------------}
function TCrpePrintDate.GetMonth : Smallint;
var
  rptYear  : Smallint;
  rptMonth : Smallint;
  rptDay   : Smallint;
begin
  Result := FMonth;
  if (Cr = nil) then Exit;
  if Cr.PrintJobs(0) > 0 then
  begin
    {Retrieve PrintDate from Report}
    
    if not Cr.FCrpeEngine.PEGetPrintDate(Cr.PrintJobs(0), rptYear, rptMonth, rptDay) then
    begin
      case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
          'PrintDate.GetMonth <PEGetPrintDate>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    FMonth := rptMonth;
    Result := FMonth;
  end;
end;
{------------------------------------------------------------------------------}
{ SetMonth                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpePrintDate.SetMonth (const Value: Smallint);
var
  rptYear  : Smallint;
  rptMonth : Smallint;
  rptDay   : Smallint;
begin
  FMonth := Value;
  if FMonth = 0 then Exit;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Retrieve PrintDate from Report}
  
  if not Cr.FCrpeEngine.PEGetPrintDate(Cr.PrintJobs(0), rptYear, rptMonth, rptDay) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'PrintDate.SetMonth <PEGetPrintDate>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Check Month}
  if FMonth <> rptMonth then
  begin
    rptMonth := FMonth;
    {Set PrintDate}
    
    if not Cr.FCrpeEngine.PESetPrintDate(Cr.PrintJobs(0), rptYear, rptMonth, rptDay) then
    begin
      case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
          'PrintDate.SetMonth <PESetPrintDate>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetYear                                                                      }
{------------------------------------------------------------------------------}
function TCrpePrintDate.GetYear : Smallint;
var
  rptYear  : Smallint;
  rptMonth : Smallint;
  rptDay   : Smallint;
begin
  Result := FYear;
  if (Cr = nil) then Exit;
  if Cr.PrintJobs(0) > 0 then
  begin
    
    {Retrieve PrintDate}
    if not Cr.FCrpeEngine.PEGetPrintDate(Cr.PrintJobs(0), rptYear, rptMonth, rptDay) then
    begin
      case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
          'PrintDate.GetYear <PEGetPrintDate>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    FYear := rptYear;
    Result := FYear;
  end;
end;
{------------------------------------------------------------------------------}
{ SetYear                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpePrintDate.SetYear (const Value: Smallint);
var
  rptYear  : Smallint;
  rptMonth : Smallint;
  rptDay   : Smallint;
begin
  FYear := Value;
  if FYear = 0 then Exit;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Retrieve PrintDate from Report}
  
  if not Cr.FCrpeEngine.PEGetPrintDate(Cr.PrintJobs(0), rptYear, rptMonth, rptDay) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'PrintDate.SetYear <PEGetPrintDate>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Compare Year}
  if FYear <> rptYear then
  begin
    rptYear := FYear;
    {Set PrintDate}
    
    if not Cr.FCrpeEngine.PESetPrintDate(Cr.PrintJobs(0), rptYear, rptMonth, rptDay) then
    begin
      case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
          'PrintDate.SetYear <PESetPrintDate>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ TCrpeExportEmail Class Definition                                            }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeExportEmail.Create;
begin
  inherited Create;
  FToList   := '';
  FCCList   := '';
  FBCCList  := '';
  FSubject  := '';
  FMessage  := '';
  FUserName := '';
  FPassword := '';
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeExportEmail.Clear;
begin
  FCCList  := '';
  FMessage := '';
  FSubject := '';
  FToList  := '';
  FBCCList := '';
  FUserName := '';
  FPassword := '';
end;


{******************************************************************************}
{ TCrpeExportExchange Class Definition                                         }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeExportExchange.Create;
begin
  inherited Create;
  FFolder   := '';
  FPassword := '';
  FProfile  := '';
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeExportExchange.Clear;
begin
  FFolder   := '';
  FPassword := '';
  FProfile  := '';
end;

{******************************************************************************}
{ TCrpeExportLotusNotes Class Definition                                       }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeExportLotusNotes.Create;
begin
  inherited Create;
  {Set defaults}
  FDBName   := '';
  FFormName := '';
  FComments := '';
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeExportLotusNotes.Clear;
begin
  {Set defaults}
  FDBName := '';
  FFormName := '';
  FComments := '';
end;


{******************************************************************************}
{ TCrpeExportODBC Class Definition                                             }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeExportODBC.Create;
begin
  inherited Create;
  FPrompt   := False;
  FPassword := '';
  FSource   := '';
  FTable    := '';
  FUser     := '';
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeExportODBC.Clear;
begin
  FPrompt   := False;
  FPassword := '';
  FSource   := '';
  FTable    := '';
  FUser     := '';
end;


{******************************************************************************}
{ TCrpeExportExcel Class Definition                                            }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeExportExcel.Create;
begin
  inherited Create;
  {Set defaults}
  FColumnWidth             := ByArea;    //both formats
  FConstant                := 36;        //both formats
  FArea                    := '';        //whole report
  FWorksheetFunctions      := False;     //for Data-Only format
  FCreatePageBreaks        := False;     //for page-based format only
  FConvertDatesToStrings   := False;     //for page-based format only
  FUsePageRange            := False;     //for page-based format only
  FFirstPage               := 1;         //for page-based format only
  FLastPage                := 1;         //for page-based format only
  FExportHeaderFooter      := True;      //obsolete (use FExportPageAreaPair)
  FChopPageHeader          := True;      //for Data-Only format
  FXlsType                 := ExcelStandard;
  FExportImagesInDataOnly  := False;     //for Data-Only format
  FUseFormatInDataOnly     := False;     //for Data-Only format
  FMaintainColumnAlignment := False;     //for Data-Only format
  FMaintainRelativeObjPosition := False; //for Data-Only format
  FShowGridlines           := False;     //for page-based format only
  FExportPageAreaPair      := PHPFOncePerReport; //for page-based format only
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeExportExcel.Clear;
begin
  FColumnWidth             := ByArea;
  FConstant                := 36;
  FArea                    := '';
  FWorksheetFunctions      := False;
  FCreatePageBreaks        := False;
  FConvertDatesToStrings   := False;
  FUsePageRange            := False;
  FFirstPage               := 1;
  FLastPage                := 1;
  FExportHeaderFooter      := True;
  FChopPageHeader          := True;
  FXlsType                 := ExcelStandard;
  FExportImagesInDataOnly  := False;
  FUseFormatInDataOnly     := False;
  FMaintainColumnAlignment := False;
  FMaintainRelativeObjPosition := False;
  FShowGridlines           := False;
  FExportPageAreaPair      := PHPFOncePerReport;
end;


{******************************************************************************}
{ TCrpeExportHTML Class Definition                                             }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeExportHTML.Create;
begin
  inherited Create;
  FPageNavigator := True;
  FSeparatePages := True;
  FUsePageRange  := False;
  FFirstPage     := 1;
  FLastPage      := 1;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeExportHTML.Clear;
begin
  FPageNavigator := True;
  FSeparatePages := True;
  FUsePageRange  := False;
  FFirstPage     := 1;
  FLastPage      := 1;
end;

{******************************************************************************}
{ TCrpeExportPDF Class Definition                                              }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeExportPDF.Create;
begin
  inherited Create;
  FPrompt       := False;
  FUsePageRange := False;
  FFirstPage    := 1;
  FLastPage     := 1;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeExportPDF.Clear;
begin
  FPrompt       := False;
  FUsePageRange := False;
  FFirstPage    := 1;
  FLastPage     := 1;
end;

{******************************************************************************}
{ TCrpeExportRTF Class Definition                                              }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeExportRTF.Create;
begin
  inherited Create;
  FPrompt       := False;
  FUsePageRange := False;
  FFirstPage    := 1;
  FLastPage     := 1;
  FIncludePgBreaks := False;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeExportRTF.Clear;
begin
  FPrompt       := False;
  FUsePageRange := False;
  FFirstPage    := 1;
  FLastPage     := 1;
  FIncludePgBreaks := False;
end;

{******************************************************************************}
{ TCrpeExportWord Class Definition                                             }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeExportWord.Create;
begin
  inherited Create;
  FPrompt       := False;
  FUsePageRange := False;
  FFirstPage    := 1;
  FLastPage     := 1;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeExportWord.Clear;
begin
  FPrompt       := False;
  FUsePageRange := False;
  FFirstPage    := 1;
  FLastPage     := 1;
end;

{******************************************************************************}
{ TCrpeExportText Class Definition                                             }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeExportText.Create;
begin
  inherited Create;
  FUseRptNumberFmt   := False;
  FUseRptDateFmt     := False;
  FStringDelimiter   := '"';
  FFieldSeparator    := ',';
  FLinesPerPage      := 60;
  FCharPerInch       := 0; //zero means use default
  FRecordsType       := ColumnsWithSpaces;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeExportText.Clear;
begin
  FUseRptNumberFmt   := False;
  FUseRptDateFmt     := False;
  FStringDelimiter   := '"';
  FFieldSeparator    := ',';
  FLinesPerPage      := 60;
  FCharPerInch       := 0;
  FRecordsType       := ColumnsWithSpaces;
end;

{******************************************************************************}
{ TCrpeExportXML Class Definition                                              }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeExportXML.Create;
begin
  inherited Create;
  FPrompt        := False;
  FSeparatePages := True;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeExportXML.Clear;
begin
  FPrompt        := False;
  FSeparatePages := True;
end;

{******************************************************************************}
{ TCrpeExportOptions Class Definition                                          }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeExportOptions.Create;
begin
  inherited Create;
  {Set defaults}
  FFileName          := '';
  FFileType          := TextFormat;
  FDestination       := toFile;
  FPromptForOptions  := False;
  FPromptOnOverwrite := False;
  FEmail             := TCrpeExportEmail.Create;
  FExchange          := TCrpeExportExchange.Create;
  FODBC              := TCrpeExportODBC.Create;
  FExcel             := TCrpeExportExcel.Create;
  FLotusNotes        := TCrpeExportLotusNotes.Create;
  FHTML              := TCrpeExportHTML.Create;
  FRTF               := TCrpeExportRTF.Create;
  FWord              := TCrpeExportWord.Create;
  FPDF               := TCrpeExportPDF.Create;
  FText              := TCrpeExportText.Create;
  FXML               := TCrpeExportXML.Create;
  FSubClassList.Add(FEmail);
  FSubClassList.Add(FExchange);
  FSubClassList.Add(FODBC);
  FSubClassList.Add(FExcel);
  FSubClassList.Add(FLotusNotes);
  FSubClassList.Add(FHTML);
  FSubClassList.Add(FRTF);
  FSubClassList.Add(FWord);
  FSubClassList.Add(FPDF);
  FSubClassList.Add(FText);
  FSubClassList.Add(FXML);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeExportOptions.Destroy;
begin
  FEmail.Free;
  FExchange.Free;
  FODBC.Free;
  FExcel.Free;
  FLotusNotes.Free;
  FHTML.Free;
  FRTF.Free;
  FWord.Free;
  FPDF.Free;
  FText.Free;
  FXML.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeExportOptions.Clear;
begin
  FFileName          := '';
  FFileType          := TextFormat;
  FDestination       := toFile;
  FPromptForOptions  := False;
  FPromptOnOverwrite := False;
  FEmail.Clear;
  FExchange.Clear;
  FODBC.Clear;
  FExcel.Clear;
  FLotusNotes.Clear;
  FHTML.Clear;
  FRTF.Clear;
  FText.Clear;
  FWord.Clear;
  FPDF.Clear;
  FXML.Clear;
end;
{------------------------------------------------------------------------------}
{ Send                                                                         }
{------------------------------------------------------------------------------}
function TCrpeExportOptions.Send : Boolean;
const
  FormatExt: array[TCrExportType] of PEDllNameType = ('.pdf',
    '.rpt', '.html', '.html', '.xls', '.doc', '.doc', '', '.rec',
    '.txt', '.rtf', '.csv', '.ttx', '.txt', '.xml');
var
  SectionCode  : Smallint;
  nGroup       : integer;
  dwFirst      : PEDWordArray;
  dwLast       : PEDWordArray;

  { Private DiskOptions }
  function DiskOptions(const Key : TCrExportDestination) : Pointer;
  begin
    Result := nil;
    case Key of
      {Disk}
      toFile :
        begin
          StrPCopy(PEExpOptions.destinationDLLName, 'uxddisk.dll');
          PEExpOptions.destinationType := UXDDiskType;
          UXDDisk.structSize := SizeOf(UXDDiskOptions);
          UXDDisk.filename := PChar(FFileName);
          Result := Addr(UXDDisk);
        end;
      {MAPI}
      toEmailViaMapi :
        begin
          StrPCopy(PEExpOptions.destinationDLLName, 'uxdmapi.dll');
          PEExpOptions.destinationType := UXDMAPIType;
          UXDMapi.structSize := SizeOf(UXDMAPIOptions);
          UXDMapi.toList := PChar(FEmail.FToList);
          UXDMapi.ccList := PChar(FEmail.FCCList);
          UXDMapi.subject := PChar(FEmail.FSubject);
          UXDMapi.mailmessage := PChar(FEmail.FMessage);
          UXDMapi.nRecipients := 0;
          UXDMapi.recipients := nil;
          UXDMapi.userName := PChar(FEmail.FUserName);
          UXDMapi.password := PChar(FEmail.FPassword);
          UXDMapi.nEncodedBytes := 0;
          Result := Addr(UXDMapi);
        end;
      {VIM}
      toEMailViaVIM :
        begin
          StrPCopy(PEExpOptions.destinationDLLName, 'uxdvim.dll');
          PEExpOptions.destinationType := UXDVIMType;
          UXDVIM.structSize := SizeOf(UXDVIMOptions);
          UXDVIM.toList := PChar(FEmail.FToList);
          UXDVIM.bccList := PChar(FEmail.FCCList);
          UXDVIM.ccList := PChar(FEmail.FBCCList);
          UXDVIM.subject := PChar(FEmail.FSubject);
          UXDVIM.mailmessage := PChar(FEmail.FMessage);
          UXDVIM.userName := PChar(FEmail.FUserName);
          UXDVIM.password := PChar(FEmail.FPassword);
          UXDVIM.nEncodedBytes := 0;
          Result := Addr(UXDVIM);
        end;
      {Exchange}
      toMSExchange :
        begin
          StrPCopy(PEExpOptions.destinationDLLName, 'uxdpost.dll');
          PEExpOptions.destinationType := UXDExchFolderType;
          UXDExchange.structsize := SizeOf(UXDPostFolderOptions);
          UXDExchange.pszProfile := PChar(FExchange.FProfile);
          UXDExchange.pszPassword := PChar(FExchange.FPassword);
          UXDExchange.wDestType := 1011; {UXDPostDocMessage}
          UXDExchange.pszFolderPath := PChar(FExchange.FFolder);
          UXDExchange.nEncodedBytes := 0;
          Result := Addr(UXDExchange);
        end;
      {Lotus Notes DB}
      toLotusNotes :
        begin
          StrPCopy(PEExpOptions.destinationDLLName, 'uxdnotes.dll');
          PEExpOptions.destinationType := UXDNotesType;
          UXDNotes.structsize := SizeOf(UXDNotesOptions);
          UXDNotes.szDBName := PChar(FLotusNotes.FDBName);
          UXDNotes.szFormName := PChar(FLotusNotes.FFormName);
          UXDNotes.szComments := PChar(FLotusNotes.FComments);
          Result := Addr(UXDNotes);
        end;
      {Application}
      toApplication :
        begin
          {If AppName not defined: set destination to Application via PE}
          if IsStrEmpty(FAppName) then
          begin
            StrPCopy(PEExpOptions.destinationDLLName, 'uxdapp.dll');
            PEExpOptions.destinationType := UXDApplicationType;
            UXDApp.structSize := SizeOf(UXDApplicationOptions);
            if IsStrEmpty(FFileName) then
              UXDApp.fileName := nil
            else
              UXDApp.fileName := PChar(FFileName);
            PEExpOptions.destinationOptions := Addr(UXDApp);
          end
          {AppName is defined: the VCL will send the file to
           an application.  First set export destination to disk,
           and handle the rest in TCrpe.Execute}
          else
          begin
            StrPCopy(PEExpOptions.destinationDLLName, 'uxddisk.dll');
            PEExpOptions.destinationType := UXDDiskType;
            UXDDisk.structSize := SizeOf(UXDDiskOptions);
            if IsStrEmpty(FFileName) then
            begin
              UXDAppFileName := CrGetTempName(FormatExt[FFileType]);
              UXDApp.fileName := PChar(UXDAppFileName);
            end
            else
              UXDApp.fileName := PChar(FFileName);
            UXDDisk.filename := PChar(FFileName);
            Result := Addr(UXDDisk);
          end;
        end;
    end; { case }
  end; { DiskOptions }


  { Private FormatOptions }
  function FormatOptions(const FType: TCrExportType) : Pointer;
  begin
    Result := nil;
    case FType of
      AdobeAcrobatPDF  :
        begin
          PEExpOptions.formatType := UXFPortableDocumentFormat;
          StrPCopy(PEExpOptions.formatDLLName, 'crxf_pdf.dll');
          UXFPDF.structSize := SizeOf(UXFPDFFormatOptions);
          UXFPDF.exportPageRange := FPDF.FUsePageRange;
          UXFPDF.firstPageNo := FPDF.FFirstPage;
          UXFPDF.lastPageNo := FPDF.FLastPage;
          Result := Addr(UXFPDF);
        end;
      CrystalReportRPT   :
        begin
          PEExpOptions.formatType := UXFCrystalReportType;
          StrPCopy(PEExpOptions.formatDLLName, 'u2fcr.dll');
        end;
      HTML32, HTML40     :
        begin
          if FType = HTML32 then
            PEExpOptions.formatType := UXFHTML32StdType
          else
            PEExpOptions.formatType := UXFHTML40Type;
          StrPCopy(PEExpOptions.formatDLLName, 'crxf_html.dll');
          UXFHTML.structSize := SizeOf(UXFHTML3Options);
          UXFHTML.filename := PChar(FFileName);
          UXFHTML.pageNavigator := FHTML.FPageNavigator;
          UXFHTML.separatePages := FHTML.FSeparatePages;
          UXFHTML.imageExtStyle := UXFJPGExtensionStyle;
          UXFHTML.nPageRanges := Ord(FHTML.FUsePageRange);
          dwFirst[0] := FHTML.FFirstPage;
          dwLast[0] := FHTML.FLastPage;
          UXFHTML.pfirstPageNo := @dwFirst;
          UXFHTML.plastPageNo := @dwLast;
          Result := Addr(UXFHTML);
        end;
      MSExcel            :
        begin
          {Check for Excel export type}
          if (FExcel.FXlsType = ExcelStandard) then
            PEExpOptions.formatType := UXFXl97Type
          else {ExcelDataOnly}
            PEExpOptions.formatType := UXFXlRecDumpType;
          StrPCopy(PEExpOptions.formatDLLName, 'crxf_xls.dll');
          {Set Options}
          UXFXls.structSize := SizeOf(UXFXlsOptions);
          UXFXls.bColumnHeadings := False; {ignored in CR9}
          case FExcel.FColumnWidth of
            ByConstant : UXFXls.bUseConstColWidth := Bool(True);
            ByArea     : UXFXls.bUseConstColWidth := Bool(False);
          end;
          if (FExcel.FConstant > MAX_CONST_COL_WIDTH_IN_TWIPS) or
             (FExcel.FConstant < MIN_CONST_COL_WIDTH_IN_TWIPS) then
            FExcel.FConstant := DEFAULT_COLUMN_WIDTH_IN_TWIPS;
          UXFXls.fConstColWidth := FExcel.FConstant;
          UXFXls.bTabularFormat := False; {ignored in CR9}
          if not StrToSectionCode(FExcel.FArea, SectionCode) then
            UXFXls.baseAreaType := PE_SECT_WHOLE_REPORT
          else
          begin
            nGroup := SectionCode mod 25;
            SectionCode := (SectionCode div 1000);
            UXFXls.baseAreaType := SectionCode;
            UXFXls.baseAreaGroupNum := nGroup + 1;
          end;
          UXFXls.bUseWorksheetFunc := Bool(FExcel.FWorksheetFunctions);
          UXFXls.bExportPageBreaks := Bool(FExcel.FCreatePageBreaks);
          UXFXls.bCnvrtDateValToStr := Bool(FExcel.FConvertDatesToStrings);
          if FExcel.FUsePageRange = True then
            UXFXls.bExportAllPages := Bool(False)
          else
            UXFXls.bExportAllPages := Bool(True);
          UXFXls.bExportPageHeaders := Bool(FExcel.FExportHeaderFooter);
          UXFXls.dwStartPageNumber32 := FExcel.FFirstPage;
          UXFXls.dwEndPageNumber32 := FExcel.FLastPage;
          UXFXls.bChopPageHeader := Bool(FExcel.FChopPageHeader);
          UXFXls.bExportImagesInDataOnly := Bool(FExcel.FExportImagesInDataOnly);
          UXFXls.bUseFormatInDataOnly := Bool(FExcel.FUseFormatInDataOnly);
          UXFXls.bMaintainColumnAlignment := Bool(FExcel.FMaintainColumnAlignment);
          UXFXls.bMaintainRelativeObjectPosition := Bool(FExcel.FMaintainRelativeObjPosition);
          UXFXls.bShowGridlines := Bool(FExcel.FShowGridlines);
          UXFXls.wExportPageAreaPair := Integer(FExcel.FExportPageAreaPair);
          Result := Addr(UXFXls);
        end;
      MSWord             :
        begin
          PEExpOptions.formatType := UXFExactDocFormatType;
          StrPCopy(PEExpOptions.formatDLLName, 'crxf_wordw.dll');
          if not FWord.FPrompt then
          begin
            UXFWord.structSize := SizeOf(UXFEDOCFormatOptions);
            UXFWord.exportPageRange := Bool(FWord.FUsePageRange);
            UXFWord.firstPageNo := FWord.FFirstPage;
            UXFWord.lastPageNo := FWord.FLastPage;
            Result := Addr(UXFWord);
          end;
        end;
      EditableWord       :
        begin
          PEExpOptions.formatType := UFXEditableRTFFormatType;
          StrPCopy(PEExpOptions.formatDLLName, 'crxf_rtf.dll');
          if not FRTF.FPrompt then
          begin
            UXFEditableRTF.structSize := SizeOf(UXFEditableRTFFormatOptions);
            UXFEditableRTF.exportPageRange := FRTF.FUsePageRange;
            UXFEditableRTF.firstPageNo := FRTF.FFirstPage;
            UXFEditableRTF.lastPageNo := FRTF.FLastPage;
            UXFEditableRTF.exportPageBreaks := true;
            Result := Addr(UXFEditableRTF);
          end;
        end;
      ODBCTable          :
        begin
          PEExpOptions.formatType := UXFODBCType;
          StrPCopy(PEExpOptions.formatDLLName, 'u2fodbc.dll');
          if not FODBC.FPrompt then
          begin
            UXFODBC.structSize := SizeOf(UXFODBCOptions);
            UXFODBC.dataSourceName := PChar(FODBC.FSource);
            UXFODBC.dataSourceUserID := PChar(FODBC.FUser);
            UXFODBC.dataSourcePassword := PChar(FODBC.FPassword);
            UXFODBC.exportTableName := PChar(FODBC.FTable);
            UXFODBC.nEncodedBytes := 0;
            Result := Addr(UXFODBC);
          end;
        end;
      Records            :
        begin
          if FText.FRecordsType = ColumnsWithSpaces then
            PEExpOptions.formatType := UXFRecordType
          else
            PEExpOptions.formatType := UXFRecord6Type;
          StrPCopy(PEExpOptions.formatDLLName, 'u2frec.dll');
          UXFRec.structSize := SizeOf(UXFRecordStyleOptions);
          UXFRec.useReportNumberFormat := FText.FUseRptNumberFmt;
          UXFRec.useReportDateFormat := FText.FUseRptDateFmt;
          Result := Addr(UXFRec);
        end;
      ReportDefinition :
        begin
          PEExpOptions.formatType := UXFReportDefinitionType;
          StrPCopy(PEExpOptions.formatDLLName, 'u2frdef.dll');
        end;
      RichText         :
        begin
          PEExpOptions.formatType := UXFExactRichTextFormatType;
          StrPCopy(PEExpOptions.formatDLLName, 'crxf_rtf.dll');
          if not FRTF.FPrompt then
          begin
            UXFRTF.structSize := SizeOf(UXFERTFFormatOptions);
            UXFRTF.exportPageRange := Bool(FRTF.FUsePageRange);
            UXFRTF.firstPageNo := FRTF.FFirstPage;
            UXFRTF.lastPageNo := FRTF.FLastPage;
            Result := Addr(UXFRTF);
          end;
        end;
      SeparatedValues    :
        begin
          PEExpOptions.formatType := UXFSeparatedValuesType;
          StrPCopy(PEExpOptions.formatDLLName, 'u2fsepv.dll');
          UXFSepVal.structSize := SizeOf(UXFCharCommaTabSeparatedOptions);
          UXFSepVal.useReportNumberFormat := FText.FUseRptNumberFmt;
          UXFSepVal.useReportDateFormat := FText.FUseRptDateFmt;
          UXFSepVal.stringDelimiter := FText.FStringDelimiter;
          UXFSepVal.fieldDelimiter := PChar(FText.FFieldSeparator);
          UXFSepVal.nEncodedBytes := 0;
          Result := Addr(UXFSepVal);
        end;
      TabSeparatedText :
        begin
          PEExpOptions.formatType := UXFTabbedTextType;
          StrPCopy(PEExpOptions.formatDLLName, 'u2ftext.dll');
        end;
      TextFormat :
        begin
          PEExpOptions.formatType := UXFPaginatedTextType;
          StrPCopy(PEExpOptions.formatDLLName, 'u2ftext.dll');
          UXFPagText.structSize := SizeOf(UXFPaginatedTextOptions);
          UXFPagText.nLinesPerPage := FText.FLinesPerPage;
          if FText.FCharPerInch = 0 then
            UXFPagText.useDefaultCPI := Bool(True)
          else
            UXFPagText.useDefaultCPI := Bool(False);
          UXFPagText.userDefinedCPI := FText.FCharPerInch;
          Result := Addr(UXFPagText);
        end;
      XML1 :
        begin
          PEExpOptions.formatType := UXFXMLType;
          StrPCopy(PEExpOptions.formatDLLName, 'u2fxml.dll');
          if not FXML.FPrompt then
          begin
            UXFXML.structSize := SizeOf(UXFXmlOptions);
            UXFXML.fileName := PChar(FFileName);
            UXFXML.allowMultipleFiles := Smallint(FXML.FSeparatePages);
            Result := Addr(UXFXML);
          end;
        end;
    end; { case ExportType }
  end;

{Main procedure: Export.Send}
begin
  Result := False;
  if (Cr = nil) then Exit;
  if not Cr.OpenPrintJob then Exit;

  if FPromptForOptions then
  begin
    PEExpOptions.structSize := SizeOf(PEExportOptions);
    if not Cr.FCrpeEngine.PEGetExportOptions(Cr.FPrintJob, PEExpOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errCancelDialog,errEngine,'',
          'Export.Send <PEGetExportOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Result := True;
  end
  else
  begin
    {Set Format Options}
    pFormat := nil;
    pFormat := FormatOptions(FFileType);
    PEExpOptions.formatOptions := pFormat;

    {Set DestinationOptions}
    pDisk := nil;
    pDisk := DiskOptions(FDestination);
    PEExpOptions.destinationOptions := pDisk;
  end;

  if not Cr.FCrpeEngine.PEExportTo(Cr.FPrintJob, PEExpOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Export.Send <PEExportTo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := True;
end;


{******************************************************************************}
{ TCrpePrinter Class Definition                                                }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpePrinter.Create;
begin
  inherited Create;
  {Set defaults}
  FName   := '';
  FPort   := '';
  FDriver := '';
  FMode   := 0;
  FPMode  := nil;
  FOrientation := orDefault;
  FPreserveRptSettings := [];
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpePrinter.Clear;
begin
  FName := '';
  FPort := '';
  FDriver := '';
  FMode := 0;
  FPMode := nil;
  FOrientation := orDefault;
  FPreserveRptSettings := [];
end;
{------------------------------------------------------------------------------}
{ FreeDevMode                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpePrinter.FreeDevMode;
begin
  if not Assigned(FPMode) then Exit;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  
  if not Cr.FCrpeEngine.PEFreeDevMode (Cr.FPrintJob, FPMode) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'Printer.FreeDevMode <PEFreeDevMode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetDMPointerFromHandle                                                       }
{  Gets a DevMode pointer from a Handle                                        }
{------------------------------------------------------------------------------}
function TCrpePrinter.GetDMPointerFromHandle(xHandle: THandle): PDevMode;
var
  pDM : PDevMode;
begin
  Result := nil;
  if xHandle = 0 then Exit;
  pDM := GlobalLock(xHandle);
  GlobalUnlock(xHandle);
  {If GlobalLock fails it could be a local variable}
  if pDM = nil then
    pDM := PDevMode(Pointer(xHandle)^);
  Result := pDM;
end;
{------------------------------------------------------------------------------}
{ Retrieve                                                                     }
{  Gets the printer information from the Report and fills in the               }
{  PrinterName, PrinterDriver, PrinterPort, and PrinterMode properties         }
{------------------------------------------------------------------------------}
function TCrpePrinter.Retrieve : Boolean;
var
  hDriver, hPrinter, hPort : hWnd;
  iDriver, iPrinter, iPort : Smallint;
  pDriver, pPrinter, pPort : PChar;
  pxDevMode                : PDevMode;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if not Cr.OpenPrintJob then Exit;
  pxDevMode := nil;

  
  if Cr.FCrpeEngine.PEGetSelectedPrinter(Cr.PrintJobs(0), hDriver, iDriver, hPrinter, iPrinter,
     hPort, iPort, pxDevMode) then
  begin
    {The DevMode pointer from the Report returns Nil:
     This means that Default Printer, Default Options
     are selected in the Printer Setup dialog for that Report.
     Get Default Printer from System, use Default Orientation.}
    if not Assigned(pxDevMode) then
    begin
      FOrientation := orDefault;
      Printers.Printer.PrinterIndex := -1;
      Result := GetCurrent(False);
    end
    {Read Report Orientation}
    else
    begin
      case pxDevMode^.dmOrientation of
        dmOrient_Portrait  : FOrientation := orPortrait;
        dmOrient_Landscape : FOrientation := orLandscape;
        else
          FOrientation := orDefault;
      end;

      {PrinterName}
      pPrinter := StrAlloc(iPrinter);
      if not Cr.FCrpeEngine.PEGetHandleString(hPrinter, pPrinter, iPrinter) then
      begin
        StrDispose(pPrinter);
        case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
            'Printer.Retrieve - Name <PEGetHandleString>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      FName := String(pPrinter);
      StrDispose(pPrinter);

      {Bug: ADAPT00158296: OnPrinterSend Event do  not get raised when
        printer setting is send to printer. Following statements are added.
        If FName is not returned then use pxDevMode^.dmDeviceName to get
        it - Shashikant,DishaTech - 19/4/03}
      //I'm not sure this will work in all cases, sometimes dmDeviceName is
      //truncated.  Maybe we should let developers worry about this since the
      //Retrieve function returns FALSE if FName is blank? -- FZ Jul 4, 2003
      if IsStrEmpty(FName) then
        FName := pxDevMode^.dmDeviceName;

      {PrinterDriver}
      pDriver := StrAlloc(iDriver);
      if not Cr.FCrpeEngine.PEGetHandleString(hDriver, pDriver, iDriver) then
      begin
        StrDispose(pDriver);
        case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
            'Printer.Retrieve - Driver <PEGetHandleString>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      FDriver := String(pDriver);
      StrDispose(pDriver);

      {PrinterPort}
      pPort := StrAlloc(iPort);
      if not Cr.FCrpeEngine.PEGetHandleString(hPort, pPort, iPort) then
      begin
        StrDispose(pPort);
        case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
            'Printer.Retrieve - Port <PEGetHandleString>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      FPort := String(pPort);
      StrDispose(pPort);

      {PrinterMode}
      SetPMode(pxDevMode);

      if (not IsStrEmpty(FName)) and
         (not IsStrEmpty(FDriver)) and
         (not IsStrEmpty(FPort)) then
        Result := True
    end;
  end
  {PEGetSelectedPrinter fails: 'No Printer' is probably checked in
   the Printer Setup dialog for the Report, or the call failed.}
  else
  begin
    FName := '';
    FPort := '';
    FDriver := '';
    FMode := 0;
    FPMode := nil;
    FOrientation := orDefault;
  end;
end;
{------------------------------------------------------------------------------}
{ RetrieveFromReport                                                           }
{------------------------------------------------------------------------------}
function TCrpePrinter.RetrieveFromReport (var sName: string; var sDriver: string;
  var sPort: string; var pxDevMode: PDevMode) : Boolean;
var
  hDriver, hPrinter, hPort : hWnd;
  iDriver, iPrinter, iPort : Smallint;
  pPrinter, pDriver, pPort : PChar;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if not Cr.OpenPrintJob then Exit;
  pxDevMode := nil;

  if Cr.FCrpeEngine.PEGetSelectedPrinter(Cr.PrintJobs(0), hDriver, iDriver, hPrinter, iPrinter,
     hPort, iPort, pxDevMode) then
  begin
    {The DevMode pointer from the Report returns Nil:
     This means that Default Printer, Default Options
     are selected in the Printer Setup dialog for that Report.
     Get Default Printer from System, use Default Orientation.}
    if not Assigned(pxDevMode) then
    begin
      Result := GetCurrent(False);
    end
    {Read Report Orientation}
    else
    begin
      {PrinterName}
      pPrinter := StrAlloc(iPrinter);
      if not Cr.FCrpeEngine.PEGetHandleString(hPrinter, pPrinter, iPrinter) then
      begin
        StrDispose(pPrinter);
        case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
            'Printer.RetrieveFromReport - Name <PEGetHandleString>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      sName := String(pPrinter);
      StrDispose(pPrinter);

      {PrinterDriver}
      pDriver := StrAlloc(iDriver);
      if not Cr.FCrpeEngine.PEGetHandleString(hDriver, pDriver, iDriver) then
      begin
        StrDispose(pDriver);
        case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
            'Printer.RetrieveFromReport - Driver <PEGetHandleString>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      sDriver := String(pDriver);
      StrDispose(pDriver);

      {PrinterPort}
      pPort := StrAlloc(iPort);
      if not Cr.FCrpeEngine.PEGetHandleString(hPort, pPort, iPort) then
      begin
        StrDispose(pPort);
        case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
            'Printer.RetrieveFromReport - Port <PEGetHandleString>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      sPort := String(pPort);
      StrDispose(pPort);

      if (not IsStrEmpty(sName)) and
         (not IsStrEmpty(sDriver)) and
         (not IsStrEmpty(sPort)) then
        Result := True
    end;
  end
  {PEGetSelectedPrinter fails: 'No Printer' is probably checked in
   the Printer Setup dialog for the Report, or the call failed.}
  else
  begin
    sName := '';
    sPort := '';
    sDriver := '';
    pxDevMode := nil;
  end;
end;
{------------------------------------------------------------------------------}
{ GetPrinterInfoFromName                                                       }
{------------------------------------------------------------------------------}
function TCrpePrinter.GetPrinterInfoFromName(PrtName: string): Boolean;
var
  index   : Smallint;
  PrtList : TStringList;
begin
  Result := False;
  PrtList := TStringList.Create;
  GetPrinterNames(PrtList);

  {If Printer Name is "HPLaserjet on LPT1:", get Device Name only}
  index := Printers.Printer.Printers.IndexOf(PrtName);
  if index > -1 then
    PrtName := PrtList[index]          {Get Device Name only}
  else
    index := PrtList.IndexOf(PrtName); {Locate Device Name in list}

  {If the Printer was found, get info}
  if index > -1 then
  begin
    Printers.Printer.PrinterIndex := index;
    if GetCurrent(False) then
      Result := True;
  end;
  PrtList.Free;
end;
{------------------------------------------------------------------------------}
{ GetPrinterNames                                                              }
{  - Fills a stringlist with the currently available Printer Names             }
{  - The List contains Printer Names only, not port as in "HP Laser on LPT1"   }
{------------------------------------------------------------------------------}
procedure TCrpePrinter.GetPrinterNames(List: TStrings);
var
  pName   : PChar;
  pDriver : PChar;
  pPort   : PChar;
  hMode   : THandle;
  i,j     : Smallint;
begin
  {Store the currently selected Printer}
  i := Printers.Printer.PrinterIndex;
  List.Clear;
  pName := StrAlloc(255);
  pDriver := StrAlloc(255);
  pPort := StrAlloc(255);
  for j := 0 to (Printers.Printer.Printers.Count - 1) do
  begin
    Printers.Printer.PrinterIndex := j;
    Printers.Printer.GetPrinter(pName, pDriver, pPort, hMode);
    List.Add(String(pName));
  end;
  {Restore the currently selected Printer}
  Printers.Printer.PrinterIndex := i;
  StrDispose(pName);
  StrDispose(pDriver);
  StrDispose(pPort);
end;
{------------------------------------------------------------------------------}
{ GetCurrent                                                                   }
{  Gets the currently selected system printer information and fills in the     }
{  PrinterName, PrinterDriver, PrinterPort, and PrinterMode properties         }
{  The PreserveDevMode parameter specifies whether this call is being made     }
{  after a Delphi PrintDialog was called or not.  If the PrintDialog was       }
{  called, then the devmode value will be set with meaningful information      }
{  and we don't want to disturb it.  But if only the Printer name was selected }
{  in code, we need to instantiate a devmode by calling SetPrinter/GetPrinter  }
{------------------------------------------------------------------------------}
function TCrpePrinter.GetCurrent(PreserveDevMode: Boolean): Boolean;
var
  hMode   : THandle;
  pName   : PChar;
  pDriver : PChar;
  pPort   : PChar;
  sName   : string;
  sDriver : string;
  sPort   : string;
  i       : integer;
begin
  pName := StrAlloc(255);
  pDriver := StrAlloc(255);
  pPort := StrAlloc(255);
  {Use GetPrinter for the hMode since it will show the current
   settings (orientation, etc.) from a PrintDialog change}
  Printers.Printer.GetPrinter(pName, pDriver, pPort, hMode);

  {Check Driver}
  sDriver := String(pDriver);
  if Length(sDriver) = 0 then
  begin
    GetProfileString('Devices', pName, '', pDriver, MAX_PATH);
    sDriver := String(pDriver);
    i := Pos(',',sDriver);
    sDriver := Copy(sDriver, 1, i-1);
  end;
  FDriver := sDriver;

  {Check Port}
  sPort := String(pPort);
  if Length(sPort) = 0 then
  begin
    GetProfileString('Devices', pName, '', pPort, MAX_PATH);
    sPort := String(pPort);
    i := Pos(',',sPort);
    sPort := Copy(sPort, i + 1, Length(sPort));
  end;
  {Get rid of 'winspool,' prefix}
  i := Pos('winspool,',sPort);
  if i > 0 then sPort := Copy(sPort, i+9, Length(sPort));
  FPort := sPort;

  {Get Name}
  sName := String(pName);

  {If GetCurrent is not being called after a PrintDialog...}
  if not PreserveDevMode then
  begin
    {SetPrinter causes the selected Printer to be updated
     as the current printer, in case the selection was by
     code and not by a PrintDialog}
    Printers.Printer.SetPrinter(pName, pDriver, pPort, 0);
    {Use GetPrinter then, to get the updated value for hMode}
    Printers.Printer.GetPrinter(pName, pDriver, pPort, hMode);
  end;

  FName := sName;
  SetMode(hMode);
  StrDispose(pName);
  StrDispose(pDriver);
  StrDispose(pPort);
  Result := True;
end;
{------------------------------------------------------------------------------}
{ SetCurrent                                                                   }
{  Sets the current VCL Printer to be the one selected in the Delphi           }
{   Application Environment.  In other words, when the PrintDialog appears     }
{   the Printer and settings specified in the VCL will be selected.            }
{------------------------------------------------------------------------------}
function TCrpePrinter.SetCurrent: Boolean;
var
  hMode    : THandle;
  xPMode   : PDevMode;
  xDevMode : TDevMode;
  pName    : PChar;
  pDriver  : PChar;
  pPort    : PChar;
begin
  Result := False;
  if IsStrEmpty(FName) then Exit;

  if IsStrEmpty(FDriver) or IsStrEmpty(FPort) or (not Assigned(FPMode)) then
  begin
    if not GetPrinterInfoFromName(FName) then Exit;
  end;

  GetMem(pName, 255);
  GetMem(pDriver, MAX_PATH);
  GetMem(pPort, MAX_PATH);
  StrPCopy(pName, FName);
  StrPCopy(pDriver, FDriver);
  StrPCopy(pPort, FPort);

  {The following code makes the Crystal VCL selected printer
   to be the Delphi selected printer.  If there is a devmode
   set in the VCL, we have to first back it up, then assign
   it to the Delphi devmode.  This is because the call to
   SetPrinter must pass a 0 for the DevMode handle to reset
   the Printer properly in the Delphi environment}
  if Assigned(FPMode) then
  begin
    {Backup the DevMode settings}
    CopyDevMode(FPMode^, xDevMode);
    Printers.Printer.SetPrinter(pName, pDriver, pPort, 0);
    Printers.Printer.GetPrinter(pName, pDriver, pPort, hMode);
    {Get the DevMode Pointer}
    xPMode := GetDMPointerFromHandle(hMode);
    {Copy the backed-up DevMode to the Delphi Printer}
    if Assigned(xPMode) then CopyDevMode(xDevMode, xPMode^);
  end
  else
  begin
    Printers.Printer.SetPrinter(pName, pDriver, pPort, 0);
    Printers.Printer.GetPrinter(pName, pDriver, pPort, hMode);
  end;

  FreeMem(pName, 255);
  FreeMem(pDriver, MAX_PATH);
  FreeMem(pPort, MAX_PATH);
  Result := True;
end;
{------------------------------------------------------------------------------}
{ Send                                                                         }
{------------------------------------------------------------------------------}
function TCrpePrinter.Send : Boolean;
var
  rptName, rptDriver, rptPort : string;
  rptPMode                    : PDevMode;
  index                       : integer;
  bCancel                     : Boolean;
  iCopies                     : integer;
  PrtList                     : TStringList;
  xOrientation                : TCrOrientation;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if not Cr.OpenPrintJob then Exit;
  if IsStrEmpty(FName) and (FOrientation = orDefault)
    and (FPreserveRptSettings = []) then
  begin
    Exit;
  end;

  {If no Printer Name has been set...}
  if IsStrEmpty(FName) then
  begin
    {If we have to set Orientation or Preserve Report Settings,
     get Printer from Report}
    xOrientation := FOrientation;
    if (FOrientation <> orDefault) or (FPreserveRptSettings <> []) then
    begin
      Retrieve;
      if not Assigned(FPMode) then
        Exit;
    end;
    {Restore Orientation...may have gotten changed from Retrieve}
    FOrientation := xOrientation;
  end;

  {If Printer Name is "HPLaserjet on LPT1:", get Device Name only}
  PrtList := TStringList.Create;
  GetPrinterNames(PrtList);
  index := Printers.Printer.Printers.IndexOf(FName);
  if index > -1 then
    FName := PrtList[index];
  PrtList.Free;

  {If the Driver, Port, or PMode are not set, get them}
  if IsStrEmpty(FDriver) or IsStrEmpty(FPort) or (not Assigned(FPMode)) then
  begin
    if not GetPrinterInfoFromName(FName) then
      Exit;
  end;

  {Check the Orientation property - only if PreserveRptSettings
   does not have Orientation}
  if not (prOrientation in FPreserveRptSettings) then
  begin
    if Assigned(FPMode) then
    begin
      case FOrientation of
        orPortrait  :
          begin
            Printers.Printer.Orientation := poPortrait;
            FPMode^.dmFields := FPMode^.dmFields or DM_ORIENTATION;
            FPMode^.dmOrientation := DMORIENT_PORTRAIT;
          end;
        orLandscape :
          begin
            Printers.Printer.Orientation := poLandscape;
            FPMode^.dmFields := FPMode^.dmFields or DM_ORIENTATION;
            FPMode^.dmOrientation := DMORIENT_LANDSCAPE;
          end;
      end;
    end;
  end;

  {Preserve Report Settings}
  if FPreserveRptSettings <> [] then
  begin
    rptPMode := nil;
    RetrieveFromReport(rptName, rptDriver, rptPort, rptPMode);
    if Assigned(rptPMode) and Assigned(FPMode) then
    begin
      if prOrientation in FPreserveRptSettings then
      begin
        FPMode^.dmFields := FPMode^.dmFields or DM_ORIENTATION;
        FPMode^.dmOrientation := rptPMode^.dmOrientation;
      end;
      if prPaperSize in FPreserveRptSettings then
      begin
        if rptPMode^.dmPaperWidth > 0 then 
        begin
          FPMode^.dmPaperWidth := rptPMode^.dmPaperWidth;
          FPMode^.dmFields := FPMode^.dmFields or DM_PAPERWIDTH;
        end;
        if rptPMode^.dmPaperLength > 0 then
        begin
          FPMode^.dmPaperLength := rptPMode^.dmPaperLength;
          FPMode^.dmFields := FPMode^.dmFields or DM_PAPERLENGTH;
        end;
        if (FPMode^.dmPaperSize <> rptPMode^.dmPaperSize) then
        begin
          FPMode^.dmPaperSize := rptPMode^.dmPaperSize;
          FPMode^.dmFields := FPMode^.dmFields or DM_PAPERSIZE;
        end;
      end;
      if prPaperSource in FPreserveRptSettings then
      begin
        FPMode^.dmFields := FPMode^.dmFields or DM_DEFAULTSOURCE;
        FPMode^.dmDefaultSource := rptPMode^.dmDefaultSource;
      end;
    end; { if }
  end;
  {This is to prevent a problem with incrementing the
  number of copies printed.  If both PrintOptions.Copies
  and Printer.PMode^.dmCopies are set to more than 1,
  the number of copies are multiplied! This problem was
  fixed in CRPE32 from CR 7.}
  if Assigned(FPMode) then
  begin
    iCopies := Cr.FPrintOptions.FCopies;
    if FPMode^.dmCopies <> iCopies then
    begin
      FPMode^.dmFields := FPMode^.dmFields or DM_COPIES;
      FPMode^.dmCopies := iCopies;
    end;
  end;

  {OnPrinterSend event}
  if Assigned(Cr.FOnPrinterSend) then
  begin
    bCancel := False;
    Cr.FOnPrinterSend(Cr, FPMode, bCancel);
    if bCancel then
      Exit;
  end;

  
  {Send Printer info to Report}
  if not Cr.FCrpeEngine.PESelectPrinter(Cr.PrintJobs(0), PChar(FDriver),
    PChar(FName), PChar(FPort), FPMode) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'Printer.Send <PESelectPrinter>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := True;
end; { Send }
{------------------------------------------------------------------------------}
{ Prompt                                                                       }
{------------------------------------------------------------------------------}
function TCrpePrinter.Prompt : Boolean;
var
  PrinterDlg : TPrintDialog;
begin
  Result := False;
  {If a Printer is defined in the VCL make sure it is the
   selected one in the Delphi environment}
  SetCurrent;
  {Create the Print Dialog}
  PrinterDlg := TPrintDialog.Create(Cr);
  try
    {Set the PrintDialog options from the PrinterOptions}
    PrinterDlg.Options := [poPageNums, poWarning];
    PrinterDlg.Copies := Cr.FPrintOptions.FCopies;
    PrinterDlg.MinPage := 1;
    PrinterDlg.MaxPage := PE_MAXPAGEN; {65535}
    PrinterDlg.FromPage := Cr.FPrintOptions.FStartPage;
    PrinterDlg.ToPage := Cr.FPrintOptions.FStopPage;
    PrinterDlg.PrintRange := prPageNums;
    {Start Page}
    if (Cr.FPrintOptions.FStartPage < 2) then
    begin
      PrinterDlg.FromPage := 1;
      if (Cr.FPrintOptions.FStopPage = 0) or
         (Cr.FPrintOptions.FStopPage = 65535) then
        PrinterDlg.PrintRange := prAllPages;
    end;
    {Stop Page}
    if (Cr.FPrintOptions.FStopPage < 1) then
      PrinterDlg.ToPage := 65535;
    {Collation}
    PrinterDlg.Collate := Cr.FPrintOptions.FCollation;

    {Show the Print Dialog}
    if PrinterDlg.Execute then
    begin
      {Set the PrinterOptions from the PrintDialog}
      Cr.FPrintOptions.SetCopies(PrinterDlg.Copies);
      Cr.FPrintOptions.SetCollation(PrinterDlg.Collate);
      if PrinterDlg.PrintRange = prAllPages then
      begin
        Cr.FPrintOptions.SetStartPage(1);
        Cr.FPrintOptions.SetStopPage(65535);
      end
      else
      begin
        Cr.FPrintOptions.SetStartPage(PrinterDlg.FromPage);
        Cr.FPrintOptions.SetStopPage(PrinterDlg.ToPage);
      end;
      {Get the Selected Printer information}
      if GetCurrent(True) then
        Result := True;
    end;
  finally
    PrinterDlg.Free;
  end;
end;
{------------------------------------------------------------------------------}
{ SetMode                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpePrinter.SetMode(const Value : THandle);
begin
  FPMode := GetDMPointerFromHandle(Value);
  FMode := Value;
end; { SetMode }
{------------------------------------------------------------------------------}
{ SetPMode                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpePrinter.SetPMode(const Value: PDevMode);
begin
  FPMode := Value;
  if not Assigned(FPMode) then
    FMode := 0
  else
    FMode := THandle(Addr(FPMode));
end; { SetPMode }


{******************************************************************************}
{ TCrpePrintOptions Class Definition                                           }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpePrintOptions.Create;
begin
  inherited Create;
  {Set defaults}
  FCopies := 1;
  FCollation := True;
  FStartPage := 0;
  FStopPage := 0;
  FOutputFileName := '';
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpePrintOptions.Clear;
begin
  SetCopies(1);
  SetCollation(True);
  SetStartPage(0);
  SetStopPage(0);
  SetOutputFileName('');
end;
{------------------------------------------------------------------------------}
{ Prompt                                                                       }
{------------------------------------------------------------------------------}
function TCrpePrintOptions.Prompt : Boolean;
var
  pPrintOpt : ^PEPrintOptions;
begin
  Result := False;
  pPrintOpt := nil;
  if (Cr = nil) then Exit;
  
  if not Cr.FCrpeEngine.PESetPrintOptions(Cr.PrintJobs(0), PEPrintOptions(pPrintOpt^)) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errCancelDialog,errEngine,'',
        'PrintOptions.Prompt <PESetPrintOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := True;
  {Store the new options in the VCL}
  GetCollation;
  GetCopies;
  GetStartPage;
  GetStopPage;
end;
{------------------------------------------------------------------------------}
{ GetCollation                                                                 }
{------------------------------------------------------------------------------}
function TCrpePrintOptions.GetCollation : Boolean;
var
  PrintOpt : PEPrintOptions;
begin
  Result := FCollation;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  if not Cr.FCrpeEngine.PEGetPrintOptions(Cr.PrintJobs(0), PrintOpt) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'PrintOptions.GetCollation <PEGetPrintOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  case PrintOpt.Collation of
    PE_UNCOLLATED : FCollation := False;
    PE_COLLATED   : FCollation := True;
    else
      FCollation := True;
  end;
  Result := FCollation;
end;
{------------------------------------------------------------------------------}
{ SetCollation                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpePrintOptions.SetCollation (const Value: Boolean);
var
  PrintOpt   : PEPrintOptions;
  iCollation : integer;
begin
  FCollation := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  
  {Get PrintOptions from Report}
  if not Cr.FCrpeEngine.PEGetPrintOptions(Cr.PrintJobs(0), PrintOpt) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'PrintOptions.SetCollation <PEGetPrintOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Collation}
  iCollation := Ord(FCollation);
  if PrintOpt.Collation <> iCollation then
  begin
    PrintOpt.Collation := iCollation;
    {Send PrintOptions}
    if not Cr.FCrpeEngine.PESetPrintOptions(Cr.PrintJobs(0), PrintOpt) then
    begin
      case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
          'PrintOptions.SetCollation <PESetPrintOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetCopies                                                                    }
{------------------------------------------------------------------------------}
function TCrpePrintOptions.GetCopies : Word;
var
  PrintOpt : PEPrintOptions;
begin
  Result := FCopies;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  if not Cr.FCrpeEngine.PEGetPrintOptions(Cr.PrintJobs(0), PrintOpt) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'PrintOptions.GetCopies <PEGetPrintOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FCopies := PrintOpt.nReportCopies;
  Result := FCopies;
end;
{------------------------------------------------------------------------------}
{ SetCopies                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpePrintOptions.SetCopies (const Value: Word);
var
  PrintOpt : PEPrintOptions;
begin
  FCopies := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  
  {Get PrintOptions from Report}
  if not Cr.FCrpeEngine.PEGetPrintOptions(Cr.PrintJobs(0), PrintOpt) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'PrintOptions.SetCopies <PEGetPrintOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Copies}
  if PrintOpt.nReportCopies <> FCopies then
  begin
    PrintOpt.nReportCopies := FCopies;
    {Send PrintOptions}
    if not Cr.FCrpeEngine.PESetPrintOptions(Cr.PrintJobs(0), PrintOpt) then
    begin
      case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
          'PrintOptions.SetCopies <PESetPrintOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetStartPage                                                                 }
{------------------------------------------------------------------------------}
function TCrpePrintOptions.GetStartPage : Word;
var
  PrintOpt : PEPrintOptions;
begin
  Result := FStartPage;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  if not Cr.FCrpeEngine.PEGetPrintOptions(Cr.PrintJobs(0), PrintOpt) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'PrintOptions.GetStartPage <PEGetPrintOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FStartPage := PrintOpt.StartPageN;
  Result := FStartPage;
end;
{------------------------------------------------------------------------------}
{ SetStartPage                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpePrintOptions.SetStartPage (const Value: Word);
var
  PrintOpt : PEPrintOptions;
  nStart   : Word;
begin
  FStartPage := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  
  {Get PrintOptions from Report}
  if not Cr.FCrpeEngine.PEGetPrintOptions(Cr.PrintJobs(0), PrintOpt) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'PrintOptions.SetStartPage <PEGetPrintOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {StartPage}
  nStart := FStartPage;
  if nStart = 0 then
    nStart := 1;
  if PrintOpt.StartPageN <> nStart then
  begin
    PrintOpt.StartPageN := nStart;
    {Send PrintOptions}
    if not Cr.FCrpeEngine.PESetPrintOptions(Cr.PrintJobs(0), PrintOpt) then
    begin
      case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
          'PrintOptions.SetStartPage <PESetPrintOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetStopPage                                                                  }
{------------------------------------------------------------------------------}
function TCrpePrintOptions.GetStopPage : Word;
var
  PrintOpt : PEPrintOptions;
begin
  Result := FStopPage;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  if not Cr.FCrpeEngine.PEGetPrintOptions(Cr.PrintJobs(0), PrintOpt) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'PrintOptions.GetStopPage <PEGetPrintOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FStopPage := PrintOpt.StopPageN;
  Result := FStopPage;
end;
{------------------------------------------------------------------------------}
{ SetStopPage                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpePrintOptions.SetStopPage (const Value: Word);
var
  PrintOpt : PEPrintOptions;
  nStop    : Word;
begin
  FStopPage := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  
  {Get PrintOptions from Report}
  if not Cr.FCrpeEngine.PEGetPrintOptions(Cr.PrintJobs(0), PrintOpt) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'PrintOptions.SetStopPage <PEGetPrintOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {StopPage}
  nStop := FStopPage;
  if nStop = 0 then
    nStop := 65535; {MaxWord}
  if PrintOpt.StopPageN <> nStop then
  begin
    PrintOpt.StopPageN := nStop;
    {Send PrintOptions}
    if not Cr.FCrpeEngine.PESetPrintOptions(Cr.PrintJobs(0), PrintOpt) then
    begin
      case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
          'PrintOptions.SetStopPage <PESetPrintOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetOutputFileName                                                            }
{------------------------------------------------------------------------------}
function TCrpePrintOptions.GetOutputFileName : string;
var
  PrintOpt : PEPrintOptions;
begin
  Result := FOutputFileName;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  if not Cr.FCrpeEngine.PEGetPrintOptions(Cr.PrintJobs(0), PrintOpt) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'PrintOptions.GetOutputFileName <PEGetPrintOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FOutputFileName := String(PrintOpt.outputFileName);
  Result := FOutputFileName;
end;
{------------------------------------------------------------------------------}
{ SetOutputFileName                                                            }
{------------------------------------------------------------------------------}
procedure TCrpePrintOptions.SetOutputFileName(const Value: string);
var
  PrintOpt : PEPrintOptions;
  sTmp     : string;
begin
  FOutputFileName := Value;
  {Check Length}
  if Length(FOutputFileName) > PE_FILE_PATH_LEN then
    FOutputFileName := Copy(FOutputFileName, 1, PE_FILE_PATH_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  
  {Get PrintOptions from Report}
  if not Cr.FCrpeEngine.PEGetPrintOptions(Cr.PrintJobs(0), PrintOpt) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'PrintOptions.SetOutputFileName <PEGetPrintOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sTmp := String(PrintOpt.outputFileName);
  if CompareText(FOutputFileName, sTmp) <> 0 then
  begin
    StrCopy(PrintOpt.outputFileName, PChar(FOutputFileName));
    {Send PrintOptions}
    if not Cr.FCrpeEngine.PESetPrintOptions(Cr.PrintJobs(0), PrintOpt) then
    begin
      case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
          'PrintOptions.SetOutputFileName <PESetPrintOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ TCrpeConnect Class Definition                                                }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeConnect.Create;
begin
  inherited Create;
  {Set defaults}
  FServerName   := '';
  FUserID       := '';
  FPassword     := '';
  FDatabaseName := '';
  FPropagate    := False;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeConnect.Clear;
begin
  if IsStrEmpty(Cr.FReportName) or  (not FileExists(Cr.FReportName)) then
  begin
    FServerName   := '';
    FUserID       := '';
    FPassword     := '';
    FDatabaseName := '';
    FPropagate    := False;
  end
  else
  begin
    SetServerName(' ');
    SetUserID(' ');
    SetPassword(' ');
    SetDatabaseName(' ');
    SetPropagate(False);
  end;
end;
{------------------------------------------------------------------------------}
{ Test                                                                         }
{------------------------------------------------------------------------------}
function TCrpeConnect.Test: Boolean;
var
  LogInfo         : PELogOnInfo;
  nTables, nIndex : Smallint;
  nRpt            : integer;
  nSub            : integer;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if not Cr.OpenPrintJob then Exit;

  {If Propagate is set we need to go through all the reports}
  if FPropagate = True then
  begin
    {Store current Rpt Index}
    nSub := Cr.FSubreports.FIndex;
    {Loop through the reports}
    for nRpt := 0 to (Cr.FSubreports.Count - 1) do
    begin
      {Set up the report pointer}
      Cr.FSubreports.SetIndex(nRpt);
      {Grab the Connect data from the Main report}
      if nRpt = 0 then
      begin
        StrCopy(LogInfo.ServerName, PChar(FServerName));
        StrCopy(LogInfo.UserID, PChar(FUserID));
        StrCopy(LogInfo.Password, PChar(FPassword));
        StrCopy(LogInfo.DatabaseName, PChar(FDatabaseName));
      end;

      {Get the number of tables}
      
      nTables := Cr.FCrpeEngine.PEGetNTables(Cr.FPrintJob);
      if nTables = -1 then
      begin
        Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Connect.Test <PEGetNTables>');
        Exit;
      end;

      {Loop through the tables}
      for nIndex := 0 to (nTables - 1) do
      begin
        
        {Set LogOnInfo}
        if not Cr.FCrpeEngine.PESetNthTableLogOnInfo(Cr.FPrintJob, nIndex, LogInfo, False) then
        begin
          Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Connect.Test <PESetNthTableLogOnInfo>');
          Exit;
        end;
        
        {Test Connect}
        Result := Cr.FCrpeEngine.PETestNthTableConnectivity(Cr.FPrintJob, nIndex);
        {If if failed, store the resulting error}
        if Result = False then
        begin
          Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Connect.Test <PETestNthTableConnectivity>');
          {Reset the report pointer}
          Cr.FSubreports.SetIndex(nSub);
          Exit;
        end;
      end;
    end;
    {Reset the report pointer}
    Cr.FSubreports.SetIndex(nSub);
  end
  {Propagate is False}
  else
  begin
    {Set the Connect logon info}
    StrCopy(LogInfo.ServerName, PChar(FServerName));
    StrCopy(LogInfo.UserID, PChar(FUserID));
    StrCopy(LogInfo.Password, PChar(FPassword));
    StrCopy(LogInfo.DatabaseName, PChar(FDatabaseName));

    {Get the number of tables}
    
    nTables := Cr.FCrpeEngine.PEGetNTables(Cr.FPrintJob);
    if nTables = -1 then
    begin
      Result := False;
      Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Connect.Test <PEGetNTables>');
      Exit;
    end;

    {Loop through the tables}
    for nIndex := 0 to (nTables - 1) do
    begin
      
      {Set LogOnInfo and propagate through other tables}
      if not Cr.FCrpeEngine.PESetNthTableLogOnInfo(Cr.FPrintJob, nIndex, LogInfo, True) then
      begin
        Result := False;
        Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Connect.Test <PESetNthTableLogOnInfo>');
        Exit;
      end;
      
      {Test Connect}
      Result := Cr.FCrpeEngine.PETestNthTableConnectivity(Cr.FPrintJob, nIndex);
      {If if failed, store the resulting error}
      if Result = False then
      begin
        Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Connect.Test <PETestNthTableConnectivity>');
        Exit;
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetServerName                                                                }
{------------------------------------------------------------------------------}
function TCrpeConnect.GetServerName : string;
var
  LogInfo         : PELogOnInfo;
  TableType       : PETableType;
  nTables, nIndex : Smallint;
begin
  Result := FServerName;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  nTables := Cr.FTables.Count;
  {Loop through tables}
  for nIndex := 0 to (nTables - 1) do
  begin
    
    {Try to find an SQL table}
    if not Cr.FCrpeEngine.PEGetNthTableType(Cr.FPrintJob, nIndex, TableType) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Connect.GetServerName <PEGetNthTableType>') of
        errIgnore : Continue;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    if (TableType.DBType = PE_DT_SQL) or
       (TableType.DBType = PE_DT_SQL_STORED_PROCEDURE) then
    begin
      
      if not Cr.FCrpeEngine.PEGetNthTableLogOnInfo(Cr.FPrintJob, nIndex, LogInfo) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Connect.GetServerName <PEGetNthTableLogOnInfo>') of
          errIgnore : Continue;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      FServerName := String(LogInfo.ServerName);
      Result := FServerName;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetServerName                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeConnect.SetServerName (const Value: string);
var
  LogInfo : PELogOnInfo;
  nReport : integer;
  sDSN    : string;
  i       : integer;
begin
  FServerName := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  {If there are no Tables, do not send Connect}
  if Cr.FTables.Count = 0 then Exit;

  sDSN := FServerName;
  {if Connect.Propagate = True, propagate to all Subreports also}
  if FPropagate = True then
  begin
    nReport := Cr.FSubreports.FIndex;
    for i := 0 to (Cr.FSubreports.Count - 1) do
    begin
      Cr.Subreports.SetIndex(i);
      {Initialize the LogInfo structure}
      
      if not Cr.FCrpeEngine.PEGetNthTableLogOnInfo(Cr.FPrintJob, 0, LogInfo) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Connect.SetServerName <PEGetNthTableLogOnInfo>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      StrCopy(LogInfo.ServerName, PChar(sDSN));
      {Send the Connect to the Report}
      
      if not Cr.FCrpeEngine.PESetNthTableLogOnInfo(Cr.FPrintJob, 0, LogInfo, True) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Connect.SetServerName <PESetNthTableLogOnInfo>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
     end;
    Cr.FSubreports.SetIndex(nReport);
  end
  else
  begin
    {Initialize the LogInfo structure}
    
    if not Cr.FCrpeEngine.PEGetNthTableLogOnInfo(Cr.FPrintJob, 0, LogInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Connect.SetServerName <PEGetNthTableLogOnInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    if StrComp(LogInfo.ServerName, PChar(FServerName)) <> 0 then
    begin
      StrCopy(LogInfo.ServerName, PChar(FServerName));
      {Send the Connect to the Report}
      
      if not Cr.FCrpeEngine.PESetNthTableLogOnInfo(Cr.FPrintJob, 0, LogInfo, True) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Connect.SetServerName <PESetNthTableLogOnInfo>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
     end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetUserID                                                                    }
{------------------------------------------------------------------------------}
function TCrpeConnect.GetUserID : string;
var
  LogInfo         : PELogOnInfo;
  TableType       : PETableType;
  nTables, nIndex : Smallint;
begin
  Result := FUserID;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  nTables := Cr.FTables.Count;
  {Loop through tables}
  for nIndex := 0 to (nTables - 1) do
  begin
    
    {Try to find an SQL table}
    if not Cr.FCrpeEngine.PEGetNthTableType(Cr.FPrintJob, nIndex, TableType) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Connect.GetUserID <PEGetNthTableType>') of
        errIgnore : Continue;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    if (TableType.DBType = PE_DT_SQL) or
       (TableType.DBType = PE_DT_SQL_STORED_PROCEDURE) then
    begin
      
      if not Cr.FCrpeEngine.PEGetNthTableLogOnInfo(Cr.FPrintJob, nIndex, LogInfo) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Connect.GetUserID <PEGetNthTableLogOnInfo>') of
          errIgnore : Continue;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      FUserID := String(LogInfo.UserID);
      Result := FUserID;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetUserID                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeConnect.SetUserID (const Value: string);
var
  LogInfo : PELogOnInfo;
  nReport : integer;
  sUID    : string;
  i       : integer;
begin
  FUserID := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  {If there are no Tables, do not send Connect}
  if Cr.FTables.Count = 0 then Exit;

  sUID := FUserID;
  {if Connect.Propagate = True, propagate to all Subreports also}
  if FPropagate = True then
  begin
    nReport := Cr.FSubreports.FIndex;
    for i := 0 to (Cr.FSubreports.Count - 1) do
    begin
      Cr.Subreports.SetIndex(i);
      {Initialize the LogInfo structure}
      
      if not Cr.FCrpeEngine.PEGetNthTableLogOnInfo(Cr.FPrintJob, 0, LogInfo) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Connect.SetUserID <PEGetNthTableLogOnInfo>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      StrCopy(LogInfo.UserID, PChar(sUID));
      {Send the Connect to the Report}
      
      if not Cr.FCrpeEngine.PESetNthTableLogOnInfo(Cr.FPrintJob, 0, LogInfo, True) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Connect.SetUserID <PESetNthTableLogOnInfo>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
    end;
    Cr.FSubreports.SetIndex(nReport);
  end
  else
  begin
    {Initialize the LogInfo structure}
    
    if not Cr.FCrpeEngine.PEGetNthTableLogOnInfo(Cr.FPrintJob, 0, LogInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Connect.SetUserID <PEGetNthTableLogOnInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    if StrComp(LogInfo.UserID, PChar(FUserID)) <> 0 then
    begin
      StrCopy(LogInfo.UserID, PChar(FUserID));
      {Send the Connect to the Report}
      
      if not Cr.FCrpeEngine.PESetNthTableLogOnInfo(Cr.FPrintJob, 0, LogInfo, True) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Connect.SetUserID <PESetNthTableLogOnInfo>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetPassword                                                                  }
{------------------------------------------------------------------------------}
function TCrpeConnect.GetPassword : string;
var
  LogInfo         : PELogOnInfo;
  TableType       : PETableType;
  nTables, nIndex : Smallint;
begin
  Result := FPassword;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  nTables := Cr.FTables.Count;
  {Loop through tables}
  for nIndex := 0 to (nTables - 1) do
  begin
    
    {Try to find an SQL table}
    if not Cr.FCrpeEngine.PEGetNthTableType(Cr.FPrintJob, nIndex, TableType) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Connect.GetPassword <PEGetNthTableType>') of
        errIgnore : Continue;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    if (TableType.DBType = PE_DT_SQL) or
       (TableType.DBType = PE_DT_SQL_STORED_PROCEDURE) then
    begin
      
      if not Cr.FCrpeEngine.PEGetNthTableLogOnInfo(Cr.FPrintJob, nIndex, LogInfo) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Connect.GetPassword <PEGetNthTableLogOnInfo>') of
          errIgnore : Continue;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      FPassword := String(LogInfo.Password);
      Result := FPassword;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetPassword                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeConnect.SetPassword (const Value: string);
var
  LogInfo : PELogOnInfo;
  nReport : integer;
  sPWD    : string;
  i       : integer;
begin
  FPassword := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  {If there are no Tables, do not send Connect}
  if Cr.FTables.Count = 0 then Exit;

  sPWD := FPassword;
  {if Connect.Propagate = True, propagate to all Subreports also}
  if FPropagate = True then
  begin
    nReport := Cr.FSubreports.FIndex;
    for i := 0 to (Cr.FSubreports.Count - 1) do
    begin
      Cr.Subreports.SetIndex(i);
      {Initialize the LogInfo structure}
      
      if not Cr.FCrpeEngine.PEGetNthTableLogOnInfo(Cr.FPrintJob, 0, LogInfo) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Connect.SetPassword <PEGetNthTableLogOnInfo>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      StrCopy(LogInfo.Password, PChar(sPWD));
      {Send the Connect to the Report}
      
      if not Cr.FCrpeEngine.PESetNthTableLogOnInfo(Cr.FPrintJob, 0, LogInfo, True) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Connect.SetPassword <PESetNthTableLogOnInfo>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
    end;
    Cr.FSubreports.SetIndex(nReport);
  end
  else
  begin
    {Initialize the LogInfo structure}
    
    if not Cr.FCrpeEngine.PEGetNthTableLogOnInfo(Cr.FPrintJob, 0, LogInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Connect.SetPassword <PEGetNthTableLogOnInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    if StrComp(LogInfo.Password, PChar(FPassword)) <> 0 then
    begin
      StrCopy(LogInfo.Password, PChar(FPassword));
      {Send the Connect to the Report}
      
      if not Cr.FCrpeEngine.PESetNthTableLogOnInfo(Cr.FPrintJob, 0, LogInfo, True) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Connect.SetPassword <PESetNthTableLogOnInfo>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetDatabaseName                                                              }
{------------------------------------------------------------------------------}
function TCrpeConnect.GetDatabaseName : string;
var
  LogInfo         : PELogOnInfo;
  TableType       : PETableType;
  nTables, nIndex : Smallint;
begin
  Result := FDatabaseName;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  
  nTables := Cr.FTables.Count;
  {Loop through tables}
  for nIndex := 0 to (nTables - 1) do
  begin
    {Try to find an SQL table}
    
    if not Cr.FCrpeEngine.PEGetNthTableType(Cr.FPrintJob, nIndex, TableType) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Connect.GetDatabaseName <PEGetNthTableType>') of
        errIgnore : Continue;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    if (TableType.DBType = PE_DT_SQL) or
       (TableType.DBType = PE_DT_SQL_STORED_PROCEDURE) then
    begin
      
      if not Cr.FCrpeEngine.PEGetNthTableLogOnInfo(Cr.FPrintJob, nIndex, LogInfo) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Connect.GetDatabaseName <PEGetNthTableLogOnInfo>') of
          errIgnore : Continue;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      FDatabaseName := String(LogInfo.DatabaseName);
      Result := FDatabaseName;
      Break;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDatabaseName                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeConnect.SetDatabaseName (const Value: string);
var
  LogInfo : PELogOnInfo;
  nReport : integer;
  sDSQ    : string;
  i       : integer;
begin
  FDatabaseName := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  {If there are no Tables, do not send Connect}
  if Cr.FTables.Count = 0 then Exit;

  sDSQ := FDatabaseName;
  {if Connect.Propagate = True, propagate to all Subreports also}
  if FPropagate = True then
  begin
    nReport := Cr.FSubreports.FIndex;
    for i := 0 to (Cr.FSubreports.Count - 1) do
    begin
      Cr.Subreports.SetIndex(i);
      {Initialize the LogInfo structure}
      
      if not Cr.FCrpeEngine.PEGetNthTableLogOnInfo(Cr.FPrintJob, 0, LogInfo) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Connect.SetDatabaseName <PEGetNthTableLogOnInfo>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      StrCopy(LogInfo.DatabaseName, PChar(sDSQ));
      {Send the Connect to the Report}
      
      if not Cr.FCrpeEngine.PESetNthTableLogOnInfo(Cr.FPrintJob, 0, LogInfo, True) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Connect.SetDatabaseName <PESetNthTableLogOnInfo>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
    end;
    Cr.FSubreports.SetIndex(nReport);
  end
  else
  begin
    {Initialize the LogInfo structure}
    
    if not Cr.FCrpeEngine.PEGetNthTableLogOnInfo(Cr.FPrintJob, 0, LogInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Connect.SetDatabaseName <PEGetNthTableLogOnInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    if StrComp(LogInfo.DatabaseName, PChar(FDatabaseName)) <> 0 then
    begin
      StrCopy(LogInfo.DatabaseName, PChar(FDatabaseName));
      {Send the Connect to the Report}
      
      if not Cr.FCrpeEngine.PESetNthTableLogOnInfo(Cr.FPrintJob, 0, LogInfo, True) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Connect.SetDatabaseName <PESetNthTableLogOnInfo>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetPropagate                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeConnect.SetPropagate (const Value: Boolean);
var
  sDSN : string;
  sPWD : string;
  sUID : string;
  sDSQ : string;
begin
  FPropagate := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  if FPropagate = True then
  begin
    sDSN := FServerName;
    sUID := FUserID;
    sPWD := FPassword;
    sDSQ := FDatabaseName;
    SetServerName(sDSN);
    SetUserID(sUID);
    SetPassword(sPWD);
    SetDatabaseName(sDSQ);
  end;
end;


{******************************************************************************}
{ TCrpeLogOnServerItem Class Definition                                        }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeLogOnServerItem.Create;
begin
  inherited Create;
  FServerName   := '';
  FUserID       := '';
  FPassword     := '';
  FDatabaseName := '';
  FDllName      := '';
  FLogNumber    := 0;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnServerItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeLogOnServerItem then
  begin
    ServerName   := TCrpeLogOnServerItem(Source).ServerName;
    UserID       := TCrpeLogOnServerItem(Source).UserID;
    Password     := TCrpeLogOnServerItem(Source).Password;
    DatabaseName := TCrpeLogOnServerItem(Source).DatabaseName;
    DllName      := TCrpeLogOnServerItem(Source).DllName;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnServerItem.Clear;
begin
  if IsLoggedOn then LogOff;
  SetServerName('');
  SetUserID('');
  SetPassword('');
  SetDatabaseName('');
  SetDllName('');
end;
{------------------------------------------------------------------------------}
{ LogOn                                                                        }
{------------------------------------------------------------------------------}
function TCrpeLogOnServerItem.LogOn : Boolean;
var
  LogInfo  : PELogOnInfo;
  pDllName : array[0..255] of Char;
  i        : integer;
  nIndex   : Smallint;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if not Cr.OpenPrintEngine then Exit;

  StrCopy(LogInfo.ServerName, PChar(FServerName));
  StrCopy(LogInfo.DatabaseName, PChar(FDatabaseName));
  StrCopy(LogInfo.UserID, PChar(FUserId));
  StrCopy(LogInfo.Password, PChar(FPassword));
  {Must use lowercase for Crystal 8 or PELogOnServer will fail}
  StrCopy(pDllName, PChar(LowerCase(FDllName)));

  
  if not Cr.FCrpeEngine.PELogOnServer(pDllName, LogInfo) then
  begin
    Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'LogOn <PELogOnServer>');
    Exit;
  end;

  {Set the LogOn Number}
  i := 1;
  while (Result = False) do
  begin
    {Check to see if the LogOn number exists already}
    nIndex := TCrpeLogOnServer(Parent).IndexOfLogNumber(i);
    {If the number wasn't found, use it}
    if nIndex = -1 then
    begin
      TCrpeLogOnServerItem(TCrpeLogOnServer(Parent).FList[FIndex]).FLogNumber := i;
      FLogNumber := i;
      Result := True;
      Exit;
    end
    else
      Inc(i);
  end;
end;
{------------------------------------------------------------------------------}
{ LogOff                                                                       }
{------------------------------------------------------------------------------}
function TCrpeLogOnServerItem.LogOff : Boolean;
var
  LogInfo  : PELogOnInfo;
  pDllName : array[0..255] of Char;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if not Cr.OpenPrintEngine then Exit;
  {If already Logged Off, Exit}
  if FLogNumber = 0 then Exit;

  StrCopy(LogInfo.ServerName, PChar(FServerName));
  StrCopy(LogInfo.DatabaseName, PChar(FDatabaseName));
  StrCopy(LogInfo.UserID, PChar(FUserID));
  StrCopy(LogInfo.Password, PChar(FPassword));
  StrCopy(pDllName, PChar(FDLLName));

  
  if Cr.FCrpeEngine.PELogOffServer(pDllName, LogInfo) then
  begin
    TCrpeLogOnServerItem(TCrpeLogOnServer(Parent).FList[FIndex]).FLogNumber := 0;
    FLogNumber := 0;
  end;
  Result := True;
end;
{------------------------------------------------------------------------------}
{ IsLoggedOn                                                                   }
{------------------------------------------------------------------------------}
function TCrpeLogOnServerItem.IsLoggedOn : Boolean;
begin
  Result := (FLogNumber > 0);
end;
{------------------------------------------------------------------------------}
{ SetServerName                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnServerItem.SetServerName (const Value: string);
begin
  FServerName := Value;
  if Parent.FIndex < 0 then Exit;
  TCrpeLogOnServerItem(TCrpeLogOnServer(Parent).FList[FIndex]).FServerName := Value;
end;
{------------------------------------------------------------------------------}
{ SetUserID                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnServerItem.SetUserID (const Value: string);
begin
  FUserID := Value;
  if Parent.FIndex < 0 then Exit;
  TCrpeLogOnServerItem(TCrpeLogOnServer(Parent).FList[FIndex]).FUserID := Value;
end;
{------------------------------------------------------------------------------}
{ SetPassword                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnServerItem.SetPassword (const Value: string);
begin
  FPassword := Value;
  if Parent.FIndex < 0 then Exit;
  TCrpeLogOnServerItem(TCrpeLogOnServer(Parent).FList[FIndex]).FPassword := Value;
end;
{------------------------------------------------------------------------------}
{ SetDatabaseName                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnServerItem.SetDatabaseName (const Value: string);
begin
  FDatabaseName := Value;
  if Parent.FIndex < 0 then Exit;
  TCrpeLogOnServerItem(TCrpeLogOnServer(Parent).FList[FIndex]).FDatabaseName := Value;
end;
{------------------------------------------------------------------------------}
{ SetDLLName                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnServerItem.SetDLLName (const Value: string);
begin
  FDLLName := Value;
  if Parent.FIndex < 0 then Exit;
  TCrpeLogOnServerItem(TCrpeLogOnServer(Parent).FList[FIndex]).FDLLName := Value;
end;


{******************************************************************************}
{ TCrpeLogOnServer Class Definition                                            }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeLogOnServer.Create;
begin
  inherited Create;
  FList        := TList.Create;
  FItem        := TCrpeLogOnServerItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeLogOnServer.Destroy;
begin
  Clear;
  FList.Free;
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnServer.Clear;
var
  i : integer;
begin
  for i := (FList.Count - 1) downto 0 do
  begin
    SetIndex(i);
    if FItem.IsLoggedOn then FItem.LogOff;
    TCrpeLogOnServerItem(FList[i]).Free;
    FList.Delete(i);
  end;
  FList.Clear;
  FIndex := -1;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.Count : integer;
begin
  Result := FList.Count;
end;
{------------------------------------------------------------------------------}
{ IndexOf                                                                      }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.IndexOf(ServerName: string): integer;
var
  i,j : integer;
begin
  Result := -1;
  {Store current index}
  j := FIndex;
  for i := 0 to Count - 1 do
  begin
    SetIndex(i);
    if CompareText(FItem.FServerName, ServerName) = 0 then
    begin
      Result := i;
      Break;
    end;
  end;
  {Re-set index}
  SetIndex(j);
end;
{------------------------------------------------------------------------------}
{ IndexOfLogNumber                                                             }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.IndexOfLogNumber (LogN : integer) : integer;
var
  iCurrent : integer;
  i        : integer;
begin
  Result := -1;
  {Store current index}
  iCurrent := FIndex;
  {Locate Log Number}
  for i := 0 to (Count-1) do
  begin
    SetIndex(i);
    if FItem.FLogNumber = LogN then
    begin
      Result := i;
      Break;
    end;
  end;
  {Re-set index}
  SetIndex(iCurrent);
end;
{------------------------------------------------------------------------------}
{ Retrieve                                                                     }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.Retrieve : Boolean;
var
  LogInfo         : PELogOnInfo;
  TableType       : PETableType;
  nTables, nIndex : Smallint;
  nRptIndex       : integer;
  nRpt            : integer;
  slTmp           : TStringList;
  sTmp            : string;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if not Cr.OpenPrintJob then Exit;
  {Clear the current LogOnServer items}
  Clear;
  {Allocate memory for Temporary list}
  slTmp := TStringList.Create;

  {Store the current Rpt Index}
  nRptIndex := Cr.FSubreports.FIndex;

  {Loop through Reports}
  for nRpt := 0 to (Cr.FSubreports.Count - 1) do
  begin
    {Set Report number}
    Cr.FSubreports.SetIndex(nRpt);
    
    {Loop through the tables}
    nTables := Cr.FCrpeEngine.PEGetNTables(Cr.FPrintJob);
    for nIndex := 0 to (nTables - 1) do
    begin
      
      if not Cr.FCrpeEngine.PEGetNthTableType(Cr.FPrintJob, nIndex, TableType) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'LogOnServer.Retrieve <PEGetNthTableType>') of
          errIgnore : Continue;
          errAbort  : begin
                       slTmp.Free;
                       Abort;
                     end;
          errRaise  : begin
                       slTmp.Free;
                       raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                     end;
        end;
      end;
      {Try to find an SQL table}
      if (TableType.DBType = PE_DT_SQL) or
         (TableType.DBType = PE_DT_SQL_STORED_PROCEDURE) then
      begin
        
        if not Cr.FCrpeEngine.PEGetNthTableLogOnInfo(Cr.FPrintJob, nIndex, LogInfo) then
        begin
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'LogOnServer.Retrieve <PEGetNthTableLogOnInfo>') of
            errIgnore : Continue;
            errAbort  : begin
                          slTmp.Free;
                          Abort;
                        end;
            errRaise  : begin
                         slTmp.Free;
                         raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                       end;
          end;
        end;
        {Only take unique LogOn info}
        sTmp := String(TableType.DLLName) +
                String(LogInfo.ServerName) +
                String(LogInfo.UserID) +
                String(LogInfo.DatabaseName);
        if slTmp.IndexOf(sTmp) = -1 then
        begin
          slTmp.Add(sTmp);
          Add(String(LogInfo.ServerName));
          TCrpeLogOnServerItem(FList[FIndex]).FUserID := String(LogInfo.UserID);
          TCrpeLogOnServerItem(FList[FIndex]).FPassword := String(LogInfo.Password);
          TCrpeLogOnServerItem(FList[FIndex]).FDatabaseName := String(LogInfo.DatabaseName);
          TCrpeLogOnServerItem(FList[FIndex]).FDLLName := String(TableType.DLLName);
          FItem.FLogNumber := 0;
          Result := True;
        end;
      end;
    end;
  end;
  slTmp.Free;
  {Set Index}
  if Count > 0 then
    FIndex := 0;
  {Restore Rpt index}
  Cr.FSubreports.SetIndex(nRptIndex);
end; {Retrieve}
{------------------------------------------------------------------------------}
{ Add                                                                          }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.Add (ServerName: string) : integer;
var
  FItem : TCrpeLogOnServerItem;
  i     : integer;
begin
  Result := -1;
  if (Cr = nil) then Exit;
  if IsStrEmpty(ServerName) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SERVERNAME,
        'LogOnServer.Add') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FItem := TCrpeLogOnServerItem.Create;
  i := FList.Add(FItem);
  TCrpeLogOnServerItem(FList[i]).FServerName := ServerName;
  SetIndex(i);
  Result := i;
end;
{------------------------------------------------------------------------------}
{ Delete                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnServer.Delete(nIndex: integer);
begin
  if (Cr = nil) then Exit;
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'LogOnServer.Delete(' + IntToStr(nIndex) + ')') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  if TCrpeLogOnServerItem(FList[nIndex]).IsLoggedOn then
    TCrpeLogOnServerItem(FList[nIndex]).LogOff;
  TCrpeLogOnServerItem(FList[nIndex]).Free;
  FList.Delete(nIndex);
  {Decrement index if necessary}
  if FIndex = Count then
    SetIndex(FList.Count-1);
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnServer.SetIndex (nIndex: integer);
begin
  if (csLoading in Cr.ComponentState) then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Clear;
    Exit;
  end;
  if (Cr = nil) then Exit;
  if not Cr.OpenEngine then Exit;

  if (FList.Count > 0) and (nIndex < FList.Count) then
  begin
    PropagateIndex(nIndex);
    FItem.FServerName := TCrpeLogOnServerItem(FList[nIndex]).FServerName;
    FItem.FUserID := TCrpeLogOnServerItem(FList[nIndex]).FUserID;
    FItem.FDatabaseName := TCrpeLogOnServerItem(FList[nIndex]).FDatabaseName;
    FItem.FPassword := TCrpeLogOnServerItem(FList[nIndex]).FPassword;
    FItem.FDLLName := TCrpeLogOnServerItem(FList[nIndex]).FDLLName;
    FItem.FLogNumber := TCrpeLogOnServerItem(FList[nIndex]).FLogNumber;
    Exit;
  end
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
      'LogOnServer[' + IntToStr(nIndex) + ']') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetItems                                                                     }
{   - This is the default property and can be also set                         }
{      via Crpe1.LogOnServer[nIndex]                                           }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.GetItems(nIndex: integer) : TCrpeLogOnServerItem;
begin
  SetIndex(nIndex);
  Result := TCrpeLogOnServerItem(FItem);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeLogOnServer.GetItem : TCrpeLogOnServerItem;
begin
  Result := TCrpeLogOnServerItem(FItem);
end;


{******************************************************************************}
{ Class TCrpeLogOnInfoItem                                                     }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeLogOnInfoItem.Create;
begin
  inherited Create;
  FServerName   := '';
  FUserID       := '';
  FPassword     := '';
  FDatabaseName := '';
  FDLLName      := '';
  FServerType   := '';
  FTableType    := ttUnknown;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnInfoItem.Clear;
begin
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Parent.PropagateIndex(-1);
  if FIndex = -1 then
  begin
    FDLLName    := '';
    FServerType := '';
    FTableType  := ttUnknown;
  end;
  SetServerName('');
  SetUserID('');
  SetPassword('');
  SetDatabaseName('');
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnInfoItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeLogOnInfoItem then
  begin
    ServerName    := TCrpeLogOnInfoItem(Source).ServerName;
    UserID        := TCrpeLogOnInfoItem(Source).UserID;
    Password      := TCrpeLogOnInfoItem(Source).Password;
    DatabaseName  := TCrpeLogOnInfoItem(Source).DatabaseName;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Test                                                                         }
{------------------------------------------------------------------------------}
function TCrpeLogOnInfoItem.Test : Boolean;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if not Cr.OpenPrintJob then Exit;

  {Test LogOn}
  
  Result := Cr.FCrpeEngine.PETestNthTableConnectivity(Cr.FPrintJob, FIndex);
  {If if failed, store the resulting error}
  if Result = False then
  begin
    Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'Test <PETestNthTableConnectivity>');
  end;
end;
{------------------------------------------------------------------------------}
{ SetServerName                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnInfoItem.SetServerName(const Value: string);
var
  LogInfo : PELogOnInfo;
begin
  {Check Length}
  if Length(Value) > PE_SERVERNAME_LEN then
    FServerName := Copy(Value, 1, PE_SERVERNAME_LEN)
  else
    FServerName := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  if not Cr.OpenPrintJob then Exit;

  {Get the LogOnInfo from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthTableLogOnInfo(Cr.FPrintJob, FIndex, LogInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetServerName <PEGetNthTableLogOnInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {ServerName}
  if CompareStr(LogInfo.ServerName, PChar(FServerName)) <> 0 then
  begin
    StrCopy(LogInfo.ServerName, PChar(FServerName));
    {Send the LogOnInfo to the Report}
    
    if not Cr.FCrpeEngine.PESetNthTableLogOnInfo(Cr.FPrintJob, FIndex,
      LogInfo, False) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetServerName <PESetNthTableLogOnInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end; { if }
end;
{------------------------------------------------------------------------------}
{ SetUserID                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnInfoItem.SetUserID(const Value: string);
var
  LogInfo : PELogOnInfo;
begin
  FUserID := Value;
  {Check Length}
  if Length(FUserID) > PE_USERID_LEN then
    FUserID := Copy(FUserID, 1, PE_USERID_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  if not Cr.OpenPrintJob then
    Exit;

  {Get the LogOnInfo from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthTableLogOnInfo(Cr.FPrintJob, FIndex, LogInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetUserID <PEGetNthTableLogOnInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {UserID}
  if StrComp(LogInfo.UserID, PChar(FUserID)) <> 0 then
  begin
    StrCopy(LogInfo.UserID, PChar(FUserID));
    {Send the LogOnInfo to the Report}
    
    if not Cr.FCrpeEngine.PESetNthTableLogOnInfo(Cr.FPrintJob, FIndex,
      LogInfo, False) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetUserID <PESetNthTableLogOnInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetPassword                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnInfoItem.SetPassword(const Value: string);
var
  LogInfo : PELogOnInfo;
begin
  {Check Length}
  if Length(Value) > PE_PASSWORD_LEN then
    FPassword := Copy(Value, 1, PE_PASSWORD_LEN)
  else
    FPassword := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  if not Cr.OpenPrintJob then Exit;

  {Get the LogOnInfo from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthTableLogOnInfo(Cr.FPrintJob, FIndex, LogInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetPassword <PEGetNthTableLogOnInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Password}
  if StrComp(LogInfo.Password, PChar(FPassword)) <> 0 then
  begin
    StrCopy(LogInfo.Password, PChar(FPassword));
    {Send the LogOnInfo to the Report}
    
    if not Cr.FCrpeEngine.PESetNthTableLogOnInfo(Cr.FPrintJob, FIndex,
      LogInfo, False) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetPassword <PESetNthTableLogOnInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end; { if }
end;
{------------------------------------------------------------------------------}
{ SetServerType                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnInfoItem.SetServerType (const Value: string);
var
  ServerInfo : PEServerTypeInfo;
  PrevType   : string;
begin
  PrevType := FServerType;
  FServerType := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  if CompareText(PrevType, FServerType) <> 0 then
  begin
    case FTableType of
      ttUnknown         : ServerInfo.DBType := PE_DT_STANDARD;
      ttStandard        : ServerInfo.DBType := PE_DT_STANDARD;
      ttSQL             : ServerInfo.DBType := PE_DT_SQL;
      ttStoredProcedure : ServerInfo.DBType := PE_DT_SQL_STORED_PROCEDURE;
    end;
    
    if not Cr.FCrpeEngine.PESetNthTableServerType(Cr.FPrintJob, FIndex, ServerInfo, False) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetServerType <PESetNthTableServerType>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDatabaseName                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnInfoItem.SetDatabaseName(const Value: string);
var
  LogInfo : PELogOnInfo;
begin
  {Check Length}
  if Length(Value) > PE_DATABASENAME_LEN then
    FDatabaseName := Copy(Value, 1, PE_DATABASENAME_LEN)
  else
    FDatabaseName := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  if not Cr.OpenPrintJob then Exit;

  {Get the LogOnInfo from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthTableLogOnInfo(Cr.FPrintJob, FIndex, LogInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetDatabaseName <PEGetNthTableLogOnInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {DatabaseName}
  if CompareStr(LogInfo.DatabaseName, PChar(FDatabaseName)) <> 0 then
  begin
    StrCopy(LogInfo.DatabaseName, PChar(FDatabaseName));
    {Send the LogOnInfo to the Report}
    
    if not Cr.FCrpeEngine.PESetNthTableLogOnInfo(Cr.FPrintJob, FIndex,
      LogInfo, False) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetDatabaseName <PESetNthTableLogOnInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end; { if }
end;
{------------------------------------------------------------------------------}
{ SetTable                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnInfoItem.SetTable(const nIndex: integer);
begin
  {read-only}
end;


{******************************************************************************}
{ Class TCrpeLogOnInfo                                                         }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeLogOnInfo.Create;
begin
  inherited Create;
  FSQLTablesOnly := True;
  FItem := TCrpeLogOnInfoItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeLogOnInfo.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnInfo.Clear;
var
  i,j : integer;
begin
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then PropagateIndex(-1);
  if FIndex = -1 then
  begin
    FItem.Clear;
  end
  else
  begin
    j := FIndex;
    for i := 0 to Count-1 do
      Items[i].Clear;
    if j > -1 then
      SetIndex(j)
    else
      FIndex := -1;
  end;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeLogOnInfo.Count : integer;
var
  TableType : PETableType;
  nTables,
  nTable    : Smallint;
  nCount    : integer;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  nCount := 0;

  {Get Number of Tables}
  
  nTables := Cr.FCrpeEngine.PEGetNTables(Cr.FPrintJob);
  if nTables = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'LogOnInfo.Count <PEGetNTables>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Loop through the tables}
  for nTable := 0 to (nTables - 1) do
  begin
    
    if not Cr.FCrpeEngine.PEGetNthTableType(Cr.FPrintJob, nTable, TableType) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'LogOnInfo.Count <PEGetNthTableType>') of
        errIgnore : Continue;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    {If SQLTablesOnly then check for SQL table}
    if FSQLTablesOnly and not ((TableType.DBType = PE_DT_SQL) or
       (TableType.DBType = PE_DT_SQL_STORED_PROCEDURE)) then
      Continue
    else
      nCount := nCount + 1;
  end;
  Result := nCount;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeLogOnInfo.SetIndex (nIndex: integer);
var
  LogInfo   : PELogOnInfo;
  TableType : PETableType;
  nTables,
  nTable    : Smallint;
  nCount    : integer;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or  (not FileExists(Cr.FReportName)) then Exit;
  if (csLoading in Cr.ComponentState) then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Clear;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;

  nCount := -1;
  
  {Loop through the tables}
  nTables := Cr.FCrpeEngine.PEGetNTables(Cr.FPrintJob);
  if nTables = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'LogOnInfo.SetIndex <PEGetNTables>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  for nTable := 0 to (nTables - 1) do
  begin
    
    if not Cr.FCrpeEngine.PEGetNthTableType(Cr.FPrintJob, nTable, TableType) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'LogOnInfo.SetIndex <PEGetNthTableType>') of
        errIgnore : Continue;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    {If SQLTablesOnly then check for SQL table}
    if FSQLTablesOnly and not ((TableType.DBType = PE_DT_SQL) or
       (TableType.DBType = PE_DT_SQL_STORED_PROCEDURE)) then
      Continue
    else
    begin
      nCount := nCount + 1;
      if nCount = nIndex then
      begin
        {Get the LogOnInfo}
        
        if not Cr.FCrpeEngine.PEGetNthTableLogOnInfo(Cr.FPrintJob, nTable, LogInfo) then
        begin
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'LogOnInfo.SetIndex <PEGetNthTableLogOnInfo>') of
            errIgnore : Continue;
            errAbort  : Abort;
            errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
        PropagateIndex(nIndex);
        FItem.FServerName := String(LogInfo.ServerName);
        FItem.FUserID := String(LogInfo.UserID);
        FItem.FPassword := String(LogInfo.Password);
        FItem.FDatabaseName := String(LogInfo.DatabaseName);
        {TableType}
        FItem.FDLLName := String(TableType.DLLName);
        FItem.FServerType := String(TableType.DescriptiveName);
        case TableType.DBType of
          PE_DT_STANDARD             : FItem.FTableType := ttStandard;
          PE_DT_SQL                  : FItem.FTableType := ttSQL;
          PE_DT_SQL_STORED_PROCEDURE : FItem.FTableType := ttStoredProcedure;
          else
            FItem.FTableType := ttUnknown;
        end;
        Exit;
      end;
    end;
  end;
  if nCount = -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
      'LogOnInfo[' + IntToStr(nIndex) + ']') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.LogOnInfo[nIndex]                                             }
{------------------------------------------------------------------------------}
function TCrpeLogOnInfo.GetItem(nIndex: integer): TCrpeLogOnInfoItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeTablesItem                                                        }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeTablesItem.Create;
begin
  inherited Create;
  FName            := '';
  FAliasName       := '';
  FPath            := '';
  FSubName         := '';
  FConnectBuffer   := '';
  FPassword        := '';
  {TableType}
  FTableType       := ttUnknown;
  FDLLName         := '';
  FServerType      := '';
  {PrivateInfo}
  FDataPointer     := nil;
  FFields          := TCrpeTableFields.Create;
  FSubClassList.Add(FFields);
  FFieldNames      := TStringList.Create;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeTablesItem.Destroy;
begin
  FFields.Free;
  FFieldNames.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeTablesItem.Clear;
begin
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Parent.PropagateIndex(-1);
  if FIndex = -1 then
  begin
    FName          := '';
    FAliasName     := '';
    FPath          := '';
    FSubName       := '';
    FConnectBuffer := '';
    FPassword      := '';
    {TableType}
    FTableType     := ttUnknown;
    FDLLName       := '';
    FServerType    := '';
    {PrivateInfo}
    FDataPointer   := nil;
    FFieldNames.Clear;
    FFields.Clear;
  end;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeTablesItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeTables then
  begin
    Name          := TCrpeTables(Source).Item.Name;
    AliasName     := TCrpeTables(Source).Item.AliasName;
    Path          := TCrpeTables(Source).Item.Path;
    SubName       := TCrpeTables(Source).Item.SubName;
    ConnectBuffer := TCrpeTables(Source).Item.ConnectBuffer;
    Password      := TCrpeTables(Source).Item.Password;
    {PrivateInfo}
    DataPointer   := TCrpeTables(Source).Item.DataPointer;
    Fields.Assign(TCrpeTables(Source).Item.Fields);
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ FieldByName                                                                  }
{------------------------------------------------------------------------------}
function TCrpeTablesItem.FieldByName(sFieldName: string): TCrpeTableFieldsItem;
begin
  Result := FFields.FieldByName(sFieldName);
end;
{------------------------------------------------------------------------------}
{ FieldNames                                                                   }
{------------------------------------------------------------------------------}
function TCrpeTablesItem.FieldNames : TStrings;
var
  i,j   : integer;
  s1,s2 : string;
begin
  FFieldNames.Clear;
  Result := FFieldNames;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  j := FFields.FIndex;
  s1 := '{' + FAliasName + '.';
  for i := 0 to FFields.Count - 1 do
  begin
    s2 := FFields[i].FFieldName + '}';
    FFieldNames.Add(s1 + s2);
  end;
  if (j = -1) and (FFields.Count > 0) then j := 0;
  FFields.SetIndex(j);
  Result := FFieldNames;
end;
{------------------------------------------------------------------------------}
{ Test                                                                         }
{------------------------------------------------------------------------------}
function TCrpeTablesItem.Test : Boolean;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  {Test Connectivity}
  
  Result := Cr.FCrpeEngine.PETestNthTableConnectivity(Cr.FPrintJob, FIndex);
  {If if failed, store the resulting error}
  if Result = False then
    Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'Test <PETestNthTableConnectivity>');
end;
{------------------------------------------------------------------------------}
{ Check                                                                        }
{------------------------------------------------------------------------------}
function TCrpeTablesItem.CheckDifferences(var DifNums: TStringList;
  var DifStrings: TStringList): Boolean;
const
  PEDiff : array[0..23] of integer = (PE_TCD_OKAY, PE_TCD_DATABASENOTFOUND,
    PE_TCD_SERVERNOTFOUND, PE_TCD_SERVERNOTOPENED, PE_TCD_ALIASCHANGED,
    PE_TCD_INDEXESCHANGED, PE_TCD_DRIVERCHANGED, PE_TCD_DICTIONARYCHANGED,
    PE_TCD_FILETYPECHANGED, PE_TCD_RECORDSIZECHANGED, PE_TCD_ACCESSCHANGED,
    PE_TCD_PARAMETERSCHANGED, PE_TCD_LOCATIONCHANGED, PE_TCD_DATABASEOTHER,
    PE_TCD_NUMFIELDSCHANGED, PE_TCD_FIELDOTHER, PE_TCD_FIELDNAMECHANGED,
    PE_TCD_FIELDDESCCHANGED, PE_TCD_FIELDTYPECHANGED, PE_TCD_FIELDSIZECHANGED,
    PE_TCD_NATIVEFIELDTYPECHANGED, PE_TCD_NATIVEFIELDOFFSETCHANGED,
    PE_TCD_NATIVEFIELDSIZECHANGED, PE_TCD_FIELDDECPLACESCHANGED);
  TCDiff : array[0..23] of string = ('1000:Okay', '1001:Database Not Found',
    '1002:Server Not Found', '1003:Server Not Opened', '1004:Alias Changed',
    '1005:Indexes Changed', '1006:Driver Changed', '1007:Dictionary Changed',
    '1008:File Type Changed', '1009:Record Size Changed', '1010:Access Changed',
    '1011:Parameters Changed', '1012:Location Changed', '1013:Database Other',
    '1014:Number of Fields Changed', '1015:Field Other', '1016:Field Name Changed',
    '1017:Field Description Changed', '1018:Field Type Changed', '1019:Field Size Changed',
    '1020:Native Field Type Changed', '1021:Native Field Offset Changed',
    '1022:Native Field Size Changed', '1023:Field Decimal Places Changed');
var
  TableDifInfo : PETableDifferenceInfo;
  i            : integer;
  nDif         : integer;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Check Differences}
  
  if not Cr.FCrpeEngine.PECheckNthTableDifferences(Cr.FPrintJob, FIndex, TableDifInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Tables.CheckDifferences <PECheckNthTableDifferences>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Extract the Differences from the returned Number}
  nDif := TableDifInfo.tableDifferences;
  for i := High(PEDiff) downto Low(PEDiff) do
  begin
    if nDif - PEDiff[i] > 0 then
    begin
      nDif := nDif - PEDiff[i];
      DifNums.Add(IntToStr(GetErrorNum(TCDiff[i])));
      DifStrings.Add(GetErrorStr(TCDiff[i]));
    end
    else if nDif - PEDiff[i] = 0 then
    begin
      DifNums.Add(IntToStr(GetErrorNum(TCDiff[i])));
      DifStrings.Add(GetErrorStr(TCDiff[i]));
      Break;
    end
    else
      Continue;
  end;
  Result := True;
end;
{------------------------------------------------------------------------------}
{ SetName                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeTablesItem.SetName(const Value: string);
var
  TableLoc      : PETableLocation;
  sPath         : string;
  sLocation     : string;
  sLocationOld  : string;
  nTables       : Smallint;
  Changed       : Boolean;
begin
  FName := Value;
  {Check Length}
  if Length(FName) > PE_TABLE_LOCATION_LEN then
    FName := Copy(FName, 1, PE_TABLE_LOCATION_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  Changed := False;

  {If Propagate is True, take the Table Path
   from the first table in the main report}
  if (TCrpeTables(Parent).FPropagate = True) then
  begin
    if (Cr.FSubreports.FIndex > 0) or (FIndex <> 0) then
    begin
      {Get number of Tables in Main Report}
      
      nTables := Cr.FCrpeEngine.PEGetNTables(Cr.PrintJobs(0));
      if nTables = -1 then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Tables[' + IntToStr(FIndex) + '].SetName <PEGetNTables>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      if nTables > 0 then
      begin
        {Get first Table path from Main Report}
        
        if not Cr.FCrpeEngine.PEGetNthTableLocation(Cr.PrintJobs(0), 0, TableLoc) then
        begin
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'Tables[' + IntToStr(FIndex) + '].SetName <PEGetNthTableLocation>') of
            errIgnore : Exit;
            errAbort  : Abort;
            errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
        sPath := ExtractFilePath(String(TableLoc.Location));
        if CompareText(sPath, FPath) <> 0 then
        begin
          FPath := sPath;
          Changed := True;
        end;
      end;
    end;
  end;

  {Get the Table Location from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthTableLocation(Cr.FPrintJob, FIndex, TableLoc) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Tables[' + IntToStr(FIndex) + '].SetName <PEGetNthTableLocation>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sLocationOld := String(TableLoc.Location);

  {Join the Name & Path}
  sLocation := AddBackSlash(Trim(FPath)) + Trim(FName);
  {Check Length}
  if Length(sLocation) > PE_TABLE_LOCATION_LEN then
    sLocation := Copy(sLocation, 1, PE_TABLE_LOCATION_LEN);
  {Compare the new Table Location/Name}
  if CompareText(sLocation, sLocationOld) <> 0 then
  begin
    StrCopy(TableLoc.Location, PChar(sLocation));
    Changed := True;
  end;

  {Set New Location}
  if Changed then
  begin
    
    if not Cr.FCrpeEngine.PESetNthTableLocation(Cr.FPrintJob, FIndex, TableLoc) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Tables[' + IntToStr(FIndex) + '].SetName <PESetNthTableLocation>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetAliasName                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeTablesItem.SetAliasName (const Value: string);
var
  hText : Hwnd;
  iText : Smallint;
  pText : PChar;
  sText : string;
begin
  FAliasName := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the Alias Name from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthTableAliasName(Cr.FPrintJob, FIndex, hText, iText) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Tables[' + IntToStr(FIndex) + '].SetAliasName <PEGetNthTableAliasName>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Alias Name string}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Tables[' + IntToStr(FIndex) + '].SetAliasName <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sText := String(pText);
  StrDispose(pText);

  {Compare the Alias Name}
  if CompareText(sText, FAliasName) <> 0 then
  begin
    {Set New Alias Name}
    
    if not Cr.FCrpeEngine.PESetNthTableAliasName(Cr.FPrintJob, FIndex, PChar(FAliasName)) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Tables[' + IntToStr(FIndex) + '].SetAliasName <PESetNthTableAliasName>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetPath                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeTablesItem.SetPath (const Value: string);
var
  TableLoc      : PETableLocation;
  sPath         : string;
  sLocation     : string;
  sLocationOld  : string;
  nTables       : Smallint;
  i, j          : integer;
  Changed       : Boolean;
begin
  FPath := Value;
  {Check Length}
  if Length(FPath) > PE_TABLE_LOCATION_LEN then
    FPath := Copy(FPath, 1, PE_TABLE_LOCATION_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  Changed := False;

  {Convert Paths with BDE Aliases to directories}
  if Length(FPath) > 0 then
  begin
    if FPath[1] = ':' then
    begin
      if not GetPathFromAlias(FPath, FPath) then
      begin
        case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALIAS_NAME,
            'Tables[' + IntToStr(FIndex) + '].SetPath <GetPathFromAlias>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
    end;
  end;
  {Add trailing backslash if needed}
  FPath := AddBackSlash(FPath);

  {If Propagate is True, take the Table Path
   from the first table in the main report}
  if (TCrpeTables(Parent).FPropagate = True) then
  begin
    if (Cr.FSubreports.FIndex > 0) or (FIndex <> 0) then
    begin
      {Get number of Tables in Main Report}
      
      nTables := Cr.FCrpeEngine.PEGetNTables(Cr.PrintJobs(0));
      if nTables = -1 then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Tables[' + IntToStr(FIndex) + '].SetPath <PEGetNTables>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      if nTables > 0 then
      begin
        {Get first Table path from Main Report}
        
        if not Cr.FCrpeEngine.PEGetNthTableLocation(Cr.PrintJobs(0), 0, TableLoc) then
        begin
          case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
              'Tables[' + IntToStr(FIndex) + '].SetPath <PEGetNthTableLocation>') of
            errIgnore : Exit;
            errAbort  : Abort;
            errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
        sPath := ExtractFilePath(String(TableLoc.Location));
        if CompareText(sPath, FPath) <> 0 then
        begin
          FPath := sPath;
          Changed := True;
        end;
      end;
    end;
  end;

  {Get the Table Location from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthTableLocation(Cr.FPrintJob, FIndex, TableLoc) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Tables[' + IntToStr(FIndex) + '].SetPath <PEGetNthTableLocation>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sLocationOld := String(TableLoc.Location);

  {Join the Name & Path}
  sLocation := AddBackSlash(Trim(FPath)) + Trim(FName);
  {Check Length}
  if Length(sLocation) > PE_TABLE_LOCATION_LEN then
    sLocation := Copy(sLocation, 1, PE_TABLE_LOCATION_LEN);
  {Compare the new Table Location/Name}
  if CompareText(sLocation, sLocationOld) <> 0 then
  begin
    StrCopy(TableLoc.Location, PChar(sLocation));
    Changed := True;
  end;

  {Set New Location}
  if Changed then
  begin
    
    if not Cr.FCrpeEngine.PESetNthTableLocation(Cr.FPrintJob, FIndex, TableLoc) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Tables[' + IntToStr(FIndex) + '].SetPath <PESetNthTableLocation>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;

  sPath := FPath;
  {If the first table is being set with Propage on, send it to all others}
  if (TCrpeTables(Parent).FPropagate = True) and
     (Cr.FSubreports.FIndex = 0) and (FIndex = 0) then
  begin
    for i := 0 to Cr.FSubreports.Count - 1 do
    begin
      Cr.FSubreports.SetIndex(i);
      for j := 0 to TCrpeTables(Parent).Count - 1 do
      begin
        TCrpeTables(Parent).SetIndex(j);
        if (Cr.FSubreports.FIndex = 0) and (FIndex = 0) then
          Continue;
        SetPath(sPath);
      end;
    end;
    Cr.FSubreports.SetIndex(0);
    TCrpeTables(Parent).SetIndex(0);
  end;
end;
{------------------------------------------------------------------------------}
{ SetSubName                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeTablesItem.SetSubName (const Value: string);
var
  TableLoc  : PETableLocation;
  sLocation : string;
begin
  FSubName := Value;
  {Check Length}
  if Length(FSubName) > PE_TABLE_LOCATION_LEN then
    FSubName := Copy(FSubName, 1, PE_TABLE_LOCATION_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the Table Location from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthTableLocation(Cr.FPrintJob, FIndex, TableLoc) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Tables[' + IntToStr(FIndex) + '].SetSubName <PEGetNthTableLocation>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare the SubName}
  sLocation := String(TableLoc.SubLocation);
  if CompareText(sLocation, FSubName) <> 0 then
  begin
    StrCopy(TableLoc.SubLocation, PChar(FSubName));
    {Set New Location}
    
    if not Cr.FCrpeEngine.PESetNthTableLocation(Cr.FPrintJob, FIndex, TableLoc) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Tables[' + IntToStr(FIndex) + '].SetSubName <PESetNthTableLocation>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetConnectBuffer                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeTablesItem.SetConnectBuffer (const Value: string);
var
  TableLoc  : PETableLocation;
  sLocation : string;
begin
  FConnectBuffer := Value;
  {Check Length}
  if Length(FConnectBuffer) > PE_CONNECTION_BUFFER_LEN then
    FConnectBuffer := Copy(FConnectBuffer, 1, PE_CONNECTION_BUFFER_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the Table Location from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthTableLocation(Cr.FPrintJob, FIndex, TableLoc) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Tables[' + IntToStr(FIndex) + '].SetConnectBuffer <PEGetNthTableLocation>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Compare the ConnectBuffer}
  sLocation := String(TableLoc.ConnectBuffer);
  if CompareText(sLocation, FConnectBuffer) <> 0 then
  begin
    StrCopy(TableLoc.ConnectBuffer, PChar(FConnectBuffer));
    {Set New Location}
    
    if not Cr.FCrpeEngine.PESetNthTableLocation(Cr.FPrintJob, FIndex, TableLoc) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Tables[' + IntToStr(FIndex) + '].SetConnectBuffer <PESetNthTableLocation>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetPassword                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeTablesItem.SetPassword (const Value: string);
var
  LogInfo   : PELogOnInfo;
  sPassword : string;
begin
  FPassword := Value;
  {Check Length}
  if Length(FPassword) > PE_PASSWORD_LEN then
    FPassword := Copy(FPassword, 1, PE_PASSWORD_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {If Password property was set, call LogOnInfo}
  if not Cr.FCrpeEngine.PEGetNthTableLogOnInfo(Cr.FPrintJob, FIndex, LogInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Tables[' + IntToStr(FIndex) + '].SetPassword <PEGetNthTableLogOnInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sPassword := String(LogInfo.Password);
  if CompareText(sPassword, FPassword) <> 0 then
  begin
    StrCopy(LogInfo.Password, PChar(FPassword));
    
    if not Cr.FCrpeEngine.PESetNthTableLogOnInfo(Cr.FPrintJob, FIndex, LogInfo, False) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Tables[' + IntToStr(FIndex) + '].SetPassword <PESetNthTableLogOnInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetServerType                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeTablesItem.SetServerType (const Value: string);
var
  ServerInfo : PEServerTypeInfo;
  PrevType   : string;
begin
  PrevType := FServerType;
  FServerType := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  if CompareText(PrevType, FServerType) <> 0 then
  begin
    case FTableType of
      ttUnknown         : ServerInfo.DBType := PE_DT_STANDARD;
      ttStandard        : ServerInfo.DBType := PE_DT_STANDARD;
      ttSQL             : ServerInfo.DBType := PE_DT_SQL;
      ttStoredProcedure : ServerInfo.DBType := PE_DT_SQL_STORED_PROCEDURE;
    end;
    
    if not Cr.FCrpeEngine.PESetNthTableServerType(Cr.FPrintJob, FIndex, ServerInfo, False) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetServerType <PESetNthTableServerType>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDataPointer                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeTablesItem.SetDataPointer (const Value: Pointer);
var
  PrivateInfo : PETablePrivateInfo;
begin
  FDataPointer := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  if Assigned(FDataPointer) then
  begin
    PrivateInfo.dataPtr := FDataPointer;
    PrivateInfo.tag := 3;
    PrivateInfo.nBytes := 4;
    {Set PrivateInfo}
    
    if not Cr.FCrpeEngine.PESetNthTablePrivateInfo(Cr.FPrintJob, FIndex, PrivateInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Tables[' + IntToStr(FIndex) + '].SetDataPointer <PESetNthTablePrivateInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ Class TCrpeTables                                                            }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeTables.Create;
begin
  inherited Create;
  FPropagate    := False;
  FFieldMapping := fmAuto;
  FVerifyFix    := False;
  FItem         := TCrpeTablesItem.Create;
  FSubClassList.Add(FItem);
  FFieldNames   := TStringList.Create;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeTables.Destroy;
begin
  FItem.Free;
  FFieldNames.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeTables.Clear;
var
  i,j : integer;
begin
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then PropagateIndex(-1);
  if FIndex = -1 then
  begin
    FItem.Clear;
  end
  else
  begin
    j := FIndex;
    for i := 0 to Count-1 do
      Items[i].Clear;
    if j > -1 then
      SetIndex(j)
    else
      FIndex := -1;
  end;
  FFieldNames.Clear;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeTables.Count : integer;
var
  nTables : Smallint;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get number of Tables}
  
  nTables := Cr.FCrpeEngine.PEGetNTables(Cr.FPrintJob);
  if nTables = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Tables.Count <PEGetNTables>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := nTables;
end;
{------------------------------------------------------------------------------}
{ IndexOf                                                                      }
{------------------------------------------------------------------------------}
function TCrpeTables.IndexOf (TableName: string): integer;
var
  iCurrent : integer;
  cnt      : integer;
begin
  Result := -1;
  {Store current index}
  iCurrent := FIndex;
  {Locate Table name}
  for cnt := 0 to (Count-1) do
  begin
    SetIndex(cnt);
    if CompareText(FItem.FAliasName, TableName) = 0 then
    begin
      Result := cnt;
      Break;
    end;
  end;
  {Re-set index}
  SetIndex(iCurrent);
end;
{------------------------------------------------------------------------------}
{ ByName                                                                       }
{------------------------------------------------------------------------------}
function TCrpeTables.ByName (AliasName: string): TCrpeTablesItem;
var
  i : integer;
begin
  Result := FItem;
  i := IndexOf(AliasName);
  if i = -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_TABLE_BY_NAME,
        'Tables.ByName') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := GetItem(i);
end;
{------------------------------------------------------------------------------}
{ GetFieldInfo                                                                 }
{------------------------------------------------------------------------------}
function TCrpeTables.GetFieldInfo (var FieldInfo: TCrFieldInfo): boolean;
var
  iTable : integer;
  iField : integer;
begin
  Result := False;
  if IsStrEmpty(FieldInfo.TableName) or IsStrEmpty(FieldInfo.FieldName) then
    Exit;

  {Get Table index}
  iTable := FIndex;
  FieldInfo.TableIndex := IndexOf(FieldInfo.TableName);
  if FieldInfo.TableIndex = -1 then Exit;
  SetIndex(FieldInfo.TableIndex);

  {Get Field index}
  iField := FItem.FFields.FIndex;
  FieldInfo.FieldIndex := FItem.FFields.IndexOf(FieldInfo.FieldName);
  if FieldInfo.FieldIndex = -1 then Exit;
  FItem.FFields.SetIndex(FieldInfo.FieldIndex);

  {Get FieldType and Length}
  FieldInfo.FieldType := FItem.FFields.FItem.FFieldType;
  FieldInfo.FieldLength := FItem.FFields.FItem.FFieldLength;

  {Re-set indexes}
  SetIndex(iTable);
  FItem.FFields.SetIndex(iField);
  Result := True;
end;
{------------------------------------------------------------------------------}
{ FieldNames                                                                   }
{------------------------------------------------------------------------------}
function TCrpeTables.FieldNames : TStrings;
var
  i,j : integer;
begin
  FFieldNames.Clear;
  Result := FFieldNames;
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.ReportName) then Exit;
  if not Cr.OpenPrintJob then Exit;

  j := FIndex;
  for i := 0 to Count-1 do
  begin
    SetIndex(i);
    FFieldNames.AddStrings(FItem.FieldNames);
  end;
  if (j = -1) and (Count > 0) then j := 0;
  SetIndex(j);
  Result := FFieldNames;
end;
{------------------------------------------------------------------------------}
{ Verify                                                                       }
{------------------------------------------------------------------------------}
function TCrpeTables.Verify : Boolean;
type
  PPEDatabaseLinkInfo = ^PEDatabaseLinkInfo;
var
  cnt, i, siz : integer;
  l           : TList;
  LinkInfo    : PPEDatabaseLinkInfo;
  EventInfo   : PEEnableEventInfo;

  {Local procedure WindowCallback}
  function WindowCallback(eventID: Smallint;
    pEvent: Pointer; Cr: TCrpe): LongBool stdcall;
  var
    Cancel           : Boolean;
    FieldMappingInfo : PEFieldMappingEventInfo;
    ReportFields     : TList;
    DatabaseFields   : TList;
    RptFields        : TCrFieldMappingInfo;
    DBFields         : TCrFieldMappingInfo;
    cnt1             : integer;
  begin
    Result := True;
    Cancel := False;
    case eventID of
      PE_MAPPING_FIELD_EVENT:
        begin
          if Assigned(Cr.FOnFieldMapping) then
          begin
            FieldMappingInfo := PEFieldMappingEventInfo(pEvent^);
            if (FieldMappingInfo.structSize = SizeOf(PEFieldMappingEventInfo)) then
            begin
              {If Range Checking is on, turn it off}
              {$IFOPT R+}
                {$DEFINE CKRANGE}
                {$R-}
              {$ENDIF}
              {Get Report Fields}
              ReportFields := TList.Create;
              for cnt1 := 0 to FieldMappingInfo.nReportFields - 1 do
              begin
                ReportFields.Add(nil);
                ReportFields[cnt1] := TCrFieldMappingInfo.Create;
                RptFields := TCrFieldMappingInfo(ReportFields[cnt1]);
                RptFields.TableName := String(FieldMappingInfo.ReportFields^[cnt1].tableAliasName);
                RptFields.FieldName := String(FieldMappingInfo.ReportFields^[cnt1].databaseFieldName);
                if FieldMappingInfo.ReportFields^[cnt1].valueType = PE_FVT_UNKNOWNFIELD then
                   RptFields.FieldType := fvUnknown
                else
                   RptFields.FieldType := TCrFieldValueType(FieldMappingInfo.ReportFields^[cnt1].valueType);
                RptFields.MapTo := FieldMappingInfo.ReportFields^[cnt1].mappingTo;
              end;
              {Get Database Fields}
              DatabaseFields := TList.Create;
              for cnt1 := 0 to FieldMappingInfo.nDatabaseFields - 1 do
              begin
                DatabaseFields.Add(nil);
                DatabaseFields[cnt1] := TCrFieldMappingInfo.Create;
                DBFields := TCrFieldMappingInfo(DatabaseFields[cnt1]);
                DBFields.TableName := String(FieldMappingInfo.DatabaseFields^[cnt1].tableAliasName);
                DBFields.FieldName := String(FieldMappingInfo.DatabaseFields^[cnt1].databaseFieldName);
                if FieldMappingInfo.DatabaseFields^[cnt1].valueType = PE_FVT_UNKNOWNFIELD then
                   DBFields.FieldType := fvUnknown
                else
                   DBFields.FieldType := TCrFieldValueType(FieldMappingInfo.DatabaseFields^[cnt1].valueType);
                DBFields.MapTo := FieldMappingInfo.DatabaseFields^[cnt1].mappingTo;
              end;
              Cr.FOnFieldMapping(ReportFields, DatabaseFields, Cancel);
              Result := not Cancel;
              {Write back the information}
              if not Cancel then
              begin
                for cnt1 := 0 to FieldMappingInfo.nReportFields - 1 do
                begin
                  if cnt1 < ReportFields.Count then
                  begin
                    RptFields := TCrFieldMappingInfo(ReportFields[cnt1]);
                    StrCopy(FieldMappingInfo.ReportFields^[cnt1].tableAliasName, PChar(RptFields.TableName));
                    StrCopy(FieldMappingInfo.ReportFields^[cnt1].databaseFieldName, PChar(RptFields.FieldName));
                    if RptFields.FieldType = fvUnknown then
                      FieldMappingInfo.ReportFields^[cnt1].valueType := PE_FVT_UNKNOWNFIELD
                    else
                      FieldMappingInfo.ReportFields^[cnt1].valueType := Ord(RptFields.FieldType);
                    FieldMappingInfo.ReportFields^[cnt1].mappingTo := RptFields.MapTo;
                  end;
                end;
                for cnt1 := 0 to FieldMappingInfo.nDatabaseFields - 1 do
                begin
                  if cnt1 < DatabaseFields.Count then
                  begin
                    DBFields := TCrFieldMappingInfo(DatabaseFields[cnt1]);
                    StrCopy(FieldMappingInfo.DatabaseFields^[cnt1].tableAliasName, PChar(DBFields.TableName));
                    StrCopy(FieldMappingInfo.DatabaseFields^[cnt1].databaseFieldName, PChar(DBFields.FieldName));
                    if DBFields.FieldType = fvUnknown then
                      FieldMappingInfo.DatabaseFields^[cnt1].valueType := PE_FVT_UNKNOWNFIELD
                    else
                      FieldMappingInfo.DatabaseFields^[cnt1].valueType := Ord(DBFields.FieldType);
                    FieldMappingInfo.DatabaseFields^[cnt1].mappingTo := DBFields.MapTo;
                  end;
                end;
                {$IFDEF CKRANGE}
                  {$UNDEF CKRANGE}
                  {$R+}
                {$ENDIF}
              end;
              {Free the TLists}
              for cnt1 := (ReportFields.Count - 1) downto 0 do
              begin
                TCrFieldMappingInfo(ReportFields[cnt1]).Free;
                ReportFields.Delete(cnt1);
              end;
              ReportFields.Free;
              for cnt1 := (DatabaseFields.Count - 1) downto 0 do
              begin
                TCrFieldMappingInfo(DatabaseFields[cnt1]).Free;
                DatabaseFields.Delete(cnt1);
              end;
              DatabaseFields.Free;
            end;
          end;
        end;
    end;
  end;


{Main Verify function}
begin
  Result := False;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Mapping by Event}
  if FFieldMapping = fmEvent then
  begin
    if Assigned(Cr.FOnFieldMapping) then
    begin
      EventInfo.fieldMappingEvent := 1;
      {Enable Event}
      
      if not Cr.FCrpeEngine.PEEnableEvent(Cr.FPrintJob, EventInfo) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Tables.Verify <PEEnableEvent>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      {Set Event Callback function}
      
      if not Cr.FCrpeEngine.PESetEventCallback(Cr.FPrintJob, Addr(WindowCallback), Cr) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'Tables.Verify <PESetEventCallback>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
    end;
  end;

  {This code is used to save and restore Database Link Information.}
  {Crystal's Paradox DLL messes this up, so we have to work around it.}
  if FVerifyFix = True then
  begin
    {Turn off Verify On Every Print, or it will}
    {cause the problem we are trying to prevent.}
    Cr.FReportOptions.FVerifyOnEveryPrint := False;
    cnt := Cr.FCrpeEngine.PEGetNDatabaseLinks(Cr.FPrintJob);
    siz := SizeOf(PEDatabaseLinkInfo);
    l := TList.Create;
    try
      {Save Link Information}
      for i := 0 to pred(cnt) do
      begin
        getMem(LinkInfo, siz);
        
        if not Cr.FCrpeEngine.PEGetNthDatabaseLinkInfo(Cr.FPrintJob, i, LinkInfo^) then
          Continue;
        l.Add(LinkInfo);
      end;
      {Verify Database}
      
      if not Cr.FCrpeEngine.PEVerifyDatabase(Cr.FPrintJob) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errCancelDialog,errEngine,'',
            'Tables.Verify <PEVerifyDatabase>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end
      else
        Result := True;
      {Restore Link Information}
      for i := 0 to pred(l.Count) do
      begin
        
        if not Cr.FCrpeEngine.PESetDatabaseLinkInfo(Cr.FPrintJob, PPEDatabaseLinkInfo(l[i])^) then
          Continue;
      end;
    finally
      for i := 0 to pred(l.Count) do
        FreeMem(l[i],siz);
      l.Free;
    end;
  end
  else
  begin
    {Verify Database}
    
    if not Cr.FCrpeEngine.PEVerifyDatabase(Cr.FPrintJob) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errCancelDialog,errEngine,'',
          'Tables.Verify <PEVerifyDatabase>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end
    else
      Result := True;
  end;
end;
{------------------------------------------------------------------------------}
{ ConvertDriver                                                                }
{------------------------------------------------------------------------------}
function TCrpeTables.ConvertDriver (DLLName: string): Boolean;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  
  if not Cr.FCrpeEngine.PEConvertDatabaseDriver(Cr.FPrintJob, PChar(DLLName), True) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errCancelDialog,errEngine,'',
        'Tables.ConvertDriver <PEConvertDatabaseDriver>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := True;
end;
{------------------------------------------------------------------------------}
{ SetPropagate                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeTables.SetPropagate (const Value: boolean);
begin
  FPropagate := Value;
  FItem.SetPath(FItem.FPath);
end;
{------------------------------------------------------------------------------}
{ GetFieldMapping                                                              }
{------------------------------------------------------------------------------}
function TCrpeTables.GetFieldMapping : TCrFieldMappingType;
var
  wFieldMapping : Word;
begin
  Result := FFieldMapping;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  {Get FieldMapping}
  wFieldMapping := PE_FM_AUTO_FLD_MAP;
  
  if not Cr.FCrpeEngine.PEGetFieldMappingType(Cr.FPrintJob, wFieldMapping) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Tables.GetFieldMapping <PEGetFieldMappingType>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  case wFieldMapping of
    PE_FM_AUTO_FLD_MAP          : FFieldMapping := fmAuto;
    PE_FM_CRPE_PROMPT_FLD_MAP   : FFieldMapping := fmPrompt;
    PE_FM_EVENT_DEFINED_FLD_MAP : FFieldMapping := fmEvent;
  end;
  Result := FFieldMapping;
end;
{------------------------------------------------------------------------------}
{ SetFieldMapping                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeTables.SetFieldMapping(const Value: TCrFieldMappingType);
var
  wFieldMapping   : Word;
  rptFieldMapping : TCrFieldMappingType;
begin
  FFieldMapping := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get FieldMapping from Report}
  rptFieldMapping := fmAuto;
  
  if not Cr.FCrpeEngine.PEGetFieldMappingType(Cr.FPrintJob, wFieldMapping) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob, errNoOption, errEngine,'',
        'Tables.SetFieldMapping <PEGetFieldMappingType>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  case wFieldMapping of
    PE_FM_AUTO_FLD_MAP          : rptFieldMapping := fmAuto;
    PE_FM_CRPE_PROMPT_FLD_MAP   : rptFieldMapping := fmPrompt;
    PE_FM_EVENT_DEFINED_FLD_MAP : rptFieldMapping := fmEvent;
  end;

  {Send FieldMapping to Report}
  if FFieldMapping <> rptFieldMapping then
  begin
    case FFieldMapping of
      fmAuto   : wFieldMapping := PE_FM_AUTO_FLD_MAP;
      fmPrompt : wFieldMapping := PE_FM_CRPE_PROMPT_FLD_MAP;
      fmEvent  : wFieldMapping := PE_FM_EVENT_DEFINED_FLD_MAP;
    end;
    
    if not Cr.FCrpeEngine.PESetFieldMappingType(Cr.FPrintJob, wFieldMapping) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Tables.SetFieldMapping <PESetFieldMappingType>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeTables.SetIndex (nIndex: integer);
var
  TableLoc    : PETableLocation;
  TableType   : PETableType;
  LogInfo     : PELogOnInfo;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or  (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Clear;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;

  {Get Location}
  
  if not Cr.FCrpeEngine.PEGetNthTableLocation(Cr.FPrintJob, nIndex, TableLoc) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Tables.SetIndex <PEGetNthTableLocation>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);
  FItem.FName := ExtractFileName(String(TableLoc.Location));
  FItem.FPath := ExtractFilePath(String(TableLoc.Location));
  FItem.FSubName := String(TableLoc.SubLocation);
  FItem.FConnectBuffer := String(TableLoc.ConnectBuffer);

  {Get Password}
  if not Cr.FCrpeEngine.PEGetNthTableLogOnInfo(Cr.FPrintJob, FIndex, LogInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Tables.SetIndex <PEGetNthTableLogOnInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FItem.FPassword := String(LogInfo.Password);

  {Get TableType}
  
  if not Cr.FCrpeEngine.PEGetNthTableType(Cr.FPrintJob, FIndex, TableType) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Tables.SetIndex <PEGetNthTableType>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  case TableType.DBType of
    PE_DT_STANDARD             : FItem.FTableType := ttStandard;
    PE_DT_SQL	               : FItem.FTableType := ttSQL;
    PE_DT_SQL_STORED_PROCEDURE : FItem.FTableType := ttStoredProcedure;
    else
      FItem.FTableType := ttUnknown;
  end;
  FItem.FDLLName := String(TableType.DLLName);
  FItem.FServerType := String(TableType.DescriptiveName);

  {Get Alias Name}
  if not Cr.FCrpeEngine.PEGetNthTableAliasName(Cr.FPrintJob, FIndex, hText, iText) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Tables[' + IntToStr(FIndex) + '].SetIndex <PEGetNthTableAliasName>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Get Alias Name string}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Tables[' + IntToStr(FIndex) + '].SetIndex <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FItem.FAliasName := String(pText);
  StrDispose(pText);

  {Update Fields}
  if FItem.FFields.FIndex > (FItem.FFields.Count-1) then
    FItem.FFields.SetIndex(-1);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.Tables[nIndex]                                                }
{------------------------------------------------------------------------------}
function TCrpeTables.GetItem(nIndex: integer): TCrpeTablesItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeTableFieldsItem                                                        }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeTableFieldsItem.Create;
begin
  inherited Create;
  FFieldName := '';
  FFieldType := fvUnknown;
  FFieldLength    := 0;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeTableFieldsItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeTableFieldsItem then
  begin
    FieldName   := TCrpeTableFieldsItem(Source).FieldName;
    FieldType   := TCrpeTableFieldsItem(Source).FieldType;
    FieldLength := TCrpeTableFieldsItem(Source).FieldLength;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeTableFieldsItem.Clear;
begin
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Parent.PropagateIndex(-1);
  if FIndex = -1 then
  begin
    FFieldName := '';
    SetFieldType(fvUnknown);
    FFieldLength := 0;
  end;
end;
{------------------------------------------------------------------------------}
{ FullName                                                                     }
{------------------------------------------------------------------------------}
function TCrpeTableFieldsItem.FullName : string;
begin
  Result := '{' + Cr.FTables.FItem.FAliasName + '.' + FFieldName + '}';
end;
{------------------------------------------------------------------------------}
{ InUse                                                                        }
{------------------------------------------------------------------------------}
function TCrpeTableFieldsItem.InUse : Boolean;
var
  sField : string;
  i      : integer;
begin
  Result := False;
  if (Cr = nil) then Exit;
  sField := FullName;
  i := Cr.FDatabaseFields.IndexOf(sField);
  Result := (i > -1);
end;
{------------------------------------------------------------------------------}
{ SetName                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeTableFieldsItem.SetFieldName (const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetValueType                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeTableFieldsItem.SetFieldType (const Value: TCrFieldValueType);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetFieldLength                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeTableFieldsItem.SetFieldLength (const Value: Word);
begin
  {Read only}
end;


{******************************************************************************}
{ Class TCrpeTableFields                                                       }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeTableFields.Create;
begin
  inherited Create;
  FItem := TCrpeTableFieldsItem.Create;
  FSubClassList.Add(FItem);
  FFieldNames := TStringList.Create;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeTableFields.Destroy;
begin
  FItem.Free;
  FFieldNames.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeTableFields.Clear;
var
  i,j : integer;
begin
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then PropagateIndex(-1);
  if FIndex = -1 then
    FItem.Clear
  else
  begin
    j := FIndex;
    for i := 0 to Count-1 do
      Items[i].Clear;
    if j > -1 then
      SetIndex(j)
    else
      FIndex := -1;
  end;
  FFieldNames.Clear;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeTableFields.Count: integer;
var
  nFields : Smallint;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  {Get number of Fields}
  
  nFields := Cr.FCrpeEngine.PEGetNDatabaseFields(Cr.FPrintJob, Cr.FTables.FIndex);
  if nFields = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'Count <PEGetNDatabaseFields>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := nFields;
end;
{------------------------------------------------------------------------------}
{ FieldByName                                                                  }
{------------------------------------------------------------------------------}
function TCrpeTableFields.FieldByName(sFieldName: string): TCrpeTableFieldsItem;
var
  iCurrent : integer;
  cnt      : integer;
begin
  Result := FItem;
  {Store current index}
  iCurrent := FIndex;
  {Locate field name}
  for cnt := 0 to (Count-1) do
  begin
    SetIndex(cnt);
    if CompareText(FItem.FFieldName, sFieldName) = 0 then
    begin
      Result := FItem;
      Break;
    end;
  end;
  {Re-set index}
  SetIndex(iCurrent);
end;
{------------------------------------------------------------------------------}
{ IndexOf                                                                      }
{------------------------------------------------------------------------------}
function TCrpeTableFields.IndexOf (sFieldName: string): integer;
var
  iCurrent : integer;
  cnt      : integer;
begin
  Result := -1;
  {Store current index}
  iCurrent := FIndex;
  {Locate field name}
  for cnt := 0 to (Count-1) do
  begin
    SetIndex(cnt);
    if CompareText(FItem.FFieldName, sFieldName) = 0 then
    begin
      Result := cnt;
      Break;
    end;
  end;
  {Re-set index}
  SetIndex(iCurrent);
end;
{------------------------------------------------------------------------------}
{ FieldNames                                                                   }
{------------------------------------------------------------------------------}
function TCrpeTableFields.FieldNames : TStrings;
var
  i,j : integer;
begin
  FFieldNames.Clear;
  Result := FFieldNames;
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.ReportName) then Exit;
  if not Cr.OpenPrintJob then Exit;

  j := FIndex;
  for i := 0 to Count - 1 do
    FFieldNames.Add(Items[i].FFieldName);
  if (j = -1) and (Count > 0) then j := 0;
  SetIndex(j);
  Result := FFieldNames;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeTableFields.SetIndex (nIndex: integer);
var
  FieldInfo : PEDatabaseFieldInfo;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or  (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Clear;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;

  {Get Location}
  
  if not Cr.FCrpeEngine.PEGetNthDatabaseFieldInfo(Cr.FPrintJob, Parent.FIndex, nIndex,
    FieldInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' + IntToStr(nIndex) +
        ') <PEGetNthDatabaseFieldInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);
  FItem.FFieldName := String(FieldInfo.databaseFieldName);
  if FieldInfo.valueType = PE_FVT_UNKNOWNFIELD then
     FItem.FFieldType := fvUnknown
  else
     FItem.FFieldType := TCrFieldValueType(FieldInfo.valueType);
  FItem.FFieldLength := FieldInfo.nBytes;
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeTableFields.GetItem(nIndex: integer) : TCrpeTableFieldsItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeSQL                                                               }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSQL.Create;
begin
  inherited Create;
  FQuery := TStringList.Create;
  xQuery := TStringList.Create;
  TStringList(FQuery).OnChange := OnChangeStrings;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSQL.Destroy;
begin
  TStringList(FQuery).OnChange := nil;
  FQuery.Free;
  xQuery.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSQL.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or  (not FileExists(Cr.FReportName)) then
  begin
    FQuery.Clear;
    xQuery.Clear;
  end
  else
  begin
    xQuery.Clear;
    SetQuery(xQuery);
  end;
end;
{------------------------------------------------------------------------------}
{ OnChangeStrings                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeSQL.OnChangeStrings(Sender: TObject);
begin
  TStringList(FQuery).OnChange := nil;
  xQuery.Assign(FQuery);
  SetQuery(xQuery);
  TStringList(FQuery).OnChange := OnChangeStrings;
end;
{------------------------------------------------------------------------------}
{ Retrieve                                                                     }
{------------------------------------------------------------------------------}
function TCrpeSQL.Retrieve : Boolean;
var
  hText : hWnd;
  iText : Smallint;
  pText : PChar;

begin
  Result := False;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get the SQL Query}
  
  if not Cr.FCrpeEngine.PEGetSQLQuery(Cr.FPrintJob, hText, iText) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormula,errEngine,'',
        'SQL.Retrieve <PEGetSQLQuery>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Retrieve the Query from the handle}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormula,errEngine,'',
        'SQL.Retrieve <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FQuery.SetText(pText);
  StrDispose(pText);
  Result := True;
end;
{------------------------------------------------------------------------------}
{ SetQuery                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeSQL.SetQuery (ListVar: TStrings);
var
  hText : hWnd;
  iText : Smallint;
  pText : PChar;
  sText : string;
  sTmp  : string;
begin
  FQuery.Assign(ListVar);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Retrieve the current Query from the Report}
  
  if not Cr.FCrpeEngine.PEGetSQLQuery(Cr.FPrintJob, hText, iText) then
  begin
    TStringList(FQuery).OnChange := OnChangeStrings;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SQL.SetQuery <PEGetSQLQuery>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Get the Query text}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    TStringList(FQuery).OnChange := OnChangeStrings;
    StrDispose(pText);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SQL.SetQuery <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sText := String(pText);
  StrDispose(pText);

  {Get VCL Query as PChar}
  sTmp := RTrimList(FQuery);
  {Compare it to the new Query}
  if CompareStr(sTmp, sText) <> 0 then
  begin
    {Send the Query}
    
    if not Cr.FCrpeEngine.PESetSQLQuery(Cr.FPrintJob, PChar(sTmp)) then
    begin
      TStringList(FQuery).OnChange := OnChangeStrings;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'SQL.SetQuery <PESetSQLQuery>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ Class TCrpeSelection                                                         }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSelection.Create;
begin
  inherited Create;
  FFormula := TStringList.Create;
  xFormula := TStringList.Create;
  TStringList(FFormula).OnChange := OnChangeStrings;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSelection.Destroy;
begin
  TStringList(FFormula).OnChange := nil;
  FFormula.Free;
  xFormula.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSelection.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or  (not FileExists(Cr.FReportName)) then
  begin
    FFormula.Clear;
    xFormula.Clear;
  end
  else
  begin
    xFormula.Clear;
    SetFormula(xFormula);
  end;
end;
{------------------------------------------------------------------------------}
{ Check                                                                        }
{------------------------------------------------------------------------------}
function TCrpeSelection.Check : Boolean;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  {Check the Selection Formula}
  
  Result := Cr.FCrpeEngine.PECheckSelectionFormula(Cr.FPrintJob);
  if Result = False then
    Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      'Selection.Check <PECheckSelectionFormula>');
end; {Check}
{------------------------------------------------------------------------------}
{ OnChangeStrings                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeSelection.OnChangeStrings(Sender: TObject);
begin
  TStringList(FFormula).OnChange := nil;
  xFormula.Assign(FFormula);
  SetFormula(xFormula);
  TStringList(FFormula).OnChange := OnChangeStrings;
end;
{------------------------------------------------------------------------------}
{ GetFormula                                                                   }
{------------------------------------------------------------------------------}
function TCrpeSelection.GetFormula: TStrings;
var
  hText : hWnd;
  iText : Smallint;
  pText : PChar;

begin
  Result := FFormula;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Retrieve the Selection Formula}
  
  if not Cr.FCrpeEngine.PEGetSelectionFormula(Cr.FPrintJob, hText, iText) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Selection.GetFormula <PEGetSelectionFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Retrieve the Selection Text}
  pText := StrAlloc(iText); 
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Selection.GetFormula <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FFormula.SetText(pText);
  StrDispose(pText);
  Result := FFormula;
end; { GetFormula }
{------------------------------------------------------------------------------}
{ SetFormula                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeSelection.SetFormula(ListVar: TStrings);
var
  hText : hWnd;
  iText : Smallint;
  pText : PChar;
  sText : string;
  sTmp  : string;

begin
  FFormula.Assign(ListVar);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Retrieve Record Selection Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetSelectionFormula(Cr.FPrintJob, hText, iText) then
  begin
    TStringList(FFormula).OnChange := OnChangeStrings;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Selection.SetFormula <PEGetSelectionFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get the Formula string from the Handle}
  pText := StrAlloc(iText); 
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Selection.SetFormula <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sText := string(pText);
  StrDispose(pText);

  {Trim of LF/CR characters}
  sTmp := RTrimList(FFormula);
  {Compare with Report: if changed assign formula to send}
  if CompareStr(sTmp, sText) <> 0 then
  begin
    {Send the Selection Formula into the Report}
    
    if not Cr.FCrpeEngine.PESetSelectionFormula(Cr.FPrintJob, PChar(sTmp)) then
    begin
      TStringList(FFormula).OnChange := OnChangeStrings;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Selection.SetFormula <PESetSelectionFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end; { SetFormula }


{******************************************************************************}
{ Class TCrpeGroupSelection                                                    }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGroupSelection.Create;
begin
  inherited Create;
  FFormula := TStringList.Create;
  xFormula := TStringList.Create;
  TStringList(FFormula).OnChange := OnChangeStrings;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeGroupSelection.Destroy;
begin
  TStringList(FFormula).OnChange := nil;
  FFormula.Free;
  xFormula.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSelection.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or  (not FileExists(Cr.FReportName)) then
  begin
    FFormula.Clear;
    xFormula.Clear;
  end
  else
  begin
    xFormula.Clear;
    SetFormula(xFormula);
  end;
end;
{------------------------------------------------------------------------------}
{ Check                                                                        }
{------------------------------------------------------------------------------}
function TCrpeGroupSelection.Check : Boolean;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  {Check the New Selection Formula}
  
  Result := Cr.FCrpeEngine.PECheckGroupSelectionFormula(Cr.FPrintJob);
  if Result = False then
    Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      'GroupSelection.Check <PECheckGroupSelectionFormula>');
end;
{------------------------------------------------------------------------------}
{ OnChangeStrings                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSelection.OnChangeStrings(Sender: TObject);
begin
  TStringList(FFormula).OnChange := nil;
  xFormula.Assign(FFormula);
  SetFormula(xFormula);
  TStringList(FFormula).OnChange := OnChangeStrings;
end;
{------------------------------------------------------------------------------}
{ GetFormula                                                                   }
{------------------------------------------------------------------------------}
function TCrpeGroupSelection.GetFormula: TStrings;
var
  hText : hWnd;
  iText : Smallint;
  pText : PChar;

begin
  Result := FFormula;
  if (Cr = nil) then Exit;
  if not Cr.JobIsOpen then Exit;

  {Retrieve the Group Selection Formula from the Report}
  
  if not Cr.FCrpeEngine.PEGetGroupSelectionFormula(Cr.FPrintJob, hText, iText) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupSelection.GetFormula <PEGetGroupSelectionFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupSelection.GetFormula <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FFormula.SetText(pText);
  StrDispose(pText);
  Result := FFormula;
end; { GetFormula }
{------------------------------------------------------------------------------}
{ SetFormula                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSelection.SetFormula(ListVar: TStrings);
var
  hText : hWnd;
  iText : Smallint;
  pText : PChar;
  sText : string;
  sTmp  : string;

begin
  FFormula.Assign(ListVar);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Retrieve Group Selection Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetGroupSelectionFormula(Cr.FPrintJob, hText, iText) then
  begin
    TStringList(FFormula).OnChange := OnChangeStrings;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupSelection.SetFormula <PEGetGroupSelectionFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get the Formula string from the Handle}
  pText := StrAlloc(iText); 
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupSelection.SetFormula <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sText := String(pText);
  StrDispose(pText);

  {Trim of LF/CR characters}
  sTmp := RTrimList(FFormula);
  {Compare with Report: if changed assign formula to send}
  if CompareStr(sTmp, sText) <> 0 then
  begin
    {Send the Selection Formula into the Report}
    
    if not Cr.FCrpeEngine.PESetGroupSelectionFormula(Cr.FPrintJob, PChar(sTmp)) then
    begin
      TStringList(FFormula).OnChange := OnChangeStrings;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GroupSelection.SetFormula <PESetGroupSelectionFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end; { SetFormula }


{******************************************************************************}
{ Class TCrpeSortFieldsItem                                                    }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSortFieldsItem.Create;
begin
  inherited Create;
  FFieldName := '';
  FDirection := sdAscending;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSortFieldsItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeSortFieldsItem then
  begin
    FieldName := TCrpeSortFieldsItem(Source).FieldName;
    Direction := TCrpeSortFieldsItem(Source).Direction;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSortFieldsItem.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex     := -1;
    FFieldName := '';
    FDirection := sdAscending;
  end;
end;
{------------------------------------------------------------------------------}
{ SetField                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeSortFieldsItem.SetFieldName (const Value: string);
var
  nDirection : Smallint;
  sField     : string;
  pField     : PChar;
  hField     : HWnd;
  iField     : Smallint;
begin
  FFieldName := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Retrieve SortField from Report}
  
  if not Cr.FCrpeEngine.PEGetNthSortField(Cr.FPrintJob, FIndex, hField, iField, nDirection) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SortFields.SetField <PEGetNthSortField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Sortfield name string}
  pField := StrAlloc(iField); 
  if not Cr.FCrpeEngine.PEGetHandleString(hField, pField, iField) then
  begin
    StrDispose(pField);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetField <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sField := String(pField);
  StrDispose(pField);

  {Check Field}
  if CompareStr(sField, FFieldName) <> 0 then
  begin
    sField := FFieldName;
    {Send SortField to Report}
    
    if not Cr.FCrpeEngine.PESetNthSortField(Cr.FPrintJob, FIndex,
      PChar(sField), nDirection) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetField <PESetNthSortField>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDirection                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeSortFieldsItem.SetDirection (const Value: TCrSortDirection);
var
  nDirection : Smallint;
  sField     : string;
  pField     : PChar;
  hField     : HWnd;
  iField     : Smallint;
begin
  FDirection := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Retrieve SortField from Report}
  
  if not Cr.FCrpeEngine.PEGetNthSortField(Cr.FPrintJob, FIndex, hField, iField, nDirection) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetDirection <PEGetNthSortField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Sortfield name string}
  pField := StrAlloc(iField);
  if not Cr.FCrpeEngine.PEGetHandleString(hField, pField, iField) then
  begin
    StrDispose(pField);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetDirection <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sField := String(pField);
  StrDispose(pField);

  {Check Direction}
  if nDirection <> Ord(FDirection) then
  begin
    nDirection := Ord(FDirection);
    {Send SortField to Report}
    
    if not Cr.FCrpeEngine.PESetNthSortField(Cr.FPrintJob, FIndex,
      PChar(sField), nDirection) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetDirection <PESetNthSortField>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ Class TCrpeSortFields                                                        }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSortFields.Create;
begin
  inherited Create;
  FItem  := TCrpeSortFieldsItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSortFields.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSortFields.Clear;
var
  i : integer;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    FItem.Clear;
  end
  else
  begin
    {Remove all SortFields}
    for i := Count-1 downto 0 do
      Delete(i);
    FIndex := -1;
  end;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeSortFields.Count : integer;
var
  nSortFields : Smallint;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get number of SortFields}
  
  nSortFields := Cr.FCrpeEngine.PEGetNSortFields(Cr.FPrintJob);
  if nSortFields = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SortFields.Count <PEGetNSortFields>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := nSortFields;
end;
{------------------------------------------------------------------------------}
{ Add                                                                          }
{------------------------------------------------------------------------------}
function TCrpeSortFields.Add (FieldName: string) : integer;
var
  nDirection : Smallint;
begin
  Result := -1;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  nDirection := Ord(sdAscending);

  {Add SortField}
  
  if not Cr.FCrpeEngine.PESetNthSortField(Cr.FPrintJob, Count,
    PChar(FieldName), nDirection) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SortFields.Add <PESetNthSortField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  SetIndex(Count-1);
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Delete                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSortFields.Delete(nIndex: integer);
begin
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  {Delete the SortField}
  
  if not Cr.FCrpeEngine.PEDeleteNthSortField(Cr.FPrintJob, nIndex) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SortFields.Delete <PEDeleteNthSortField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Decrement index if necessary}
  if FIndex = Count then
    SetIndex(FIndex-1);
end;
{------------------------------------------------------------------------------}
{ Insert                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSortFields.Insert(Position: Smallint; FieldName: string;
  Direction: TCrSortDirection);
var
  nDirection : Smallint;
begin
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  nDirection := Ord(Direction);
  {Insert the SortField}
  
  if not Cr.FCrpeEngine.PEInsertSortField(Cr.FPrintJob, Position, PChar(FieldName), nDirection) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SortFields.Insert <PEInsertSortField> ' + FieldName) of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Swap                                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeSortFields.Swap (SourceN, TargetN: Smallint);
begin
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Swap the SortFields}
  
  if not Cr.FCrpeEngine.PESwapSortFields(Cr.FPrintJob, SourceN, TargetN) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SortFields.Swap <PESwapSortFields>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeSortFields.SetIndex (nIndex: integer);
var
  nDirection : Smallint;
  pField     : PChar;
  hField     : HWnd;
  iField     : Smallint;

begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Clear;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;

  {Get SortField}
  
  if not Cr.FCrpeEngine.PEGetNthSortField(Cr.FPrintJob, nIndex, hField, iField, nDirection) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SortFields.SetIndex <PEGetNthSortField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);
  FItem.FDirection := TCrSortDirection(nDirection);

  {Get Sortfield name string}
  pField := StrAlloc(iField);
  if not Cr.FCrpeEngine.PEGetHandleString(hField, pField, iField) then
  begin
    StrDispose(pField);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SortFields.SetIndex <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FItem.FFieldName := String(pField);
  StrDispose(pField);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.SortFields[nIndex]                                            }
{------------------------------------------------------------------------------}
function TCrpeSortFields.GetItem(nIndex: integer) : TCrpeSortFieldsItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeGroupSortFieldsItem                                               }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGroupSortFieldsItem.Create;
begin
  inherited Create;
  FFieldName := '';
  FDirection := sdAscending;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSortFieldsItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeGroupSortFieldsItem then
  begin
    FieldName := TCrpeGroupSortFieldsItem(Source).FieldName;
    Direction := TCrpeGroupSortFieldsItem(Source).Direction;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSortFieldsItem.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex     := -1;
    FFieldName := '';
    FDirection := sdAscending;
  end;
end;
{------------------------------------------------------------------------------}
{ SetField                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSortFieldsItem.SetFieldName (const Value: string);
var
  nDirection : Smallint;
  sField     : string;
  pField     : PChar;
  hField     : HWnd;
  iField     : Smallint;
begin
  FFieldName := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Retrieve GSortField from Report}
  nDirection := 0;
  
  if not Cr.FCrpeEngine.PEGetNthGroupSortField(Cr.FPrintJob, FIndex, hField, iField, nDirection) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetField <PEGetNthGroupSortField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Group Sortfield name string}
  pField := StrAlloc(iField);
  if not Cr.FCrpeEngine.PEGetHandleString(hField, pField, iField) then
  begin
    StrDispose(pField);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetField <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sField := String(pField);
  StrDispose(pField);

  {Check Field}
  if CompareStr(sField, FFieldName) <> 0 then
  begin
    sField := FFieldName;
    {Send GroupSortField to Report}
    
    if not Cr.FCrpeEngine.PESetNthGroupSortField(Cr.FPrintJob, FIndex, PChar(sField), nDirection) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetField <PESetNthGroupSortField>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDirection                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSortFieldsItem.SetDirection (const Value: TCrSortDirection);
var
  nDirection : Smallint;
  sField     : string;
  pField     : PChar;
  hField     : HWnd;
  iField     : Smallint;
begin
  FDirection := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Retrieve GSortField from Report}
  
  if not Cr.FCrpeEngine.PEGetNthGroupSortField(Cr.FPrintJob, FIndex, hField, iField, nDirection) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetDirection <PEGetNthGroupSortField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GSortfield name string}
  pField := StrAlloc(iField);
  if not Cr.FCrpeEngine.PEGetHandleString(hField, pField, iField) then
  begin
    StrDispose(pField);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetDirection <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sField := String(pField);
  StrDispose(pField);

  {Check Direction}
  if nDirection <> Ord(FDirection) then
  begin
    nDirection := Ord(FDirection);
    {Send GroupSortField to Report}
    
    if not Cr.FCrpeEngine.PESetNthGroupSortField(Cr.FPrintJob, FIndex, PChar(sField), nDirection) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetDirection <PESetNthGroupSortField>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ Class TCrpeGroupSortFields                                                   }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGroupSortFields.Create;
begin
  inherited Create;
  FItem   := TCrpeGroupSortFieldsItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeGroupSortFields.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSortFields.Clear;
var
  i : integer;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    FItem.Clear;
  end
  else
  begin
    for i := Count-1 downto 0 do
      Delete(i);
    FIndex := -1;
  end;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeGroupSortFields.Count: integer;
var
  nGSortFields : Smallint;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get number of SortFields}
  
  nGSortFields := Cr.FCrpeEngine.PEGetNGroupSortFields(Cr.FPrintJob);
  if (nGSortFields = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupSortFields.Count <PEGetNGroupSortFields>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {The Print Engine can't handle more than 25 groups!}
  if nGSortFields > 25 then
    nGSortFields := 25;
  Result := nGSortFields;
end;
{------------------------------------------------------------------------------}
{ Add                                                                          }
{------------------------------------------------------------------------------}
function TCrpeGroupSortFields.Add (FieldName : string) : integer;
var
  nDirection : Smallint;
begin
  Result := -1;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  nDirection := Ord(sdAscending);

  {Add SortField}
  
  if not Cr.FCrpeEngine.PESetNthGroupSortField(Cr.FPrintJob, Count,
    PChar(FieldName), nDirection) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupSortFields.Add <PESetNthGroupSortField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  SetIndex(Count-1);
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Delete                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSortFields.Delete (nIndex: integer);
begin
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  {Delete the SortField}
  
  if not Cr.FCrpeEngine.PEDeleteNthGroupSortField(Cr.FPrintJob, nIndex) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupSortFields.Delete <PEDeleteNthGroupSortField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Decrement index if necessary}
  if FIndex = Count then
    SetIndex(FIndex-1);
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeGroupSortFields.SetIndex (nIndex: integer);
var
  nDirection : Smallint;
  pField     : PChar;
  hField     : HWnd;
  iField     : Smallint;

begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Clear;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;

  {Get GroupSortField}
  
  if not Cr.FCrpeEngine.PEGetNthGroupSortField(Cr.FPrintJob, nIndex, hField, iField, nDirection) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupSortFields.SetIndex <PEGetNthGroupSortField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);
  FItem.FDirection := TCrSortDirection(nDirection);

  {Get GroupSortField Field}
  pField := StrAlloc(iField);
  if not Cr.FCrpeEngine.PEGetHandleString(hField, pField, iField) then
  begin
    StrDispose(pField);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GroupSortFields.SetIndex <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FItem.FFieldName := String(pField);
  StrDispose(pField);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.GroupSortFields[nIndex]                                       }
{------------------------------------------------------------------------------}
function TCrpeGroupSortFields.GetItem(nIndex: integer) : TCrpeGroupSortFieldsItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeGroupTopN                                                         }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGroupTopN.Create;
begin
  inherited Create;
  FSortType      := tnUnsorted;
  FNGroups       := 5;
  FSortField     := '';
  FIncludeOthers := True;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeGroupTopN.Assign(Source: TPersistent);
begin
  if Source is TCrpeGroupTopN then
  begin
    SortType      := TCrpeGroupTopN(Source).SortType;
    NGroups       := TCrpeGroupTopN(Source).NGroups;
    SortField     := TCrpeGroupTopN(Source).SortField;
    IncludeOthers := TCrpeGroupTopN(Source).IncludeOthers;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGroupTopN.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex         := -1;
    FSortType      := tnUnsorted;
    FNGroups       := 5;
    FSortField     := '';
    FIncludeOthers := True;
  end;
end;
{------------------------------------------------------------------------------}
{ SetSortType                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeGroupTopN.SetSortType (const Value: TCrTopNSortType);
var
  GroupOptions : PEGroupOptions;
  iCondition   : Smallint;
begin
  FSortType := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the GroupOptions from the Report}
  
  if not Cr.FCrpeEngine.PEGetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetSortType <PEGetGroupOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Store the Report Condition setting}
  {Condition with Type Mask; This obtains the Type of
   Group Condition Field from the Condition variable}
  iCondition := GroupOptions.condition;
  iCondition := iCondition and PE_GC_TYPEMASK;
  case iCondition of
    {"Others" have no conditions}
    PE_GC_TYPEOTHER  : iCondition := PE_GC_ANYCHANGE;
    PE_GC_TYPEDATE   : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEBOOLEAN: iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPETIME   : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEDATETIME : iCondition := iCondition and PE_GC_CONDITIONMASK;
  end;
  GroupOptions.condition := iCondition;

  {SortType}
  if Ord(FSortType) <> GroupOptions.topOrBottomNGroups then
  begin
    GroupOptions.topOrBottomNGroups := Ord(FSortType);
    {Send GroupOptions to Report}
    
    if not Cr.FCrpeEngine.PESetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetSortType <PESetGroupOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetNGroups                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeGroupTopN.SetNGroups (const Value: Smallint);
var
  GroupOptions : PEGroupOptions;
  iCondition   : Smallint;
begin
  FNGroups := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the GroupOptions from the Report}
  
  if not Cr.FCrpeEngine.PEGetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetNGroups <PEGetGroupOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Store the Report Condition setting}
  {Condition with Type Mask; This obtains the Type of
   Group Condition Field from the Condition variable}
  iCondition := GroupOptions.condition;
  iCondition := iCondition and PE_GC_TYPEMASK;
  case iCondition of
    {"Others" have no conditions}
    PE_GC_TYPEOTHER   : iCondition := PE_GC_ANYCHANGE;
    PE_GC_TYPEDATE    : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEBOOLEAN : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPETIME    : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEDATETIME : iCondition := iCondition and PE_GC_CONDITIONMASK;
  end;
  GroupOptions.condition := iCondition;

  {TopNGroups}
  if Ord(FNGroups) <> GroupOptions.nTopOrBottomGroups then
  begin
    GroupOptions.nTopOrBottomGroups := Ord(FNGroups);
    {Send GroupOptions to Report}
    
    if not Cr.FCrpeEngine.PESetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetNGroups <PESetGroupOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetSortField                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGroupTopN.SetSortField (const Value: string);
var
  GroupOptions : PEGroupOptions;
  sField       : string;
  iCondition   : Smallint;
begin
  FSortField := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the GroupOptions from the Report}
  
  if not Cr.FCrpeEngine.PEGetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetSortField <PEGetGroupOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Store the Report Condition setting}
  {Condition with Type Mask; This obtains the Type of
   Group Condition Field from the Condition variable}
  iCondition := GroupOptions.condition;
  iCondition := iCondition and PE_GC_TYPEMASK;
  case iCondition of
    {"Others" have no conditions}
    PE_GC_TYPEOTHER   : iCondition := PE_GC_ANYCHANGE;
    PE_GC_TYPEDATE    : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEBOOLEAN : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPETIME    : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEDATETIME : iCondition := iCondition and PE_GC_CONDITIONMASK;
  end;
  GroupOptions.condition := iCondition;

  {SortField}
  sField := String(GroupOptions.topOrBottomNSortFieldName);
  if CompareStr(FSortField, sField) <> 0 then
  begin
    StrCopy(GroupOptions.topOrBottomNSortFieldName, PChar(FSortField));
    {Send GroupOptions to Report}
    
    if not Cr.FCrpeEngine.PESetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetSortField <PESetGroupOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetIncludeOthers                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeGroupTopN.SetIncludeOthers (const Value: Boolean);
var
  GroupOptions : PEGroupOptions;
  iCondition   : Smallint;
begin
  FIncludeOthers := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the GroupOptions from the Report}
  
  if not Cr.FCrpeEngine.PEGetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIncludeOthers <PEGetGroupOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Store the Report Condition setting}
  {Condition with Type Mask; This obtains the Type of
   Group Condition Field from the Condition variable}
  iCondition := GroupOptions.condition;
  iCondition := iCondition and PE_GC_TYPEMASK;
  case iCondition of
    {"Others" have no conditions}
    PE_GC_TYPEOTHER   : iCondition := PE_GC_ANYCHANGE;
    PE_GC_TYPEDATE    : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEBOOLEAN : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPETIME    : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEDATETIME : iCondition := iCondition and PE_GC_CONDITIONMASK;
  end;
  GroupOptions.condition := iCondition;

  {TopNIncludeOthers}
  if Ord(FIncludeOthers) = GroupOptions.discardOtherGroups then
  begin
    GroupOptions.discardOtherGroups := Smallint(not FIncludeOthers);
    {Send GroupOptions to Report}
    
    if not Cr.FCrpeEngine.PESetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetIncludeOthers <PESetGroupOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetOthersName                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGroupTopN.SetOthersName (const Value: string);
var
  GroupOptions : PEGroupOptions;
  sRpt         : string;
  iCondition   : Smallint;
begin
  if Length(Value) > PE_FIELD_NAME_LEN then
    FOthersName := Copy(Value, 1, PE_FIELD_NAME_LEN)
  else
    FOthersName := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the GroupOptions from the Report}
  
  if not Cr.FCrpeEngine.PEGetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetOthersName <PEGetGroupOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Store the Report Condition setting}
  {Condition with Type Mask; This obtains the Type of
   Group Condition Field from the Condition variable}
  iCondition := GroupOptions.condition;
  iCondition := iCondition and PE_GC_TYPEMASK;
  case iCondition of
    {"Others" have no conditions}
    PE_GC_TYPEOTHER   : iCondition := PE_GC_ANYCHANGE;
    PE_GC_TYPEDATE    : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEBOOLEAN : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPETIME    : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEDATETIME : iCondition := iCondition and PE_GC_CONDITIONMASK;
  end;
  GroupOptions.condition := iCondition;

  {OthersName}
  sRpt := String(GroupOptions.notInTopOrBottomNName);
  if CompareText(sRpt, FOthersName) <> 0 then
  begin
    StrCopy(GroupOptions.notInTopOrBottomNName, PChar(FOthersName));
    {Send GroupOptions to Report}
    
    if not Cr.FCrpeEngine.PESetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetOthersName <PESetGroupOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ Class TCrpeGroupHierarchy                                                    }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGroupHierarchy.Create;
begin
  inherited Create;
  FEnabled       := False;
  FInstanceField := '';
  FParentField   := '';
  FIndent        := 0;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeGroupHierarchy.Assign(Source: TPersistent);
begin
  if Source is TCrpeGroupHierarchy then
  begin
    Enabled       := TCrpeGroupHierarchy(Source).Enabled;
    InstanceField := TCrpeGroupHierarchy(Source).InstanceField;
    ParentField   := TCrpeGroupHierarchy(Source).ParentField;
    Indent        := TCrpeGroupHierarchy(Source).Indent;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGroupHierarchy.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex         := -1;
    FEnabled       := False;
    FInstanceField := '';
    FParentField   := '';
    FIndent        := 0;
  end;
end;
{------------------------------------------------------------------------------}
{ SetEnabled                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeGroupHierarchy.SetEnabled (const Value: Boolean);
var
  GroupOptions : PEGroupOptions;
  iCondition   : Smallint;
begin
  FEnabled := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the GroupOptions from the Report}
  
  if not Cr.FCrpeEngine.PEGetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetEnabled <PEGetGroupOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Store the Report Condition setting}
  {Condition with Type Mask; This obtains the Type of
   Group Condition Field from the Condition variable}
  iCondition := GroupOptions.condition;
  iCondition := iCondition and PE_GC_TYPEMASK;
  case iCondition of
    {"Others" have no conditions}
    PE_GC_TYPEOTHER   : iCondition := PE_GC_ANYCHANGE;
    PE_GC_TYPEDATE    : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEBOOLEAN : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPETIME    : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEDATETIME : iCondition := iCondition and PE_GC_CONDITIONMASK;
  end;
  GroupOptions.condition := iCondition;

  {Enabled}
  if Ord(FEnabled) <> GroupOptions.hierarchicalSorting then
  begin
    GroupOptions.hierarchicalSorting := Smallint(FEnabled);
    {Send GroupOptions to Report}
    
    if not Cr.FCrpeEngine.PESetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetEnabled <PESetGroupOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetInstanceField                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeGroupHierarchy.SetInstanceField (const Value: string);
var
  GroupOptions : PEGroupOptions;
  iCondition   : Smallint;
  sField       : string;
begin
  FInstanceField := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the GroupOptions from the Report}
  
  if not Cr.FCrpeEngine.PEGetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetInstanceField <PEGetGroupOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Store the Report Condition setting}
  {Condition with Type Mask; This obtains the Type of
   Group Condition Field from the Condition variable}
  iCondition := GroupOptions.condition;
  iCondition := iCondition and PE_GC_TYPEMASK;
  case iCondition of
    {"Others" have no conditions}
    PE_GC_TYPEOTHER   : iCondition := PE_GC_ANYCHANGE;
    PE_GC_TYPEDATE    : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEBOOLEAN : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPETIME    : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEDATETIME : iCondition := iCondition and PE_GC_CONDITIONMASK;
  end;
  GroupOptions.condition := iCondition;

  {InstanceField}
  sField := String(GroupOptions.instanceIDField);
  if CompareStr(FInstanceField, sField) <> 0 then
  begin
    StrCopy(GroupOptions.instanceIDField, PChar(FInstanceField));
    {Send GroupOptions to Report}
    
    if not Cr.FCrpeEngine.PESetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetInstanceField <PESetGroupOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetParentField                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeGroupHierarchy.SetParentField (const Value: string);
var
  GroupOptions : PEGroupOptions;
  iCondition   : Smallint;
  sField       : string;
begin
  FParentField := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the GroupOptions from the Report}
  
  if not Cr.FCrpeEngine.PEGetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetParentField <PEGetGroupOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Store the Report Condition setting}
  {Condition with Type Mask; This obtains the Type of
   Group Condition Field from the Condition variable}
  iCondition := GroupOptions.condition;
  iCondition := iCondition and PE_GC_TYPEMASK;
  case iCondition of
    {"Others" have no conditions}
    PE_GC_TYPEOTHER   : iCondition := PE_GC_ANYCHANGE;
    PE_GC_TYPEDATE    : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEBOOLEAN : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPETIME    : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEDATETIME : iCondition := iCondition and PE_GC_CONDITIONMASK;
  end;
  GroupOptions.condition := iCondition;

  {ParentField}
  sField := String(GroupOptions.parentIDField);
  if CompareStr(FParentField, sField) <> 0 then
  begin
    StrCopy(GroupOptions.parentIDField, PChar(FParentField));
    {Send GroupOptions to Report}
    
    if not Cr.FCrpeEngine.PESetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetParentField <PESetGroupOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetIndent                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeGroupHierarchy.SetIndent (const Value: LongInt);
var
  GroupOptions : PEGroupOptions;
  iCondition   : Smallint;
begin
  FIndent := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the GroupOptions from the Report}
  
  if not Cr.FCrpeEngine.PEGetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndent <PEGetGroupOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Store the Report Condition setting}
  {Condition with Type Mask; This obtains the Type of
   Group Condition Field from the Condition variable}
  iCondition := GroupOptions.condition;
  iCondition := iCondition and PE_GC_TYPEMASK;
  case iCondition of
    {"Others" have no conditions}
    PE_GC_TYPEOTHER   : iCondition := PE_GC_ANYCHANGE;
    PE_GC_TYPEDATE    : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEBOOLEAN : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPETIME    : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEDATETIME : iCondition := iCondition and PE_GC_CONDITIONMASK;
  end;
  GroupOptions.condition := iCondition;

  {Indent}
  if FIndent <> GroupOptions.groupIndent then
  begin
    GroupOptions.groupIndent := FIndent;
    {Send GroupOptions to Report}
    
    if not Cr.FCrpeEngine.PESetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetIndent <PESetGroupOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ Class TCrpeGroupsItem                                                        }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGroupsItem.Create;
begin
  inherited Create;
  FFieldName    := '';
  FCondition    := AnyChange;
  FDirection    := gdAscending;
  FGroupType    := gtOther;
  FRepeatGH     := False;
  FKeepTogether := False;
  FTopN         := TCrpeGroupTopN.Create;
  FSubClassList.Add(FTopN);
  FHierarchy    := TCrpeGroupHierarchy.Create;
  FSubClassList.Add(FHierarchy);
  FCustomizeGroupName := False;
  FGroupNameFormula := TStringList.Create;
  xFormula          := TStringList.Create;
  {Set up OnChange event}
  TStringList(FGroupNameFormula).OnChange := OnChangeGroupNameFormula;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeGroupsItem.Destroy;
begin
  TStringList(FGroupNameFormula).OnChange := nil;
  FTopN.Free;
  FHierarchy.Free;
  FGroupNameFormula.Free;
  xFormula.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeGroupsItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeGroupsItem then
  begin
    FieldName    := TCrpeGroupsItem(Source).FieldName;
    Condition    := TCrpeGroupsItem(Source).Condition;
    Direction    := TCrpeGroupsItem(Source).Direction;
    GroupType    := TCrpeGroupsItem(Source).GroupType;
    RepeatGH     := TCrpeGroupsItem(Source).RepeatGH;
    KeepTogether := TCrpeGroupsItem(Source).KeepTogether;
    TopN.Assign(TCrpeGroupsItem(Source).TopN);
    Hierarchy.Assign(TCrpeGroupsItem(Source).Hierarchy);
    CustomizeGroupName := TCrpeGroupsItem(Source).CustomizeGroupName;
    GroupNameFormula.Assign(TCrpeGroupsItem(Source).GroupNameFormula);
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGroupsItem.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex        := -1;
    FFieldName    := '';
    FCondition    := AnyChange;
    FDirection    := gdAscending;
    FGroupType    := gtOther;
    FRepeatGH     := False;
    FKeepTogether := False;
    FCustomizeGroupName := False;
    FGroupNameFormula.Clear;
  end;
  FTopN.Clear;
  FHierarchy.Clear;
end;
{------------------------------------------------------------------------------}
{ SetField                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeGroupsItem.SetFieldName (const Value: string);
var
  GroupOptions : PEGroupOptions;
  iCondition   : Smallint;
  sField       : string;
begin
  FFieldName := Value;
  {Check Length}
  if Length(FFieldName) > PE_FIELD_NAME_LEN then
    FFieldName := Copy(FFieldName, 1, PE_FIELD_NAME_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the GroupOptions from the Report}
  
  if not Cr.FCrpeEngine.PEGetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetField <PEGetGroupOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Store the Condition setting}
  iCondition := GroupOptions.condition;
  {Field}
  sField := String(GroupOptions.fieldName);

  {Condition with Type Mask; This obtains the Type of
   Group Condition Field from the Condition variable}
  iCondition := iCondition and PE_GC_TYPEMASK;
  case iCondition of
    {"Others" have no conditions}
    PE_GC_TYPEOTHER  : iCondition := PE_GC_ANYCHANGE;
    PE_GC_TYPEDATE   : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEBOOLEAN: iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPETIME   : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEDATETIME : iCondition := iCondition and PE_GC_CONDITIONMASK;
  end;

  {Check to see if GroupField has changed}
  if CompareStr(FFieldName, sField) <> 0 then
  begin
    GroupOptions.condition := iCondition;
    StrCopy(GroupOptions.fieldName, PChar(FFieldName));
    {Send GroupOptions to Report}
    
    if not Cr.FCrpeEngine.PESetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetField <PESetGroupOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetGroupType                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGroupsItem.SetGroupType (const Value: TCrGroupType);
var
  GroupOptions : PEGroupOptions;
  {variables for Rpt settings}
  iCondition   : Smallint;
  vCondition   : Smallint;
begin
  FGroupType := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Update Condition to match GroupType, else an error will occur}
  case FGroupType of
    gtOther    : FCondition := AnyChange;
    gtDate     : begin
                   if not (FCondition in [dateDaily..dateAnnually]) then
                     FCondition := dateDaily;
                 end;
    gtBoolean  : begin
                   if not (FCondition in [boolToYes..boolNextIsNo]) then
                     FCondition := boolToYes;
                 end;
    gtTime     : begin
                   if not (FCondition in [timeBySecond..timeByAMPM]) then
                     FCondition := timeBySecond;
                 end;
    gtDateTime : begin
                   if not ((FCondition in [dateDaily..dateAnnually]) or
                           (FCondition in [timeBySecond..timeByAMPM])) then
                     FCondition := dateDaily;
                 end;
  end;

  {Get the GroupOptions from the Report}

  if not Cr.FCrpeEngine.PEGetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetGroupType <PEGetGroupOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Store the Report Condition setting}
  iCondition := GroupOptions.condition;

  {Condition with Type Mask; This obtains the Type of
   Group Condition Field from the Condition variable}
  iCondition := iCondition and PE_GC_TYPEMASK;
  case iCondition of
    {"Others" have no conditions}
    PE_GC_TYPEOTHER  : iCondition := PE_GC_ANYCHANGE;
    PE_GC_TYPEDATE   : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEBOOLEAN: iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPETIME   : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEDATETIME : iCondition := iCondition and PE_GC_CONDITIONMASK;
    else
      iCondition := PE_GC_ANYCHANGE;
  end;

  {Convert the VCL Condition setting}
  case FGroupType of
    gtOther   : vCondition := 0;
    gtDate    : vCondition := Ord(FCondition) - 1; {constants: 0..7/vcl: 1..8}
    gtBoolean : vCondition := Ord(FCondition) - 8; {constants: 1..6/vcl: 9..14}
    gtTime    : vCondition := Ord(FCondition) - 7; {constants: 8..11/vcl: 15..18}
    else
      vCondition := 0;
  end;

  {Condition}
  if vCondition <> iCondition then
  begin
    GroupOptions.condition := vCondition;
    {Send GroupOptions to Report}
    
    if not Cr.FCrpeEngine.PESetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetGroupType <PESetGroupOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetCondition                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGroupsItem.SetCondition (const Value: TCrGroupCondition);
var
  GroupOptions : PEGroupOptions;
  {variables for Rpt settings}
  iCondition   : Smallint;
  vCondition   : Smallint;
begin
  FCondition := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Update GroupType to avoid an error}
  case FCondition of
    AnyChange                : FGroupType := gtOther;
    dateDaily..dateAnnually  : begin
                                 if FGroupType <> gtDateTime then
                                   FGroupType := gtDate;
                               end;
    boolToYes..boolNextIsNo  : FGroupType := gtBoolean;
    timeBySecond..timeByAMPM : begin
                                 if FGroupType <> gtDateTime then
                                   FGroupType := gtTime;
                               end;
  end;

  {Get the GroupOptions from the Report}
  if not Cr.FCrpeEngine.PEGetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetCondition <PEGetGroupOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Store the Report Condition setting}
  iCondition := GroupOptions.condition;

  {Condition with Type Mask; This obtains the Type of
   Group Condition Field from the Condition variable}
  iCondition := iCondition and PE_GC_TYPEMASK;
  case iCondition of
    {"Others" have no conditions}
    PE_GC_TYPEOTHER  : iCondition := PE_GC_ANYCHANGE;
    PE_GC_TYPEDATE   : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEBOOLEAN: iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPETIME   : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEDATETIME : iCondition := iCondition and PE_GC_CONDITIONMASK;
    else
      iCondition := PE_GC_ANYCHANGE;
  end;

  {Convert the VCL Condition setting}
  case FGroupType of
    gtOther   : vCondition := 0;
    gtDate    : vCondition := Ord(FCondition) - 1; {constants: 0..7/vcl: 1..8}
    gtBoolean : vCondition := Ord(FCondition) - 8; {constants: 1..6/vcl: 9..14}
    gtTime    : vCondition := Ord(FCondition) - 7; {constants: 8..11/vcl: 15..18}
    else
      vCondition := 0;
  end;

  {Condition}
  if vCondition <> iCondition then
  begin
    GroupOptions.condition := vCondition;
    {Send GroupOptions to Report}
    
    if not Cr.FCrpeEngine.PESetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetCondition <PESetGroupOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDirection                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGroupsItem.SetDirection (const Value: TCrGroupDirection);
var
  GroupOptions : PEGroupOptions;
  iCondition   : Smallint;
  iDirection   : Smallint;
begin
  FDirection := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the GroupOptions from the Report}
  
  if not Cr.FCrpeEngine.PEGetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetDirection <PEGetGroupCondition>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Store the Condition setting}
  iCondition := GroupOptions.condition;
  iDirection := GroupOptions.sortDirection;

  {Condition with Type Mask; This obtains the Type of
   Group Condition Field from the Condition variable}
  iCondition := iCondition and PE_GC_TYPEMASK;
  case iCondition of
    {"Others" have no conditions}
    PE_GC_TYPEOTHER  : iCondition := PE_GC_ANYCHANGE;
    PE_GC_TYPEDATE   : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEBOOLEAN: iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPETIME   : iCondition := iCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEDATETIME : iCondition := iCondition and PE_GC_CONDITIONMASK;
  end;

  {Check to see if Direction has changed}
  if Ord(FDirection) <> iDirection then
  begin
    GroupOptions.condition := iCondition;
    GroupOptions.sortDirection := Ord(FDirection);
    {Send GroupOptions to Report}
    
    if not Cr.FCrpeEngine.PESetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetDirection <PESetGroupOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetRepeatGH                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeGroupsItem.SetRepeatGH (const Value: Boolean);
var
  GroupOptions : PEGroupOptions;
  rCondition   : Smallint;
begin
  FRepeatGH := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the GroupOptions from the Report}
  
  if not Cr.FCrpeEngine.PEGetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetRepeatGH <PEGetGroupOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Store the Report Condition setting}
  {Condition with Type Mask; This obtains the Type of
   Group Condition Field from the Condition variable}
  rCondition := GroupOptions.condition;
  rCondition := rCondition and PE_GC_TYPEMASK;
  case rCondition of
    {"Others" have no conditions}
    PE_GC_TYPEOTHER  : rCondition := PE_GC_ANYCHANGE;
    PE_GC_TYPEDATE   : rCondition := rCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEBOOLEAN: rCondition := rCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPETIME   : rCondition := rCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEDATETIME : rCondition := rCondition and PE_GC_CONDITIONMASK;
  end;
  GroupOptions.condition := rCondition;

  {RepeatGH}
  if Ord(FRepeatGH) <> GroupOptions.repeatGroupHeader then
  begin
    GroupOptions.repeatGroupHeader := Ord(FRepeatGH);
    {Send GroupOptions to Report}
    
    if not Cr.FCrpeEngine.PESetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetRepeatGH <PESetGroupOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetKeepTogether                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeGroupsItem.SetKeepTogether (const Value: Boolean);
var
  GroupOptions : PEGroupOptions;
  rCondition   : Smallint;
begin
  FKeepTogether := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the GroupOptions from the Report}
  
  if not Cr.FCrpeEngine.PEGetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetKeepTogether <PEGetGroupOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Store the Report Condition setting}
  {Condition with Type Mask; This obtains the Type of
   Group Condition Field from the Condition variable}
  rCondition := GroupOptions.condition;
  rCondition := rCondition and PE_GC_TYPEMASK;
  case rCondition of
    {"Others" have no conditions}
    PE_GC_TYPEOTHER  : rCondition := PE_GC_ANYCHANGE;
    PE_GC_TYPEDATE   : rCondition := rCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEBOOLEAN: rCondition := rCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPETIME   : rCondition := rCondition and PE_GC_CONDITIONMASK;
    PE_GC_TYPEDATETIME : rCondition := rCondition and PE_GC_CONDITIONMASK;
  end;
  GroupOptions.condition := rCondition;

  {KeepTogether}
  if Ord(FKeepTogether) <> GroupOptions.keepGroupTogether then
  begin
    GroupOptions.keepGroupTogether := Ord(FKeepTogether);
    {Send GroupOptions to Report}
    
    if not Cr.FCrpeEngine.PESetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetKeepTogether <PESetGroupOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetCustomizeGroupName                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGroupsItem.SetCustomizeGroupName (const Value: Boolean);
var
  GroupOptions : PEGroupOptions;
begin
  FCustomizeGroupName := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the GroupOptions from the Report}
  
  if not Cr.FCrpeEngine.PEGetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetCustomizeGroupName <PEGetGroupOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if Ord(FCustomizeGroupName) <> GroupOptions.customizeGroupName then
  begin
    GroupOptions.customizeGroupName := Ord(FCustomizeGroupName);
    {Send GroupOptions to Report}
    
    if not Cr.FCrpeEngine.PESetGroupOptions(Cr.FPrintJob, FIndex, GroupOptions) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetCustomizeGroupName <PESetGroupOptions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetGroupNameFormula                                                        }
{------------------------------------------------------------------------------}
function TCrpeGroupsItem.GetGroupNameFormula : TStrings;
var
  hText : HWnd;
  iText : Smallint;
  pText : PChar;
begin
  Result := FGroupNameFormula;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetNthGroupNameFormula(Cr.FPrintJob, FIndex,
    hText, iText) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetGroupNameFormula <PEGetNthGroupNameFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get FormatFormula Text}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetGroupNameFormula <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FGroupNameFormula.SetText(pText);
  StrDispose(pText);
  Result := FGroupNameFormula;
end;
{------------------------------------------------------------------------------}
{ SetGroupNameFormula                                                          }
{------------------------------------------------------------------------------}
procedure TCrpeGroupsItem.SetGroupNameFormula (const Value: TStrings);
var
  sRPT, sVCL : string;
  pText      : PChar;
  hText      : HWnd;
  iText      : Smallint;

begin
  FGroupNameFormula.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetNthGroupNameFormula(Cr.FPrintJob, FIndex,
    hText, iText) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetGroupNameFormula <PEGetNthGroupNameFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get FormatFormula Text}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetGroupNameFormula <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sRPT := String(pText);
  StrDispose(pText);

  sVCL := RTrimList(FGroupNameFormula);
  {Compare Formula with Report Formula}
  if CompareText(sVCL, sRPT) <> 0 then
  begin
    if not Cr.FCrpeEngine.PESetNthGroupNameFormula(Cr.FPrintJob, FIndex, PChar(sVCL)) then
    begin
      TStringList(FGroupNameFormula).OnChange := OnChangeGroupNameFormula;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetGroupNameFormula <PESetNthGroupNameFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ OnChangeGroupNameFormula                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeGroupsItem.OnChangeGroupNameFormula (Sender: TObject);
begin
  if Sender is TStringList then
  begin
    TStringList(Sender).OnChange := nil;
    xFormula.Assign(TStringList(Sender));
    SetGroupNameFormula(xFormula);
    TStringList(Sender).OnChange := OnChangeGroupNameFormula;
  end;
end;


{******************************************************************************}
{ Class TCrpeGroupOptions                                                      }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGroups.Create;
begin
  inherited Create;
  FItem := TCrpeGroupsItem.Create;
  FSubClassList.Add(FItem);
  FGroupNames := TStringList.Create;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeGroups.Destroy;
begin
  FItem.Free;
  FGroupNames.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGroups.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    FItem.Clear;
  end;
  FGroupNames.Clear;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeGroups.Count: integer;
var
  nGroups : Smallint;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get the number of Groups}
  
  nGroups := Cr.FCrpeEngine.PEGetNGroups(Cr.FPrintJob);
  if (nGroups = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Groups.Count <PEGetNGroups>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {The Print Engine can't handle more than 25 groups!}
  if nGroups > 25 then
    nGroups := 25;
  Result := nGroups;
end;
{------------------------------------------------------------------------------}
{ Swap                                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeGroups.Swap(SourceN, TargetN: Smallint);
begin
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Swap the Groups}
  
  if not Cr.FCrpeEngine.PESwapGroups(Cr.FPrintJob, SourceN, TargetN) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Groups.Swap <PESwapGroups>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Group Names                                                                  }
{------------------------------------------------------------------------------}
function TCrpeGroups.Names : TStrings;
var
  i,j : integer;
begin
  FGroupNames.Clear;
  Result := FGroupNames;
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.ReportName) then  Exit;
  if not Cr.OpenPrintJob then Exit;

  j := FIndex;
  for i := 0 to Count-1 do
  begin
    SetIndex(i);
    FGroupNames.Add(FItem.FFieldName);
  end;
  if (j = -1) and (Count > 0) then j := 0;
  SetIndex(j);
  Result := FGroupNames;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeGroups.SetIndex (nIndex: integer);
var
  GroupOptions : PEGroupOptions;
  int1,int2    : Smallint;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Clear;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;

  {Get GroupOptions}
  
  if not Cr.FCrpeEngine.PEGetGroupOptions(Cr.FPrintJob, nIndex, GroupOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetGroupOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);
  FItem.FFieldName := String(GroupOptions.fieldName);
  {Direction}
  case GroupOptions.SortDirection of
    PE_SF_DESCENDING : FItem.FDirection := gdDescending;
    PE_SF_ASCENDING  : FItem.FDirection := gdAscending;
    PE_SF_ORIGINAL   : FItem.FDirection := gdOriginal;
    PE_SF_SPECIFIED  : FItem.FDirection := gdSpecified;
    else
      FItem.FDirection := gdAscending;
  end;
  {RepeatGH}
  case GroupOptions.repeatGroupHeader of
    0 : FItem.FRepeatGH := False;
    1 : FItem.FRepeatGH := True;
    else
       FItem.FRepeatGH := False;
  end;
  {KeepTogether}
  case GroupOptions.keepGroupTogether of
    0 : FItem.FKeepTogether := False;
    1 : FItem.FKeepTogether := True;
    else
      FItem.FKeepTogether := False;
  end;

  {CustomizeGroupName, TopN.OthersName}
  case GroupOptions.customizeGroupName of
    0 : FItem.FCustomizeGroupName := False;
    1 : FItem.FCustomizeGroupName := True;
    else
      FItem.FCustomizeGroupName := False;
  end;
  FItem.FTopN.FOthersName := String(GroupOptions.notInTopOrBottomNName);

  {TopN.IncludeOthers}
  case GroupOptions.discardOtherGroups of
    0 : FItem.FTopN.FIncludeOthers := True;
    1 : FItem.FTopN.FIncludeOthers := False;
    else
      FItem.FTopN.FIncludeOthers := True;
  end;
  {TopN.SortType}
  case GroupOptions.topOrBottomNGroups of
    PE_GO_TBN_ALL_GROUPS_UNSORTED : FItem.FTopN.FSortType := tnUnsorted;
    PE_GO_TBN_ALL_GROUPS_SORTED   : FItem.FTopN.FSortType := tnSortAll;
    PE_GO_TBN_TOP_N_GROUPS        : FItem.FTopN.FSortType := tnTopN;
    PE_GO_TBN_BOTTOM_N_GROUPS     : FItem.FTopN.FSortType := tnBottomN;
    else
      FItem.FTopN.FSortType := tnUnsorted;
  end;
  {TopN.NGroups}
  FItem.FTopN.FNGroups := GroupOptions.nTopOrBottomGroups;
  {TopN.SortField}
  FItem.FTopN.FSortField := String(GroupOptions.topOrBottomNSortFieldName);

  {Hierarchy.Enabled}
  case GroupOptions.hierarchicalSorting of
    0 : FItem.FHierarchy.FEnabled := False;
    1 : FItem.FHierarchy.FEnabled := True;
    else
      FItem.FHierarchy.FEnabled := False;
  end;
  {Hierarchy.InstanceField}
  FItem.FHierarchy.FInstanceField := String(GroupOptions.instanceIDField);
  {Hierarchy.ParentField}
  FItem.FHierarchy.FParentField := String(GroupOptions.parentIDField);
  {Hierarchy.Indent}
  FItem.FHierarchy.FIndent := GroupOptions.groupIndent;

  {Condition with Type Mask; This obtains the Type of
   Group Condition Field from the Condition variable}
  int1 := GroupOptions.condition and PE_GC_TYPEMASK;  //$0F00
  int2 := GroupOptions.condition and PE_GC_CONDITIONMASK;  //$00FF

  {GroupType and Condition}
  case int1 of
    {"Others" have no conditions}
    PE_GC_TYPEOTHER:  // $0000
      begin
        FItem.FGroupType := gtOther;
        FItem.FCondition := AnyChange;
      end;
    PE_GC_TYPEDATE:   //$0200;
      begin
        FItem.FGroupType := gtDate;
        {Condition with Condition Mask; This obtains the
         condition of the group from the Condition variable}
        case int2 of
          PE_GC_DAILY        : FItem.FCondition := dateDaily;
          PE_GC_WEEKLY       : FItem.FCondition := dateWeekly;
          PE_GC_BIWEEKLY     : FItem.FCondition := dateBiWeekly;
          PE_GC_SEMIMONTHLY  : FItem.FCondition := dateSemiMonthly;
          PE_GC_MONTHLY      : FItem.FCondition := dateMonthly;
          PE_GC_QUARTERLY    : FItem.FCondition := dateQuarterly;
          PE_GC_SEMIANNUALLY : FItem.FCondition := dateSemiAnnually;
          PE_GC_ANNUALLY     : FItem.FCondition := dateAnnually;
          else
            FItem.FCondition := AnyChange;
        end;
      end;
    PE_GC_TYPEBOOLEAN:  //$0400:
      begin
        FItem.FGroupType := gtBoolean;
        case int2 of
          PE_GC_TOYES     : FItem.FCondition := boolToYes;
          PE_GC_TONO      : FItem.FCondition := boolToNo;
          PE_GC_EVERYYES  : FItem.FCondition := boolEveryYes;
          PE_GC_EVERYNO   : FItem.FCondition := boolEveryNo;
          PE_GC_NEXTISYES : FItem.FCondition := boolNextIsYes;
          PE_GC_NEXTISNO  : FItem.FCondition := boolNextIsNo;
          else
            FItem.FCondition := AnyChange;
        end;
      end;
    PE_GC_TYPETIME:  //$0800:
      begin
        FItem.FGroupType := gtTime;
        case int2 of
          PE_GC_BYSECOND : FItem.FCondition := timeBySecond;
          PE_GC_BYMINUTE : FItem.FCondition := timeByMinute;
          PE_GC_BYHOUR   : FItem.FCondition := timeByHour;
          PE_GC_BYAMPM   : FItem.FCondition := timeByAMPM;
          else
            FItem.FCondition := AnyChange;
        end;
      end;
    {DateTime type added for CR 9.x}
    PE_GC_TYPEDATETIME :  // $A00
      begin
        FItem.FGroupType := gtDateTime;
        {Condition with Condition Mask; This obtains the
         condition of the group from the Condition variable}
        case int2 of
          PE_GC_DAILY        : FItem.FCondition := dateDaily;
          PE_GC_WEEKLY       : FItem.FCondition := dateWeekly;
          PE_GC_BIWEEKLY     : FItem.FCondition := dateBiWeekly;
          PE_GC_SEMIMONTHLY  : FItem.FCondition := dateSemiMonthly;
          PE_GC_MONTHLY      : FItem.FCondition := dateMonthly;
          PE_GC_QUARTERLY    : FItem.FCondition := dateQuarterly;
          PE_GC_SEMIANNUALLY : FItem.FCondition := dateSemiAnnually;
          PE_GC_ANNUALLY     : FItem.FCondition := dateAnnually;
          {Time }
          PE_GC_BYSECOND     : FItem.FCondition := timeBySecond;
          PE_GC_BYMINUTE     : FItem.FCondition := timeByMinute;
          PE_GC_BYHOUR       : FItem.FCondition := timeByHour;
          PE_GC_BYAMPM       : FItem.FCondition := timeByAMPM;
          else
            FItem.FCondition := AnyChange;
        end;
      end;
  end; {case}
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.Groups[nIndex]                                                }
{------------------------------------------------------------------------------}
function TCrpeGroups.GetItem(nIndex: integer) : TCrpeGroupsItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;
{------------------------------------------------------------------------------}
{ SetItem                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeGroups.SetItem (const nItem: TCrpeGroupsItem);
begin
  FItem.Assign(nItem);
end;


{******************************************************************************}
{ Class TCrpeSectionFormatFormulas                                             }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSectionFormatFormulas.Create;
begin
  inherited Create;
  FSuppress             := TStringList.Create;
  FNewPageBefore        := TStringList.Create;
  FNewPageAfter         := TStringList.Create;
  FKeepTogether         := TStringList.Create;
  FSuppressBlankSection := TStringList.Create;
  FResetPageNAfter      := TStringList.Create;
  FPrintAtBottomOfPage  := TStringList.Create;
  FBackgroundColor      := TStringList.Create;
  FUnderlaySection      := TStringList.Create;
  xFormula              := TStringList.Create;
  {Set up OnChange event}
  TStringList(FSuppress).OnChange := OnChangeSuppress;
  TStringList(FNewPageBefore).OnChange := OnChangeNewPageBefore;
  TStringList(FNewPageAfter).OnChange := OnChangeNewPageAfter;
  TStringList(FKeepTogether).OnChange := OnChangeKeepTogether;
  TStringList(FSuppressBlankSection).OnChange := OnChangeSuppressBlankSection;
  TStringList(FResetPageNAfter).OnChange := OnChangeResetPageNAfter;
  TStringList(FPrintAtBottomOfPage).OnChange := OnChangePrintAtBottomOfPage;
  TStringList(FBackgroundColor).OnChange := OnChangeBackgroundColor;
  TStringList(FUnderlaySection).OnChange := OnChangeUnderlaySection;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSectionFormatFormulas.Destroy;
begin
  TStringList(FSuppress).OnChange := nil;
  TStringList(FNewPageBefore).OnChange := nil;
  TStringList(FNewPageAfter).OnChange := nil;
  TStringList(FKeepTogether).OnChange := nil;
  TStringList(FSuppressBlankSection).OnChange := nil;
  TStringList(FResetPageNAfter).OnChange := nil;
  TStringList(FPrintAtBottomOfPage).OnChange := nil;
  TStringList(FBackgroundColor).OnChange := nil;
  TStringList(FUnderlaySection).OnChange := nil;
  FSuppress.Free;
  FNewPageBefore.Free;
  FNewPageAfter.Free;
  FKeepTogether.Free;
  FSuppressBlankSection.Free;
  FResetPageNAfter.Free;
  FPrintAtBottomOfPage.Free;
  FBackgroundColor.Free;
  FUnderlaySection.Free;
  xFormula.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.Assign(Source: TPersistent);
begin
  if Source is TCrpeSectionFormatFormulas then
  begin
    Suppress.Assign(TCrpeSectionFormatFormulas(Source).Suppress);
    NewPageBefore.Assign(TCrpeSectionFormatFormulas(Source).NewPageBefore);
    NewPageAfter.Assign(TCrpeSectionFormatFormulas(Source).NewPageAfter);
    KeepTogether.Assign(TCrpeSectionFormatFormulas(Source).KeepTogether);
    SuppressBlankSection.Assign(TCrpeSectionFormatFormulas(Source).SuppressBlankSection);
    ResetPageNAfter.Assign(TCrpeSectionFormatFormulas(Source).ResetPageNAfter);
    PrintAtBottomOfPage.Assign(TCrpeSectionFormatFormulas(Source).PrintAtBottomOfPage);
    BackgroundColor.Assign(TCrpeSectionFormatFormulas(Source).BackgroundColor);
    UnderlaySection.Assign(TCrpeSectionFormatFormulas(Source).UnderlaySection);
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    FSuppress.Clear;
    FNewPageBefore.Clear;
    FNewPageAfter.Clear;
    FKeepTogether.Clear;
    FSuppressBlankSection.Clear;
    FResetPageNAfter.Clear;
    FPrintAtBottomOfPage.Clear;
    FBackgroundColor.Clear;
    FUnderlaySection.Clear;
    xFormula.Clear;
  end
  else
  begin
    xFormula.Clear;
    SetSuppress(xFormula);
    SetNewPageBefore(xFormula);
    SetNewPageAfter(xFormula);
    SetKeepTogether(xFormula);
    SetSuppressBlankSection(xFormula);
    SetResetPageNAfter(xFormula);
    SetPrintAtBottomOfPage(xFormula);
    SetBackgroundColor(xFormula);
    SetUnderlaySection(xFormula);
  end;
end;
{------------------------------------------------------------------------------}
{ GetSuppress                                                                  }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetSuppress : TStrings;
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
begin
  Result := FSuppress;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeSectionFormatItem(Parent).FSection, SectionCode) then
  begin
    TStringList(FSuppress).OnChange := OnChangeSuppress;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'GetSuppress <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula from Report}

  if not Cr.FCrpeEngine.PEGetSectionFormatFormula(Cr.FPrintJob, SectionCode,
     PE_FFN_SECTION_VISIBILITY, hText, iText) then
  begin
    TStringList(FSuppress).OnChange := OnChangeSuppress;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'GetSuppress <PEGetSectionFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula Text}
  pText := GlobalLock(hText);
  FSuppress.Text := WideCharToString(PWideChar(pText));
  GlobalUnlock(hText);
  GlobalFree(hText);
  Result := FSuppress;
end;
{------------------------------------------------------------------------------}
{ SetSuppress                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.SetSuppress (const Value: TStrings);
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
  sRPT,sVCL   : string;


begin
  FSuppress.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeSectionFormatItem(Parent).FSection, SectionCode) then
  begin
    TStringList(FSuppress).OnChange := OnChangeSuppress;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetSuppress <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetSectionFormatFormula(Cr.FPrintJob, SectionCode,
     PE_FFN_SECTION_VISIBILITY, hText, iText) then
  begin
    TStringList(FSuppress).OnChange := OnChangeSuppress;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'SetSuppress <PEGetSectionFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula Text}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FSuppress).OnChange := OnChangeSuppress;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'SetSuppress <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sRPT := String(pText);
  StrDispose(pText);
  sVCL := RTrimList(FSuppress);

  {Compare it to the new Formula}
  if CompareStr(sVCL, sRPT) <> 0 then
  begin
    {Send SectionFormatFormula to Report}
    
    if not Cr.FCrpeEngine.PESetSectionFormatFormula(Cr.FPrintJob, SectionCode,
      PE_FFN_SECTION_VISIBILITY, PChar(sVCL)) then
    begin
      TStringList(FSuppress).OnChange := OnChangeSuppress;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetSuppress <PESetSectionFormatFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ OnChangeSuppress                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.OnChangeSuppress (Sender: TObject);
begin
  if Sender is TStringList then
  begin
    TStringList(Sender).OnChange := nil;
    xFormula.Assign(TStringList(Sender));
    SetSuppress(xFormula);
    TStringList(Sender).OnChange := OnChangeSuppress;
  end;
end;
{------------------------------------------------------------------------------}
{ GetNewPageBefore                                                             }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetNewPageBefore : TStrings;
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;

begin
  Result := FNewPageBefore;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeSectionFormatItem(Parent).FSection, SectionCode) then
  begin
    TStringList(FNewPageBefore).OnChange := OnChangeNewPageBefore;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'GetNewPageBefore <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {PH,PF,Subreport RHb,RFb: some options do not have formulas}
  if ((SectionCode div 1000) = PE_SECT_PAGE_HEADER) or
     ((SectionCode div 1000) = PE_SECT_PAGE_FOOTER) or
     ((SectionCode = 1025) and (Cr.FSubreports.FIndex > 0)) or
     ((SectionCode = 8025) and (Cr.FSubreports.FIndex > 0)) then
      Exit;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetSectionFormatFormula(Cr.FPrintJob, SectionCode,
     PE_FFN_NEW_PAGE_BEFORE, hText, iText) then
  begin
    TStringList(FNewPageBefore).OnChange := OnChangeNewPageBefore;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'GetNewPageBefore <PEGetSectionFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula Text}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FNewPageBefore).OnChange := OnChangeNewPageBefore;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'GetNewPageBefore <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FNewPageBefore.SetText(pText);
  StrDispose(pText);
  Result := FNewPageBefore;
end;
{------------------------------------------------------------------------------}
{ SetNewPageBefore                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.SetNewPageBefore (const Value: TStrings);
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
  sRPT,sVCL   : string;
begin
  FNewPageBefore.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeSectionFormatItem(Parent).FSection, SectionCode) then
  begin
    TStringList(FNewPageBefore).OnChange := OnChangeNewPageBefore;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetNewPageBefore <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {PH,PF,Subreport RHb,RFb: some options do not have formulas}
  if ((SectionCode div 1000) = PE_SECT_PAGE_HEADER) or
     ((SectionCode div 1000) = PE_SECT_PAGE_FOOTER) or
     ((SectionCode = 1025) and (Cr.FSubreports.FIndex > 0)) or
     ((SectionCode = 8025) and (Cr.FSubreports.FIndex > 0)) then
      Exit;

  {Get Formula from Report}
  if not Cr.FCrpeEngine.PEGetSectionFormatFormula(Cr.FPrintJob, SectionCode,
     PE_FFN_NEW_PAGE_BEFORE, hText, iText) then
  begin
    TStringList(FNewPageBefore).OnChange := OnChangeNewPageBefore;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'SetNewPageBefore <PEGetSectionFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula Text}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FNewPageBefore).OnChange := OnChangeNewPageBefore;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'SetNewPageBefore <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sRPT := String(pText);
  StrDispose(pText);

  {Trim off the CR/LF characters}
  sVCL := RTrimList(FNewPageBefore);

  {Compare it to the new Formula}
  if CompareStr(sVCL, sRPT) <> 0 then
  begin
    {Send SectionFormatFormula to Report}
    
    if not Cr.FCrpeEngine.PESetSectionFormatFormula(Cr.FPrintJob, SectionCode,
      PE_FFN_NEW_PAGE_BEFORE, PChar(sVCL)) then
    begin
      TStringList(FNewPageBefore).OnChange := OnChangeNewPageBefore;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetNewPageBefore <PESetSectionFormatFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ OnChangeNewPageBefore                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.OnChangeNewPageBefore (Sender: TObject);
begin
  if Sender is TStringList then
  begin
    TStringList(Sender).OnChange := nil;
    xFormula.Assign(TStringList(Sender));
    SetNewPageBefore(xFormula);
    TStringList(Sender).OnChange := OnChangeNewPageBefore;
  end;
end;
{------------------------------------------------------------------------------}
{ GetNewPageAfter                                                              }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetNewPageAfter : TStrings;
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;


begin
  Result := FNewPageAfter;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeSectionFormatItem(Parent).FSection, SectionCode) then
  begin
    TStringList(FNewPageAfter).OnChange := OnChangeNewPageAfter;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'GetNewPageAfter <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {PH,PF,Subreport RHb,RFb: some options do not have formulas}
  if ((SectionCode div 1000) = PE_SECT_PAGE_HEADER) or
     ((SectionCode div 1000) = PE_SECT_PAGE_FOOTER) or
     ((SectionCode = 1025) and (Cr.FSubreports.FIndex > 0)) or
     ((SectionCode = 8025) and (Cr.FSubreports.FIndex > 0)) then
    Exit;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetSectionFormatFormula(Cr.FPrintJob, SectionCode,
     PE_FFN_NEW_PAGE_AFTER, hText, iText) then
  begin
    TStringList(FNewPageAfter).OnChange := OnChangeNewPageAfter;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'GetNewPageAfter <PEGetSectionFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula Text}
  pText := GlobalLock(hText);
  FNewPageAfter.Text := WideCharToString(PWideChar(pText));
  GlobalUnlock(hText);
  GlobalFree(hText);
  Result := FNewPageAfter;
end;
{------------------------------------------------------------------------------}
{ SetNewPageAfter                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.SetNewPageAfter (const Value: TStrings);
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
  sRPT,sVCL   : string;
begin
  FNewPageAfter.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeSectionFormatItem(Parent).FSection, SectionCode) then
  begin
    TStringList(FNewPageAfter).OnChange := OnChangeNewPageAfter;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetNewPageAfter <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {PH,PF,Subreport RHb,RFb: some options do not have formulas}
  if ((SectionCode div 1000) = PE_SECT_PAGE_HEADER) or
     ((SectionCode div 1000) = PE_SECT_PAGE_FOOTER) or
     ((SectionCode = 1025) and (Cr.FSubreports.FIndex > 0)) or
     ((SectionCode = 8025) and (Cr.FSubreports.FIndex > 0)) then
    Exit;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetSectionFormatFormula(Cr.FPrintJob, SectionCode,
     PE_FFN_NEW_PAGE_AFTER, hText, iText) then
  begin
    TStringList(FNewPageAfter).OnChange := OnChangeNewPageAfter;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'SetNewPageAfter <PEGetSectionFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula Text}
  pText := StrAlloc(hText);
  sRPT := String(pText);
  GlobalUnlock(hText);
  GlobalFree(hText);

  {Compare it to the new Formula}
  sVCL := RTrimList(FNewPageAfter);
  if CompareStr(sVCL, sRPT) <> 0 then
  begin
    {Send SectionFormatFormula to Report}
    
    if not Cr.FCrpeEngine.PESetSectionFormatFormula(Cr.FPrintJob, SectionCode,
      PE_FFN_NEW_PAGE_AFTER, PChar(sVCL)) then
    begin
      TStringList(FNewPageAfter).OnChange := OnChangeNewPageAfter;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetNewPageAfter <PESetSectionFormatFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ OnChangeNewPageAfter                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.OnChangeNewPageAfter (Sender: TObject);
begin
  if Sender is TStringList then
  begin
    TStringList(Sender).OnChange := nil;
    xFormula.Assign(TStringList(Sender));
    SetNewPageAfter(xFormula);
    TStringList(Sender).OnChange := OnChangeNewPageAfter;
  end;
end;
{------------------------------------------------------------------------------}
{ GetKeepTogether                                                              }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetKeepTogether : TStrings;
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;

begin
  Result := FKeepTogether;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeSectionFormatItem(Parent).FSection, SectionCode) then
  begin
    TStringList(FKeepTogether).OnChange := OnChangeKeepTogether;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'GetKeepTogether <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {PH,PF,Subreport RHb,RFb: some options do not have formulas}
  if ((SectionCode div 1000) = PE_SECT_PAGE_HEADER) or
     ((SectionCode div 1000) = PE_SECT_PAGE_FOOTER) or
     ((SectionCode = 1025) and (Cr.FSubreports.FIndex > 0)) or
     ((SectionCode = 8025) and (Cr.FSubreports.FIndex > 0)) then
     Exit;

  {Get Formula from Report}
  if not Cr.FCrpeEngine.PEGetSectionFormatFormula(Cr.FPrintJob, SectionCode,
     PE_FFN_KEEP_SECTION_TOGETHER, hText, iText) then
  begin
    TStringList(FKeepTogether).OnChange := OnChangeKeepTogether;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'GetKeepTogether <PEGetSectionFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula Text}
  pText := GlobalLock(hText);
  FKeepTogether.Text := WideCharToString(PWideChar(pText));
  GlobalUnlock(hText);
  GlobalFree(hText);
  Result := FKeepTogether;
end;
{------------------------------------------------------------------------------}
{ SetKeepTogether                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.SetKeepTogether (const Value: TStrings);
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
  sRPT,sVCL   : string;
begin
  FKeepTogether.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeSectionFormatItem(Parent).FSection, SectionCode) then
  begin
    TStringList(FKeepTogether).OnChange := OnChangeKeepTogether;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetKeepTogether <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {PH,PF,Subreport RHb,RFb: some options do not have formulas}
  if ((SectionCode div 1000) = PE_SECT_PAGE_HEADER) or
     ((SectionCode div 1000) = PE_SECT_PAGE_FOOTER) or
     ((SectionCode = 1025) and (Cr.FSubreports.FIndex > 0)) or
     ((SectionCode = 8025) and (Cr.FSubreports.FIndex > 0)) then
     Exit;

  {Get Formula from Report}
  if not Cr.FCrpeEngine.PEGetSectionFormatFormula(Cr.FPrintJob, SectionCode,
     PE_FFN_KEEP_SECTION_TOGETHER, hText, iText) then
  begin
    TStringList(FKeepTogether).OnChange := OnChangeKeepTogether;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'SetKeepTogether <PEGetSectionFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula Text}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FKeepTogether).OnChange := OnChangeKeepTogether;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'SetKeepTogether <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sRPT := String(pText);
  StrDispose(pText);

  {Compare it to the new Formula}
  sVCL := RTrimList(FKeepTogether);
  if CompareStr(sVCL, sRPT) <> 0 then
  begin
    {Send SectionFormatFormula to Report}
    if not Cr.FCrpeEngine.PESetSectionFormatFormula(Cr.FPrintJob, SectionCode,
      PE_FFN_KEEP_SECTION_TOGETHER, PChar(sVCL)) then
    begin
      TStringList(FKeepTogether).OnChange := OnChangeKeepTogether;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetKeepTogether <PESetSectionFormatFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ OnChangeKeepTogether                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.OnChangeKeepTogether (Sender: TObject);
begin
  if Sender is TStringList then
  begin
    TStringList(Sender).OnChange := nil;
    xFormula.Assign(TStringList(Sender));
    SetKeepTogether(xFormula);
    TStringList(Sender).OnChange := OnChangeKeepTogether;
  end;
end;
{------------------------------------------------------------------------------}
{ GetSuppressBlankSection                                                      }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetSuppressBlankSection : TStrings;
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
begin
  Result := FSuppressBlankSection;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeSectionFormatItem(Parent).FSection, SectionCode) then
  begin
    TStringList(FSuppressBlankSection).OnChange := OnChangeSuppressBlankSection;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'GetSuppressBlankSection <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetSectionFormatFormula(Cr.FPrintJob, SectionCode,
     PE_FFN_SUPPRESS_BLANK_SECTION, hText, iText) then
  begin
    TStringList(FSuppressBlankSection).OnChange := OnChangeSuppressBlankSection;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'GetSuppressBlankSection <PEGetSectionFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula Text}
  pText := GlobalLock(hText);
  FSuppressBlankSection.Text := WideCharToString(PWideChar(pText));
  GlobalUnlock(hText);
  GlobalFree(hText);
  Result := FSuppressBlankSection;
end;
{------------------------------------------------------------------------------}
{ SetSuppressBlankSection                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.SetSuppressBlankSection (const Value: TStrings);
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
  sRPT,sVCL   : string;
begin
  FSuppressBlankSection.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeSectionFormatItem(Parent).FSection, SectionCode) then
  begin
    TStringList(FSuppressBlankSection).OnChange := OnChangeSuppressBlankSection;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetSuppressBlankSection <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetSectionFormatFormula(Cr.FPrintJob, SectionCode,
     PE_FFN_SUPPRESS_BLANK_SECTION, hText, iText) then
  begin
    TStringList(FSuppressBlankSection).OnChange := OnChangeSuppressBlankSection;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'SetSuppressBlankSection <PEGetSectionFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FSuppressBlankSection).OnChange := OnChangeSuppressBlankSection;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'SetSuppressBlankSection <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sRPT := String(pText);
  StrDispose(pText);

  {Compare it to the new Formula}
  sVCL := RTrimList(FSuppressBlankSection);
  if CompareStr(sVCL, sRPT) <> 0 then
  begin
    {Send SectionFormatFormula to Report}
    
    if not Cr.FCrpeEngine.PESetSectionFormatFormula(Cr.FPrintJob, SectionCode,
      PE_FFN_SUPPRESS_BLANK_SECTION, PChar(sVCL)) then
    begin
      TStringList(FSuppressBlankSection).OnChange := OnChangeSuppressBlankSection;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetSuppressBlankSection <PESetSectionFormatFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ OnChangeSuppressBlankSection                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.OnChangeSuppressBlankSection (Sender: TObject);
begin
  if Sender is TStringList then
  begin
    TStringList(Sender).OnChange := nil;
    xFormula.Assign(TStringList(Sender));
    SetSuppressBlankSection(xFormula);
    TStringList(Sender).OnChange := OnChangeSuppressBlankSection;
  end;
end;
{------------------------------------------------------------------------------}
{ GetResetPageNAfter                                                           }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetResetPageNAfter : TStrings;
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
begin
  Result := FResetPageNAfter;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeSectionFormatItem(Parent).FSection, SectionCode) then
  begin
    TStringList(FResetPageNAfter).OnChange := OnChangeResetPageNAfter;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'GetResetPageNAfter <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetSectionFormatFormula(Cr.FPrintJob, SectionCode,
     PE_FFN_RESET_PAGE_N_AFTER, hText, iText) then
  begin
    TStringList(FResetPageNAfter).OnChange := OnChangeResetPageNAfter;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'GetResetPageNAfter <PEGetSectionFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula Text}
  pText := GlobalLock(hText);
  FResetPageNAfter.Text := WideCharToString(PWideChar(pText));
  GlobalUnlock(hText);
  GlobalFree(hText);
  Result := FResetPageNAfter;
end;
{------------------------------------------------------------------------------}
{ SetResetPageNAfter                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.SetResetPageNAfter (const Value: TStrings);
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
  sRPT,sVCL   : string;

begin
  FResetPageNAfter.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeSectionFormatItem(Parent).FSection, SectionCode) then
  begin
    TStringList(FResetPageNAfter).OnChange := OnChangeResetPageNAfter;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetResetPageNAfter <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetSectionFormatFormula(Cr.FPrintJob, SectionCode,
     PE_FFN_RESET_PAGE_N_AFTER, hText, iText) then
  begin
    TStringList(FResetPageNAfter).OnChange := OnChangeResetPageNAfter;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'SetResetPageNAfter <PEGetSectionFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FResetPageNAfter).OnChange := OnChangeResetPageNAfter;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'SetResetPageNAfter <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sRPT := String(pText);
  StrDispose(pText);

  {Compare it to the new Formula}
  sVCL := RTrimList(FResetPageNAfter);
  if CompareStr(sVCL, sRPT) <> 0 then
  begin
    {Send SectionFormatFormula to Report}

    if not Cr.FCrpeEngine.PESetSectionFormatFormula(Cr.FPrintJob, SectionCode,
      PE_FFN_RESET_PAGE_N_AFTER, PChar(sVCL)) then
    begin
      TStringList(FResetPageNAfter).OnChange := OnChangeResetPageNAfter;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetResetPageNAfter <PESetSectionFormatFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ OnChangeResetPageNAfter                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.OnChangeResetPageNAfter (Sender: TObject);
begin
  if Sender is TStringList then
  begin
    TStringList(Sender).OnChange := nil;
    xFormula.Assign(TStringList(Sender));
    SetResetPageNAfter(xFormula);
    TStringList(Sender).OnChange := OnChangeResetPageNAfter;
  end;
end;
{------------------------------------------------------------------------------}
{ GetPrintAtBottomOfPage                                                       }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetPrintAtBottomOfPage : TStrings;
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;

begin
  Result := FPrintAtBottomOfPage;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeSectionFormatItem(Parent).FSection, SectionCode) then
  begin
    TStringList(FPrintAtBottomOfPage).OnChange := OnChangePrintAtBottomOfPage;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'GetPrintAtBottomOfPage <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {PH,PF,Subreport RHb,RFb: some options do not have formulas}
  if ((SectionCode div 1000) = PE_SECT_PAGE_HEADER) or
     ((SectionCode div 1000) = PE_SECT_PAGE_FOOTER) or
     ((SectionCode = 1025) and (Cr.FSubreports.FIndex > 0)) or
     ((SectionCode = 8025) and (Cr.FSubreports.FIndex > 0)) then
     Exit;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetSectionFormatFormula(Cr.FPrintJob, SectionCode,
     PE_FFN_PRINT_AT_BOTTOM_OF_PAGE, hText, iText) then
  begin
    TStringList(FPrintAtBottomOfPage).OnChange := OnChangePrintAtBottomOfPage;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'GetPrintAtBottomOfPage <PEGetSectionFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula Text}
  pText := GlobalLock(hText);
  FPrintAtBottomOfPage.Text := WideCharToString(PWideChar(pText));
  GlobalUnlock(hText);
  GlobalFree(hText);
  Result := FPrintAtBottomOfPage;
end;
{------------------------------------------------------------------------------}
{ SetPrintAtBottomOfPage                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.SetPrintAtBottomOfPage (const Value: TStrings);
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
  sRPT,sVCL   : string;
begin
  FPrintAtBottomOfPage.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeSectionFormatItem(Parent).FSection, SectionCode) then
  begin
    TStringList(FPrintAtBottomOfPage).OnChange := OnChangePrintAtBottomOfPage;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetPrintAtBottomOfPage <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {PH,PF,Subreport RHb,RFb: some options do not have formulas}
  if ((SectionCode div 1000) = PE_SECT_PAGE_HEADER) or
     ((SectionCode div 1000) = PE_SECT_PAGE_FOOTER) or
     ((SectionCode = 1025) and (Cr.FSubreports.FIndex > 0)) or
     ((SectionCode = 8025) and (Cr.FSubreports.FIndex > 0)) then
     Exit;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetSectionFormatFormula(Cr.FPrintJob, SectionCode,
     PE_FFN_PRINT_AT_BOTTOM_OF_PAGE, hText, iText) then
  begin
    TStringList(FPrintAtBottomOfPage).OnChange := OnChangePrintAtBottomOfPage;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'SetPrintAtBottomOfPage <PEGetSectionFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula Text}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FPrintAtBottomOfPage).OnChange := OnChangePrintAtBottomOfPage;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'SetPrintAtBottomOfPage <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sRPT := String(pText);
  StrDispose(pText);

  {Compare it to the new Formula}
  sVCL := RTrimList(FPrintAtBottomOfPage);
  if CompareStr(sVCL, sRPT) <> 0 then
  begin
    {Send SectionFormatFormula to Report}
    
    if not Cr.FCrpeEngine.PESetSectionFormatFormula(Cr.FPrintJob, SectionCode,
      PE_FFN_PRINT_AT_BOTTOM_OF_PAGE, PChar(sVCL)) then
    begin
      TStringList(FPrintAtBottomOfPage).OnChange := OnChangePrintAtBottomOfPage;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetPrintAtBottomOfPage <PESetSectionFormatFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ OnChangePrintAtBottomOfPage                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.OnChangePrintAtBottomOfPage (Sender: TObject);
begin
  if Sender is TStringList then
  begin
    TStringList(Sender).OnChange := nil;
    xFormula.Assign(TStringList(Sender));
    SetPrintAtBottomOfPage(xFormula);
    TStringList(Sender).OnChange := OnChangePrintAtBottomOfPage;
  end;
end;
{------------------------------------------------------------------------------}
{ GetBackgroundColor                                                           }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetBackgroundColor : TStrings;
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
begin
  Result := FBackgroundColor;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeSectionFormatItem(Parent).FSection, SectionCode) then
  begin
    TStringList(FBackgroundColor).OnChange := OnChangeBackgroundColor;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'GetBackgroundColor <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula from Report}
  if not Cr.FCrpeEngine.PEGetSectionFormatFormula(Cr.FPrintJob, SectionCode,
     PE_FFN_SECTION_BACK_COLOUR, hText, iText) then
  begin
    TStringList(FBackgroundColor).OnChange := OnChangeBackgroundColor;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'GetBackgroundColor <PEGetSectionFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula Text}
  pText := GlobalLock(hText);
  FBackgroundColor.Text := WideCharToString(PWideChar(pText));
  GlobalUnlock(hText);
  GlobalFree(hText);
  Result := FBackgroundColor;
end;
{------------------------------------------------------------------------------}
{ SetBackgroundColor                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.SetBackgroundColor (const Value: TStrings);
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
  sRPT,sVCL   : string;

begin
  FBackgroundColor.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeSectionFormatItem(Parent).FSection, SectionCode) then
  begin
    TStringList(FBackgroundColor).OnChange := OnChangeBackgroundColor;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetBackgroundColor <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetSectionFormatFormula(Cr.FPrintJob, SectionCode,
     PE_FFN_SECTION_BACK_COLOUR, hText, iText) then
  begin
    TStringList(FBackgroundColor).OnChange := OnChangeBackgroundColor;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'SetBackgroundColor <PEGetSectionFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FBackgroundColor).OnChange := OnChangeBackgroundColor;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'SetBackgroundColor <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sRPT := String(pText);
  StrDispose(pText);

  {Compare it to the new Formula}
  sVCL := RTrimList(FBackgroundColor);
  if CompareStr(sVCL, sRPT) <> 0 then
  begin
    {Send SectionFormatFormula to Report}

    if not Cr.FCrpeEngine.PESetSectionFormatFormula(Cr.FPrintJob, SectionCode,
      PE_FFN_SECTION_BACK_COLOUR, PChar(sVCL)) then
    begin
      TStringList(FBackgroundColor).OnChange := OnChangeBackgroundColor;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetBackgroundColor <PESetSectionFormatFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ OnChangeBackgroundColor                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.OnChangeBackgroundColor (Sender: TObject);
begin
  if Sender is TStringList then
  begin
    TStringList(Sender).OnChange := nil;
    xFormula.Assign(TStringList(Sender));
    SetBackgroundColor(xFormula);
    TStringList(Sender).OnChange := OnChangeBackgroundColor;
  end;
end;
{------------------------------------------------------------------------------}
{ GetUnderlaySection                                                           }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatFormulas.GetUnderlaySection : TStrings;
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
begin
  Result := FUnderlaySection;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeSectionFormatItem(Parent).FSection, SectionCode) then
  begin
    TStringList(FUnderlaySection).OnChange := OnChangeUnderlaySection;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'GetUnderlaySection <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula from Report}
  if not Cr.FCrpeEngine.PEGetSectionFormatFormula(Cr.FPrintJob, SectionCode,
     PE_FFN_UNDERLAY_SECTION, hText, iText) then
  begin
    TStringList(FUnderlaySection).OnChange := OnChangeUnderlaySection;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'GetUnderlaySection <PEGetSectionFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula Text}
  pText := GlobalLock(hText);
  FUnderlaySection.Text := WideCharToString(PWideChar(pText));
  GlobalUnlock(hText);
  GlobalFree(hText);
  Result := FUnderlaySection;
end;
{------------------------------------------------------------------------------}
{ SetUnderlaySection                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.SetUnderlaySection (const Value: TStrings);
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
  sRPT,sVCL   : string;
begin
  FUnderlaySection.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeSectionFormatItem(Parent).FSection, SectionCode) then
  begin
    TStringList(FUnderlaySection).OnChange := OnChangeUnderlaySection;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetUnderlaySection <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula from Report}
  if not Cr.FCrpeEngine.PEGetSectionFormatFormula(Cr.FPrintJob, SectionCode,
     PE_FFN_UNDERLAY_SECTION, hText, iText) then
  begin
    TStringList(FUnderlaySection).OnChange := OnChangeUnderlaySection;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'SetUnderlaySection <PEGetSectionFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula Text}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FUnderlaySection).OnChange := OnChangeUnderlaySection;
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormatFormulaName,errEngine,'',
       Cr.BuildErrorString(Self) + 'SetUnderlaySection <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sRPT := String(pText);
  StrDispose(pText);

  {Compare it to the new Formula}
  sVCL := RTrimList(FUnderlaySection);
  if CompareStr(sVCL, sRPT) <> 0 then
  begin
    {Send SectionFormatFormula to Report}
    if not Cr.FCrpeEngine.PESetSectionFormatFormula(Cr.FPrintJob, SectionCode,
      PE_FFN_UNDERLAY_SECTION, PChar(sVCL)) then
    begin
      TStringList(FUnderlaySection).OnChange := OnChangeUnderlaySection;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetUnderlaySection <PESetSectionFormatFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ OnChangeUnderlaySection                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatFormulas.OnChangeUnderlaySection (Sender: TObject);
begin
  if Sender is TStringList then
  begin
    TStringList(Sender).OnChange := nil;
    xFormula.Assign(TStringList(Sender));
    SetUnderlaySection(xFormula);
    TStringList(Sender).OnChange := OnChangeUnderlaySection;
  end;
end;


{******************************************************************************}
{ Class TCrpeSectionFormatItem                                                 }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSectionFormatItem.Create;
begin
  inherited Create;
  FSection              := '';
  FSuppress             := False;
  FNewPageBefore        := False;
  FNewPageAfter         := False;
  FKeepTogether         := True;
  FSuppressBlankSection := False;
  FResetPageNAfter      := False;
  FPrintAtBottomOfPage  := False;
  FBackgroundColor      := clNone;
  FUnderlaySection      := False;
  FFreeFormPlacement    := True;
  FFormulas             := TCrpeSectionFormatFormulas.Create;
  FSubClassList.Add(FFormulas);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSectionFormatItem.Destroy;
begin
  FFormulas.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeSectionFormatItem then
  begin
    Section              := TCrpeSectionFormatItem(Source).Section;
    Suppress             := TCrpeSectionFormatItem(Source).Suppress;
    NewPageBefore        := TCrpeSectionFormatItem(Source).NewPageBefore;
    NewPageAfter         := TCrpeSectionFormatItem(Source).NewPageAfter;
    KeepTogether         := TCrpeSectionFormatItem(Source).KeepTogether;
    SuppressBlankSection := TCrpeSectionFormatItem(Source).SuppressBlankSection;
    ResetPageNAfter      := TCrpeSectionFormatItem(Source).ResetPageNAfter;
    PrintAtBottomOfPage  := TCrpeSectionFormatItem(Source).PrintAtBottomOfPage;
    BackgroundColor      := TCrpeSectionFormatItem(Source).BackgroundColor;
    UnderlaySection      := TCrpeSectionFormatItem(Source).UnderlaySection;
    FreeFormPlacement    := TCrpeSectionFormatItem(Source).FreeFormPlacement;
    Formulas.Assign(TCrpeSectionFormatItem(Source).Formulas);
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatItem.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex                := -1;
    FSection              := '';
    FSuppress             := False;
    FNewPageBefore        := False;
    FNewPageAfter         := False;
    FKeepTogether         := True;
    FSuppressBlankSection := False;
    FResetPageNAfter      := False;
    FPrintAtBottomOfPage  := False;
    FBackgroundColor      := clNone;
    FUnderlaySection      := False;
    FFreeFormPlacement    := True;
  end
  else
  begin
    SetSuppress(False);
    SetNewPageBefore(False);
    SetNewPageAfter(False);
    SetKeepTogether(True);
    SetSuppressBlankSection(False);
    SetResetPageNAfter(False);
    SetPrintAtBottomOfPage(False);
    SetBackgroundColor(clNone);
    SetUnderlaySection(False);
    SetFreeFormPlacement(True);
  end;
  FFormulas.Clear;
end;
{------------------------------------------------------------------------------}
{ SetSection                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatItem.SetSection (const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetSuppress                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatItem.SetSuppress (const Value: Boolean);
var
  SecOpt      : PESectionOptions;
  SectionCode : Smallint;
begin
  FSuppress := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert Section Name to Code}
  if not StrToSectionCode(FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetSuppress <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get SectionFormat from Report}
  
  if not Cr.FCrpeEngine.PEGetSectionFormat(Cr.FPrintJob, SectionCode, SecOpt) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetSuppress <PEGetSectionFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Visible}
  if Ord(FSuppress) = SecOpt.visible then
  begin
    SecOpt.visible := Ord(not FSuppress);
    {Send SectionFormat to Report}
    
    if not Cr.FCrpeEngine.PESetSectionFormat(Cr.FPrintJob, SectionCode, SecOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetSuppress <PESetSectionFormat>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetNewPageBefore                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatItem.SetNewPageBefore (const Value: Boolean);
var
  SecOpt      : PESectionOptions;
  SectionCode : Smallint;
begin
  FNewPageBefore := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert Section Name to Code}
  if not StrToSectionCode(FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetNewPageBefore <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get SectionFormat from Report}
  
  if not Cr.FCrpeEngine.PEGetSectionFormat(Cr.FPrintJob, SectionCode, SecOpt) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetNewPageBefore <PEGetSectionFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {NewPageBefore}
  if Ord(FNewPageBefore) <> SecOpt.newPageBefore then
  begin
    SecOpt.newPageBefore := Ord(FNewPageBefore);
    {Send SectionFormat to Report}
    
    if not Cr.FCrpeEngine.PESetSectionFormat(Cr.FPrintJob, SectionCode, SecOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetNewPageBefore <PESetSectionFormat>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetNewPageAfter                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatItem.SetNewPageAfter (const Value: Boolean);
var
  SecOpt      : PESectionOptions;
  SectionCode : Smallint;
begin
  FNewPageAfter := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert Section Name to Code}
  if not StrToSectionCode(FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetNewPageAfter <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get SectionFormat from Report}
  
  if not Cr.FCrpeEngine.PEGetSectionFormat(Cr.FPrintJob, SectionCode, SecOpt) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetNewPageAfter <PEGetSectionFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {NewPageAfter}
  if Ord(FNewPageAfter) <> SecOpt.newPageAfter then
  begin
    SecOpt.newPageAfter := Ord(FNewPageAfter);
    {Send SectionFormat to Report}
    
    if not Cr.FCrpeEngine.PESetSectionFormat(Cr.FPrintJob, SectionCode, SecOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetNewPageAfter <PESetSectionFormat>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetKeepTogether                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatItem.SetKeepTogether (const Value: Boolean);
var
  SecOpt      : PESectionOptions;
  SectionCode : Smallint;
begin
  FKeepTogether := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert Section Name to Code}
  if not StrToSectionCode(FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetKeepTogether <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get SectionFormat from Report}
  
  if not Cr.FCrpeEngine.PEGetSectionFormat(Cr.FPrintJob, SectionCode, SecOpt) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetKeepTogether <PEGetSectionFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {KeepTogether}
  if Ord(FKeepTogether) <> SecOpt.keepTogether then
  begin
    SecOpt.keepTogether := Ord(FKeepTogether);
    {Send SectionFormat to Report}
    
    if not Cr.FCrpeEngine.PESetSectionFormat(Cr.FPrintJob, SectionCode, SecOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetKeepTogether <PESetSectionFormat>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetSuppressBlankSection                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatItem.SetSuppressBlankSection (const Value: Boolean);
var
  SecOpt      : PESectionOptions;
  SectionCode : Smallint;
begin
  FSuppressBlankSection := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert Section Name to Code}
  if not StrToSectionCode(FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetSuppressBlankSection <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get SectionFormat from Report}
  
  if not Cr.FCrpeEngine.PEGetSectionFormat(Cr.FPrintJob, SectionCode, SecOpt) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetSuppressBlankSection <PEGetSectionFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {SuppressBlankSection}
  if Ord(FSuppressBlankSection) <> SecOpt.suppressBlankSection then
  begin
    SecOpt.suppressBlankSection := Ord(FSuppressBlankSection);
    {Send SectionFormat to Report}
    
    if not Cr.FCrpeEngine.PESetSectionFormat(Cr.FPrintJob, SectionCode, SecOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetSuppressBlankSection <PESetSectionFormat>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetResetPageNAfter                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatItem.SetResetPageNAfter (const Value: Boolean);
var
  SecOpt      : PESectionOptions;
  SectionCode : Smallint;
begin
  FResetPageNAfter := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert Section Name to Code}
  if not StrToSectionCode(FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetResetPageNAfter <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get SectionFormat from Report}
  
  if not Cr.FCrpeEngine.PEGetSectionFormat(Cr.FPrintJob, SectionCode, SecOpt) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetResetPageNAfter <PEGetSectionFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {ResetPageNAfter}
  if Ord(FResetPageNAfter) <> SecOpt.resetPageNAfter then
  begin
    SecOpt.resetPageNAfter := Ord(FResetPageNAfter);
    {Send SectionFormat to Report}
    
    if not Cr.FCrpeEngine.PESetSectionFormat(Cr.FPrintJob, SectionCode, SecOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetResetPageNAfter <PESetSectionFormat>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetPrintAtBottomOfPage                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatItem.SetPrintAtBottomOfPage (const Value: Boolean);
var
  SecOpt      : PESectionOptions;
  SectionCode : Smallint;
begin
  FPrintAtBottomOfPage := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert Section Name to Code}
  if not StrToSectionCode(FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetPrintAtBottomOfPage <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get SectionFormat from Report}
  
  if not Cr.FCrpeEngine.PEGetSectionFormat(Cr.FPrintJob, SectionCode, SecOpt) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetPrintAtBottomOfPage <PEGetSectionFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {PrintAtBottomOfPage}
  if Ord(FPrintAtBottomOfPage) <> SecOpt.printAtBottomOfPage then
  begin
    SecOpt.printAtBottomOfPage := Ord(FPrintAtBottomOfPage);
    {Send SectionFormat to Report}
    
    if not Cr.FCrpeEngine.PESetSectionFormat(Cr.FPrintJob, SectionCode, SecOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetPrintAtBottomOfPage <PESetSectionFormat>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetBackgroundColor                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatItem.SetBackgroundColor (const Value: TColor);
var
  SecOpt           : PESectionOptions;
  SectionCode      : Smallint;
  nColor1, nColor2 : TColor;
begin
  FBackgroundColor := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert Section Name to Code}
  if not StrToSectionCode(FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetBackgroundColor <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get SectionFormat from Report}
  
  if not Cr.FCrpeEngine.PEGetSectionFormat(Cr.FPrintJob, SectionCode, SecOpt) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetBackgroundColor <PEGetSectionFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {BackgroundColor}
  if SecOpt.backgroundColor = PE_NO_COLOR then
    nColor1 := clNone
  else
    nColor1 := TColor(SecOpt.backgroundColor);
  nColor2 := FBackgroundColor;
  if nColor1 <> nColor2 then
  begin
    if nColor2 = clNone then
      SecOpt.backgroundColor := PE_NO_COLOR
    else
      SecOpt.backgroundColor := ColorToRGB(nColor2);
    {Send SectionFormat to Report}
    
    if not Cr.FCrpeEngine.PESetSectionFormat(Cr.FPrintJob, SectionCode, SecOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetBackgroundColor <PESetSectionFormat>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetUnderlaySection                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatItem.SetUnderlaySection (const Value: Boolean);
var
  SecOpt      : PESectionOptions;
  SectionCode : Smallint;
begin
  FUnderlaySection := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert Section Name to Code}
  if not StrToSectionCode(FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetUnderlaySection <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get SectionFormat from Report}
  
  if not Cr.FCrpeEngine.PEGetSectionFormat(Cr.FPrintJob, SectionCode, SecOpt) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetUnderlaySection <PEGetSectionFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {UnderlaySection}
  if Ord(FUnderlaySection) <> SecOpt.underlaySection then
  begin
    SecOpt.underlaySection := Ord(FUnderlaySection);
    {Send SectionFormat to Report}
    
    if not Cr.FCrpeEngine.PESetSectionFormat(Cr.FPrintJob, SectionCode, SecOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetUnderlaySection <PESetSectionFormat>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetFreeFormPlacement                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormatItem.SetFreeFormPlacement (const Value: Boolean);
var
  SecOpt      : PESectionOptions;
  SectionCode : Smallint;
begin
  FFreeFormPlacement := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert Section Name to Code}
  if not StrToSectionCode(FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetFreeFormPlacement <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get SectionFormat from Report}
  
  if not Cr.FCrpeEngine.PEGetSectionFormat(Cr.FPrintJob, SectionCode, SecOpt) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetFreeFormPlacement <PEGetSectionFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {FreeFormPlacement}
  if Ord(FFreeFormPlacement) <> SecOpt.freeFormPlacement then
  begin
    SecOpt.freeFormPlacement := Ord(FFreeFormPlacement);
    {Send SectionFormat to Report}
    
    if not Cr.FCrpeEngine.PESetSectionFormat(Cr.FPrintJob, SectionCode, SecOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetFreeFormPlacement <PESetSectionFormat>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SectionAsCode                                                                }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatItem.SectionAsCode : Smallint;
var
  SectionCode : Smallint;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  if not StrToSectionCode(FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SectionAsCode <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := SectionCode;
end;
{------------------------------------------------------------------------------}
{ SectionType                                                                  }
{------------------------------------------------------------------------------}
function TCrpeSectionFormatItem.SectionType : string;
begin
  Result := '';
  if Length(FSection) > 0 then
  begin
    if UpperCase(FSection[1]) = 'D' then
      Result := Copy(FSection,1,1)
    else
      Result := Copy(FSection,1,2);
  end;
end;


{******************************************************************************}
{ Class TCrpeSectionFormat                                                     }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSectionFormat.Create;
begin
  inherited Create;
  FSection := '';
  FItem := TCrpeSectionFormatItem.Create;
  FSubClassList.Add(FItem);
  FSectionNames := TStringList.Create;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSectionFormat.Destroy;
begin
  FItem.Free;
  FSectionNames.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormat.Clear;
var
  i,j : integer;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex   := -1;
    FSection := '';
    FItem.Clear;
  end
  else
  begin
    j := FIndex;
    for i := 0 to Count-1 do
      Items[i].Clear;
    SetIndex(j);
  end;
  FSectionNames.Clear;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeSectionFormat.Count: integer;
var
  slSectionsS : TStringList;
  slSectionsN : TStringList;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {This next block of code is needed to adjust the section codes list if
   a Report has more than 40 sections or 25 groups, which cannot be accessed
   by the Print Engine}
  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;
  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(Cr.FPrintJob, slSectionsN, slSectionsS, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        Cr.BuildErrorString(Self) + 'Count <GetSectionCodes>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := slSectionsS.Count;
  slSectionsN.Free;
  slSectionsS.Free;
end;
{------------------------------------------------------------------------------}
{ IndexOf                                                                      }
{------------------------------------------------------------------------------}
function TCrpeSectionFormat.IndexOf(SectionName: string): integer;
var
  iCurrent : integer;
  cnt      : integer;
begin
  Result := -1;
  {Store current index}
  iCurrent := FIndex;
  {Locate formula name}
  for cnt := 0 to (Count-1) do
  begin
    SetIndex(cnt);
    if CompareText(FSection, SectionName) = 0 then
    begin
      Result := cnt;
      Break;
    end;
  end;
  {Re-set index}
  SetIndex(iCurrent);
end;
{------------------------------------------------------------------------------}
{ ByName                                                                       }
{------------------------------------------------------------------------------}
function TCrpeSectionFormat.ByName (SectionName: string): TCrpeSectionFormatItem;
var
  i : integer;
begin
  Result := FItem;
  i := IndexOf(SectionName);
  if i = -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTIONFORMAT_BY_NAME,
        'SectionFormat.ByName') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := GetItem(i);
end;
{------------------------------------------------------------------------------}
{ Section Names                                                                }
{------------------------------------------------------------------------------}
function TCrpeSectionFormat.Names : TStrings;
var
  slSectionsN : TStringList;
  slSectionsS : TStringList;
begin
  FSectionNames.Clear;
  Result := FSectionNames;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {This next block of code is needed to adjust the section codes list if
   a Report has more than 40 sections or 25 groups, which cannot be accessed
   by the Print Engine}
  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;
  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(Cr.FPrintJob, slSectionsN, slSectionsS, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        Cr.BuildErrorString(Self) + 'GetSectionNames <GetSectionCodes>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FSectionNames.AddStrings(slSectionsS);
  slSectionsN.Free;
  slSectionsS.Free;
  Result := FSectionNames;
end;
{------------------------------------------------------------------------------}
{ SetSection                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormat.SetSection (const Value: string);
var
  nIndex : integer;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Value) or (csLoading in Cr.ComponentState) then
  begin
    FIndex := -1;
    Exit;
  end;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
       'SectionFormat.Section := ' + Value) of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetSectionAsCode                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormat.SetSectionAsCode (const nCode: Smallint);
begin
  SetSection(Cr.SectionCodeToStringEx(nCode, False));
end;
{------------------------------------------------------------------------------}
{ GetSectionAsCode                                                             }
{------------------------------------------------------------------------------}
function TCrpeSectionFormat.GetSectionAsCode : Smallint;
var
  SectionCode : Smallint;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  if not StrToSectionCode(FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SectionAsCode <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := SectionCode;
end;
{------------------------------------------------------------------------------}
{ AreaType                                                                     }
{------------------------------------------------------------------------------}
function TCrpeSectionFormat.AreaType : string;
begin
  Result := '';
  if Length(FSection) > 0 then
  begin
    if UpperCase(FSection[1]) = 'D' then
      Result := Copy(FSection,1,1)
    else
      Result := Copy(FSection,1,2);
  end;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFormat.SetIndex (nIndex: integer);
var
  SecOpt       : PESectionOptions;
  slSectionsN  : TStringList;
  slSectionsS  : TStringList;
  SectionCode  : Smallint;
  s1           : string;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Clear;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;

  {Check that nIndex is in range}
  if nIndex > Count-1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       Cr.BuildErrorString(Self) + 'SetIndex(' + IntToStr(nIndex) + ')') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;
  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(Cr.FPrintJob, slSectionsN, slSectionsS, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
       'SectionFormat.SetIndex(' + IntToStr(nIndex) + ') <GetSectionCodes>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {This part obtains the Section information from a Report.}
  SectionCode := StrToInt(slSectionsN[nIndex]);
  s1 := slSectionsS[nIndex];
  slSectionsN.Free;
  slSectionsS.Free;
  
  if not Cr.FCrpeEngine.PEGetSectionFormat(Cr.FPrintJob, SectionCode, SecOpt) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' + IntToStr(nIndex) +
        ') <PEGetSectionFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);
  {Section}
  FSection := s1;
  FItem.FSection := FSection;
  {Visible}
  case SecOpt.visible of
    0: FItem.FSuppress := True;
    1: FItem.FSuppress := False;
  end;
  {NewPageBefore}
  if SecOpt.newPageBefore in [0..1] then
    FItem.FNewPageBefore := Boolean(SecOpt.newPageBefore);
  {NewPageAfter}
  if SecOpt.newPageAfter in [0..1] then
    FItem.FNewPageAfter := Boolean(SecOpt.newPageAfter);
  {KeepTogether}
  if SecOpt.keepTogether in [0..1] then
    FItem.FKeepTogether := Boolean(SecOpt.keepTogether);
  {SuppressBlankSection}
  if SecOpt.suppressBlankSection in [0..1] then
    FItem.FSuppressBlankSection := Boolean(SecOpt.suppressBlankSection);
  {ResetPageNAfter}
  if SecOpt.resetPageNAfter in [0..1] then
    FItem.FResetPageNAfter := Boolean(SecOpt.resetPageNAfter);
  {PrintAtBottomOfPage}
  if SecOpt.printAtBottomOfPage in [0..1] then
    FItem.FPrintAtBottomOfPage := Boolean(SecOpt.printAtBottomOfPage);
  {UnderlaySection}
  if SecOpt.underlaySection in [0..1] then
    FItem.FUnderlaySection := Boolean(SecOpt.underlaySection);
  {FreeFormPlacement}
  if SecOpt.freeFormPlacement in [0..1] then
    FItem.FFreeFormPlacement := Boolean(SecOpt.freeFormPlacement);
  {BackgroundColor}
  if SecOpt.backgroundColor = PE_NO_COLOR then
    FItem.FBackgroundColor := clNone
  else
    FItem.FBackgroundColor := SecOpt.backgroundColor;
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.SectionFormat[nIndex]                                         }
{------------------------------------------------------------------------------}
function TCrpeSectionFormat.GetItem(nIndex: integer) : TCrpeSectionFormatItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeAreaFormatFormulas                                                }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeAreaFormatFormulas.Create;
begin
  inherited Create;
  FSuppress            := TStringList.Create;
  FHide                := TStringList.Create;
  FNewPageBefore       := TStringList.Create;
  FNewPageAfter        := TStringList.Create;
  FKeepTogether        := TStringList.Create;
  FResetPageNAfter     := TStringList.Create;
  FPrintAtBottomOfPage := TStringList.Create;
  xFormula             := TStringList.Create;
  {Set up OnChange event}
  TStringList(FSuppress).OnChange := OnChangeSuppress;
  TStringList(FHide).OnChange := OnChangeHide;
  TStringList(FNewPageBefore).OnChange := OnChangeNewPageBefore;
  TStringList(FNewPageAfter).OnChange := OnChangeNewPageAfter;
  TStringList(FKeepTogether).OnChange := OnChangeKeepTogether;
  TStringList(FResetPageNAfter).OnChange := OnChangeResetPageNAfter;
  TStringList(FPrintAtBottomOfPage).OnChange := OnChangePrintAtBottomOfPage;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeAreaFormatFormulas.Destroy;
begin
  TStringList(FSuppress).OnChange := nil;
  TStringList(FHide).OnChange := nil;
  TStringList(FNewPageBefore).OnChange := nil;
  TStringList(FNewPageAfter).OnChange := nil;
  TStringList(FKeepTogether).OnChange := nil;
  TStringList(FResetPageNAfter).OnChange := nil;
  TStringList(FPrintAtBottomOfPage).OnChange := nil;
  FSuppress.Free;
  FHide.Free;
  FNewPageBefore.Free;
  FNewPageAfter.Free;
  FKeepTogether.Free;
  FResetPageNAfter.Free;
  FPrintAtBottomOfPage.Free;
  xFormula.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.Assign(Source: TPersistent);
begin
  if Source is TCrpeAreaFormatFormulas then
  begin
    Suppress.Assign(TCrpeAreaFormatFormulas(Source).Suppress);
    Hide.Assign(TCrpeAreaFormatFormulas(Source).Hide);
    NewPageBefore.Assign(TCrpeAreaFormatFormulas(Source).NewPageBefore);
    NewPageAfter.Assign(TCrpeAreaFormatFormulas(Source).NewPageAfter);
    KeepTogether.Assign(TCrpeAreaFormatFormulas(Source).KeepTogether);
    ResetPageNAfter.Assign(TCrpeAreaFormatFormulas(Source).ResetPageNAfter);
    PrintAtBottomOfPage.Assign(TCrpeAreaFormatFormulas(Source).PrintAtBottomOfPage);
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    FSuppress.Clear;
    FHide.Clear;
    FNewPageBefore.Clear;
    FNewPageAfter.Clear;
    FKeepTogether.Clear;
    FResetPageNAfter.Clear;
    FPrintAtBottomOfPage.Clear;
    xFormula.Clear;
  end
  else
  begin
    xFormula.Clear;
    SetSuppress(xFormula);
    SetHide(xFormula);
    SetNewPageBefore(xFormula);
    SetNewPageAfter(xFormula);
    SetKeepTogether(xFormula);
    SetResetPageNAfter(xFormula);
    SetPrintAtBottomOfPage(xFormula);
  end;
end;
{------------------------------------------------------------------------------}
{ GetSuppress                                                                  }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.GetSuppress : TStrings;
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;


begin
  Result := FSuppress;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeAreaFormatItem(Parent).FArea, SectionCode) then
  begin
    TStringList(FSuppress).OnChange := OnChangeSuppress;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'GetSuppress <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormatFormula(Cr.FPrintJob, SectionCode,
    PE_FFN_AREASECTION_VISIBILITY, hText, iText) then
  begin
    TStringList(FSuppress).OnChange := OnChangeSuppress;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'GetSuppress <PEGetAreaFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FSuppress).OnChange := OnChangeSuppress;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'GetSuppress <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FSuppress.SetText(pText);
  StrDispose(pText);
  Result := FSuppress;
end;
{------------------------------------------------------------------------------}
{ SetSuppress                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.SetSuppress (const Value: TStrings);
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
  sRPT,sVCL   : string;


begin
  FSuppress.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeAreaFormatItem(Parent).FArea, SectionCode) then
  begin
    TStringList(FSuppress).OnChange := OnChangeSuppress;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
       Cr.BuildErrorString(Self) + 'SetSuppress <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormatFormula(Cr.FPrintJob, SectionCode,
    PE_FFN_AREASECTION_VISIBILITY, hText, iText) then
  begin
    TStringList(FSuppress).OnChange := OnChangeSuppress;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
       Cr.BuildErrorString(Self) + 'SetSuppress <PEGetAreaFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FSuppress).OnChange := OnChangeSuppress;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
       Cr.BuildErrorString(Self) + 'SetSuppress <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sRPT := String(pText);
  StrDispose(pText);

  {Compare it to the new Formula...If they are the same, do not send}
  sVCL := RTrimList(FSuppress);
  if CompareStr(sVCL, sRPT) <> 0 then
  begin
    {Send AreaFormatFormula to Report}
    
    if not Cr.FCrpeEngine.PESetAreaFormatFormula(Cr.FPrintJob, SectionCode,
      PE_FFN_AREASECTION_VISIBILITY, PChar(sVCL)) then
    begin
      TStringList(FSuppress).OnChange := OnChangeSuppress;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetSuppress <PESetAreaFormatFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ OnChangeSuppress                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.OnChangeSuppress (Sender: TObject);
begin
  if Sender is TStringList then
  begin
    TStringList(Sender).OnChange := nil;
    xFormula.Assign(TStringList(Sender));
    SetSuppress(xFormula);
    TStringList(Sender).OnChange := OnChangeSuppress;
  end;
end;
{------------------------------------------------------------------------------}
{ GetHide                                                                      }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.GetHide : TStrings;
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;


begin
  Result := FHide;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeAreaFormatItem(Parent).FArea, SectionCode) then
  begin
    TStringList(FHide).OnChange := OnChangeHide;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
       Cr.BuildErrorString(Self) + 'GetHide <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Page Header & Footer : some options do not have formulas}
  if ((SectionCode div 1000) = PE_SECT_PAGE_HEADER) or
     ((SectionCode div 1000) = PE_SECT_PAGE_FOOTER) then
    Exit;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormatFormula(Cr.FPrintJob, SectionCode,
    PE_FFN_SHOW_AREA, hText, iText) then
  begin
    TStringList(FHide).OnChange := OnChangeHide;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
       Cr.BuildErrorString(Self) + 'GetHide <PEGetAreaFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FHide).OnChange := OnChangeHide;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
       Cr.BuildErrorString(Self) + 'GetHide <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FHide.SetText(pText);
  StrDispose(pText);
  Result := FHide;
end;
{------------------------------------------------------------------------------}
{ SetHide                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.SetHide (const Value: TStrings);
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
  sRPT,sVCL   : string;


begin
  FHide.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeAreaFormatItem(Parent).FArea, SectionCode) then
  begin
    TStringList(FHide).OnChange := OnChangeHide;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetHide <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Page Header & Footer : some options do not have formulas}
  if ((SectionCode div 1000) = PE_SECT_PAGE_HEADER) or
     ((SectionCode div 1000) = PE_SECT_PAGE_FOOTER) then
    Exit;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormatFormula(Cr.FPrintJob, SectionCode,
    PE_FFN_SHOW_AREA, hText, iText) then
  begin
    TStringList(FHide).OnChange := OnChangeHide;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetHide <PEGetAreaFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FHide).OnChange := OnChangeHide;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetHide <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sRPT := String(pText);
  StrDispose(pText);

  {Compare it to the new Formula...If they are the same, do not send}
  sVCL := RTrimList(FHide);
  if CompareStr(sVCL, sRPT) <> 0 then
  begin
    {Send AreaFormatFormula to Report}
    
    if not Cr.FCrpeEngine.PESetAreaFormatFormula(Cr.FPrintJob, SectionCode,
      PE_FFN_SHOW_AREA, PChar(sVCL)) then
    begin
      TStringList(FHide).OnChange := OnChangeHide;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetHide <PESetAreaFormatFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ OnChangeHide                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.OnChangeHide (Sender: TObject);
begin
  if Sender is TStringList then
  begin
    TStringList(Sender).OnChange := nil;
    xFormula.Assign(TStringList(Sender));
    SetHide(xFormula);
    TStringList(Sender).OnChange := OnChangeHide;
  end;
end;
{------------------------------------------------------------------------------}
{ GetNewPageBefore                                                             }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.GetNewPageBefore : TStrings;
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;

  
begin
  Result := FNewPageBefore;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeAreaFormatItem(Parent).FArea, SectionCode) then
  begin
    TStringList(FNewPageBefore).OnChange := OnChangeNewPageBefore;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'GetNewPageBefore <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Report Header : NewPageBefore does not have a formula}
  if ((SectionCode div 1000) = PE_SECT_REPORT_HEADER) then
    Exit;
  {Page Header & Footer : some options do not have formulas}
  if ((SectionCode div 1000) = PE_SECT_PAGE_HEADER) or
     ((SectionCode div 1000) = PE_SECT_PAGE_FOOTER) then
    Exit;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormatFormula(Cr.FPrintJob, SectionCode,
    PE_FFN_NEW_PAGE_BEFORE, hText, iText) then
  begin
    TStringList(FNewPageBefore).OnChange := OnChangeNewPageBefore;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'GetNewPageBefore <PEGetAreaFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FNewPageBefore).OnChange := OnChangeNewPageBefore;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'GetNewPageBefore <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FNewPageBefore.SetText(pText);
  StrDispose(pText);
  Result := FNewPageBefore;
end;
{------------------------------------------------------------------------------}
{ SetNewPageBefore                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.SetNewPageBefore (const Value: TStrings);
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
  sRPT,sVCL   : string;


begin
  FNewPageBefore.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeAreaFormatItem(Parent).FArea, SectionCode) then
  begin
    TStringList(FNewPageBefore).OnChange := OnChangeNewPageBefore;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetNewPageBefore <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Report Header : NewPageBefore does not have a formula}
  if ((SectionCode div 1000) = PE_SECT_REPORT_HEADER) then
    Exit;
  {Page Header & Footer : some options do not have formulas}
  if ((SectionCode div 1000) = PE_SECT_PAGE_HEADER) or
     ((SectionCode div 1000) = PE_SECT_PAGE_FOOTER) then
    Exit;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormatFormula(Cr.FPrintJob, SectionCode,
    PE_FFN_NEW_PAGE_BEFORE, hText, iText) then
  begin
    TStringList(FNewPageBefore).OnChange := OnChangeNewPageBefore;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetNewPageBefore <PEGetAreaFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FNewPageBefore).OnChange := OnChangeNewPageBefore;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetNewPageBefore <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sRPT := String(pText);
  StrDispose(pText);

  {Compare it to the new Formula...If they are the same, do not send}
  sVCL := RTrimList(FNewPageBefore);
  if CompareStr(sVCL, sRPT) <> 0 then
  begin
    {Send AreaFormatFormula to Report}
    
    if not Cr.FCrpeEngine.PESetAreaFormatFormula(Cr.FPrintJob, SectionCode,
      PE_FFN_NEW_PAGE_BEFORE, PChar(sVCL)) then
    begin
      TStringList(FNewPageBefore).OnChange := OnChangeNewPageBefore;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetNewPageBefore <PESetAreaFormatFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ OnChangeNewPageBefore                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.OnChangeNewPageBefore (Sender: TObject);
begin
  if Sender is TStringList then
  begin
    TStringList(Sender).OnChange := nil;
    xFormula.Assign(TStringList(Sender));
    SetNewPageBefore(xFormula);
    TStringList(Sender).OnChange := OnChangeNewPageBefore;
  end;
end;
{------------------------------------------------------------------------------}
{ GetNewPageAfter                                                              }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.GetNewPageAfter : TStrings;
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
begin
  Result := FNewPageAfter;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeAreaFormatItem(Parent).FArea, SectionCode) then
  begin
    TStringList(FNewPageAfter).OnChange := OnChangeNewPageAfter;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'GetNewPageAfter <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Report Footer : NewPageAfter does not have a formula}
  if ((SectionCode div 1000) = PE_SECT_REPORT_FOOTER) then
    Exit;
  {Page Header & Footer : some options do not have formulas}
  if ((SectionCode div 1000) = PE_SECT_PAGE_HEADER) or
     ((SectionCode div 1000) = PE_SECT_PAGE_FOOTER) then
    Exit;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormatFormula(Cr.FPrintJob, SectionCode,
    PE_FFN_NEW_PAGE_AFTER, hText, iText) then
  begin
    TStringList(FNewPageAfter).OnChange := OnChangeNewPageAfter;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'GetNewPageAfter <PEGetAreaFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FNewPageAfter).OnChange := OnChangeNewPageAfter;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'GetNewPageAfter <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FNewPageAfter.SetText(pText);
  StrDispose(pText);
  Result := FNewPageAfter;
end;
{------------------------------------------------------------------------------}
{ SetNewPageAfter                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.SetNewPageAfter (const Value: TStrings);
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
  sRPT,sVCL   : string;
begin
  FNewPageAfter.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeAreaFormatItem(Parent).FArea, SectionCode) then
  begin
    TStringList(FNewPageAfter).OnChange := OnChangeNewPageAfter;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetNewPageAfter <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Report Footer : NewPageAfter does not have a formula}
  if ((SectionCode div 1000) = PE_SECT_REPORT_FOOTER) then
    Exit;
  {Page Header & Footer : some options do not have formulas}
  if ((SectionCode div 1000) = PE_SECT_PAGE_HEADER) or
     ((SectionCode div 1000) = PE_SECT_PAGE_FOOTER) then
    Exit;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormatFormula(Cr.FPrintJob, SectionCode,
    PE_FFN_NEW_PAGE_AFTER, hText, iText) then
  begin
    TStringList(FNewPageAfter).OnChange := OnChangeNewPageAfter;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetNewPageAfter <PEGetAreaFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FNewPageAfter).OnChange := OnChangeNewPageAfter;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetNewPageAfter <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sRPT := String(pText);
  StrDispose(pText);

  {Compare it to the new Formula...If they are the same, do not send}
  sVCL := RTrimList(FNewPageAfter);
  if CompareStr(sVCL, sRPT) <> 0 then
  begin
    {Send AreaFormatFormula to Report}
    
    if not Cr.FCrpeEngine.PESetAreaFormatFormula(Cr.FPrintJob, SectionCode,
      PE_FFN_NEW_PAGE_AFTER, PChar(sVCL)) then
    begin
      TStringList(FNewPageAfter).OnChange := OnChangeNewPageAfter;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetNewPageAfter <PESetAreaFormatFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ OnChangeNewPageAfter                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.OnChangeNewPageAfter (Sender: TObject);
begin
  if Sender is TStringList then
  begin
    TStringList(Sender).OnChange := nil;
    xFormula.Assign(TStringList(Sender));
    SetNewPageAfter(xFormula);
    TStringList(Sender).OnChange := OnChangeNewPageAfter;
  end;
end;
{------------------------------------------------------------------------------}
{ GetKeepTogether                                                              }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.GetKeepTogether : TStrings;
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;


begin
  Result := FKeepTogether;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeAreaFormatItem(Parent).FArea, SectionCode) then
  begin
    TStringList(FKeepTogether).OnChange := OnChangeKeepTogether;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
       Cr.BuildErrorString(Self) + 'GetKeepTogether <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Page Header & Footer : some options do not have formulas}
  if ((SectionCode div 1000) = PE_SECT_PAGE_HEADER) or
     ((SectionCode div 1000) = PE_SECT_PAGE_FOOTER) then
    Exit;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormatFormula(Cr.FPrintJob, SectionCode,
    PE_FFN_KEEP_SECTION_TOGETHER, hText, iText) then
  begin
    TStringList(FKeepTogether).OnChange := OnChangeKeepTogether;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'GetKeepTogether <PEGetAreaFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FKeepTogether).OnChange := OnChangeKeepTogether;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'GetKeepTogether <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FKeepTogether.SetText(pText);
  StrDispose(pText);
  Result := FKeepTogether;
end;
{------------------------------------------------------------------------------}
{ SetKeepTogether                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.SetKeepTogether (const Value: TStrings);
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
  sRPT,sVCL   : string;

begin
  FKeepTogether.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeAreaFormatItem(Parent).FArea, SectionCode) then
  begin
    TStringList(FKeepTogether).OnChange := OnChangeKeepTogether;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetKeepTogether <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Page Header & Footer : some options do not have formulas}
  if ((SectionCode div 1000) = PE_SECT_PAGE_HEADER) or
     ((SectionCode div 1000) = PE_SECT_PAGE_FOOTER) then
    Exit;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormatFormula(Cr.FPrintJob, SectionCode,
    PE_FFN_KEEP_SECTION_TOGETHER, hText, iText) then
  begin
    TStringList(FKeepTogether).OnChange := OnChangeKeepTogether;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetKeepTogether <PEGetAreaFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FKeepTogether).OnChange := OnChangeKeepTogether;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetKeepTogether <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sRPT := String(pText);
  StrDispose(pText);

  {Compare it to the new Formula...If they are the same, do not send}
  sVCL := RTrimList(FKeepTogether);
  if CompareStr(sVCL, sRPT) <> 0 then
  begin
    {Send AreaFormatFormula to Report}
    
    if not Cr.FCrpeEngine.PESetAreaFormatFormula(Cr.FPrintJob, SectionCode,
      PE_FFN_KEEP_SECTION_TOGETHER, PChar(sVCL)) then
    begin
      TStringList(FKeepTogether).OnChange := OnChangeKeepTogether;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetKeepTogether <PESetAreaFormatFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ OnChangeKeepTogether                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.OnChangeKeepTogether (Sender: TObject);
begin
  if Sender is TStringList then
  begin
    TStringList(Sender).OnChange := nil;
    xFormula.Assign(TStringList(Sender));
    SetKeepTogether(xFormula);
    TStringList(Sender).OnChange := OnChangeKeepTogether;
  end;
end;
{------------------------------------------------------------------------------}
{ GetResetPageNAfter                                                           }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.GetResetPageNAfter : TStrings;
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
begin
  Result := FResetPageNAfter;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeAreaFormatItem(Parent).FArea, SectionCode) then
  begin
    TStringList(FResetPageNAfter).OnChange := OnChangeResetPageNAfter;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'GetResetPageNAfter <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormatFormula(Cr.FPrintJob, SectionCode,
    PE_FFN_RESET_PAGE_N_AFTER, hText, iText) then
  begin
    TStringList(FResetPageNAfter).OnChange := OnChangeResetPageNAfter;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'GetResetPageNAfter <PEGetAreaFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FResetPageNAfter).OnChange := OnChangeResetPageNAfter;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'GetResetPageNAfter <PEGetAreaFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FResetPageNAfter.SetText(pText);
  StrDispose(pText);
  Result := FResetPageNAfter;
end;
{------------------------------------------------------------------------------}
{ SetResetPageNAfter                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.SetResetPageNAfter (const Value: TStrings);
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
  sRPT,sVCL   : string;
begin
  FResetPageNAfter.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeAreaFormatItem(Parent).FArea, SectionCode) then
  begin
    TStringList(FResetPageNAfter).OnChange := OnChangeResetPageNAfter;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetResetPageNAfter <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormatFormula(Cr.FPrintJob, SectionCode,
    PE_FFN_RESET_PAGE_N_AFTER, hText, iText) then
  begin
    TStringList(FResetPageNAfter).OnChange := OnChangeResetPageNAfter;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetResetPageNAfter <PEGetAreaFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FResetPageNAfter).OnChange := OnChangeResetPageNAfter;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetResetPageNAfter <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sRPT := String(pText);
  StrDispose(pText);

  {Compare it to the new Formula...If they are the same, do not send}
  sVCL := RTrimList(FResetPageNAfter);
  if CompareStr(sVCL, sRPT) <> 0 then
  begin
    {Send AreaFormatFormula to Report}
    
    if not Cr.FCrpeEngine.PESetAreaFormatFormula(Cr.FPrintJob, SectionCode,
      PE_FFN_RESET_PAGE_N_AFTER, PChar(sVCL)) then
    begin
      TStringList(FResetPageNAfter).OnChange := OnChangeResetPageNAfter;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetResetPageNAfter <PESetAreaFormatFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ OnChangeResetPageNAfter                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.OnChangeResetPageNAfter (Sender: TObject);
begin
  if Sender is TStringList then
  begin
    TStringList(Sender).OnChange := nil;
    xFormula.Assign(TStringList(Sender));
    SetResetPageNAfter(xFormula);
    TStringList(Sender).OnChange := OnChangeResetPageNAfter;
  end;
end;
{------------------------------------------------------------------------------}
{ GetPrintAtBottomOfPage                                                       }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatFormulas.GetPrintAtBottomOfPage : TStrings;
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
begin
  Result := FPrintAtBottomOfPage;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeAreaFormatItem(Parent).FArea, SectionCode) then
  begin
    TStringList(FPrintAtBottomOfPage).OnChange := OnChangePrintAtBottomOfPage;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'GetPrintAtBottomOfPage <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through Formulas}
  {Page Header & Footer : some options do not have formulas}
  if ((SectionCode div 1000) = PE_SECT_PAGE_HEADER) or
     ((SectionCode div 1000) = PE_SECT_PAGE_FOOTER) then
     Exit;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormatFormula(Cr.FPrintJob, SectionCode,
    PE_FFN_PRINT_AT_BOTTOM_OF_PAGE, hText, iText) then
  begin
    TStringList(FPrintAtBottomOfPage).OnChange := OnChangePrintAtBottomOfPage;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'GetPrintAtBottomOfPage <PEGetAreaFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FPrintAtBottomOfPage).OnChange := OnChangePrintAtBottomOfPage;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'GetPrintAtBottomOfPage <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FPrintAtBottomOfPage.SetText(pText);
  StrDispose(pText);
  Result := FPrintAtBottomOfPage;
end;
{------------------------------------------------------------------------------}
{ SetPrintAtBottomOfPage                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.SetPrintAtBottomOfPage (const Value: TStrings);
var
  SectionCode : Smallint;
  hText       : HWnd;
  iText       : Smallint;
  pText       : PChar;
  sRPT,sVCL   : string;
begin
  FPrintAtBottomOfPage.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeAreaFormatItem(Parent).FArea, SectionCode) then
  begin
    TStringList(FPrintAtBottomOfPage).OnChange := OnChangePrintAtBottomOfPage;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetPrintAtBottomOfPage <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through Formulas}
  {Page Header & Footer : some options do not have formulas}
  if ((SectionCode div 1000) = PE_SECT_PAGE_HEADER) or
     ((SectionCode div 1000) = PE_SECT_PAGE_FOOTER) then
     Exit;

  {Get Formula from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormatFormula(Cr.FPrintJob, SectionCode,
    PE_FFN_PRINT_AT_BOTTOM_OF_PAGE, hText, iText) then
  begin
    TStringList(FPrintAtBottomOfPage).OnChange := OnChangePrintAtBottomOfPage;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetPrintAtBottomOfPage <PEGetAreaFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Formula}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FPrintAtBottomOfPage).OnChange := OnChangePrintAtBottomOfPage;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetPrintAtBottomOfPage <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sRPT  := String(pText);
  StrDispose(pText);

  {Compare it to the new Formula...If they are the same, do not send}
  sVCL := RTrimList(FPrintAtBottomOfPage);
  if CompareStr(sVCL, sRPT) <> 0 then
  begin
    {Send AreaFormatFormula to Report}
    
    if not Cr.FCrpeEngine.PESetAreaFormatFormula(Cr.FPrintJob, SectionCode,
      PE_FFN_PRINT_AT_BOTTOM_OF_PAGE, PChar(sVCL)) then
    begin
      TStringList(FPrintAtBottomOfPage).OnChange := OnChangePrintAtBottomOfPage;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetPrintAtBottomOfPage <PESetAreaFormatFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ OnChangePrintAtBottomOfPage                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatFormulas.OnChangePrintAtBottomOfPage (Sender: TObject);
begin
  if Sender is TStringList then
  begin
    TStringList(Sender).OnChange := nil;
    xFormula.Assign(TStringList(Sender));
    SetPrintAtBottomOfPage(xFormula);
    TStringList(Sender).OnChange := OnChangePrintAtBottomOfPage;
  end;
end;


{******************************************************************************}
{ Class TCrpeAreaFormatItem                                                    }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeAreaFormatItem.Create;
begin
  inherited Create;
  FArea                := '';
  FHide                := False;
  FNewPageBefore       := False;
  FNewPageAfter        := False;
  FKeepTogether        := False;
  FResetPageNAfter     := False;
  FPrintAtBottomOfPage := False;
  FSuppress            := False;
  FReserveMinimumPageFooter := False;
  FFormulas            := TCrpeAreaFormatFormulas.Create;
  FSubClassList.Add(FFormulas);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeAreaFormatItem.Destroy;
begin
  FFormulas.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeAreaFormatItem then
  begin
    Hide                := TCrpeAreaFormatItem(Source).Hide;
    NewPageBefore       := TCrpeAreaFormatItem(Source).NewPageBefore;
    NewPageAfter        := TCrpeAreaFormatItem(Source).NewPageAfter;
    KeepTogether        := TCrpeAreaFormatItem(Source).KeepTogether;
    ResetPageNAfter     := TCrpeAreaFormatItem(Source).ResetPageNAfter;
    PrintAtBottomOfPage := TCrpeAreaFormatItem(Source).PrintAtBottomOfPage;
    Suppress            := TCrpeAreaFormatItem(Source).Suppress;
    ReserveMinimumPageFooter := TCrpeAreaFormatItem(Source).ReserveMinimumPageFooter;
    Formulas.Assign(TCrpeAreaFormatItem(Source).Formulas);
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatItem.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex               := -1;
    FArea                := '';
    FHide                := False;
    FNewPageBefore       := False;
    FNewPageAfter        := False;
    FKeepTogether        := False;
    FResetPageNAfter     := False;
    FPrintAtBottomOfPage := False;
    FSuppress            := False;
    FReserveMinimumPageFooter := False;
  end
  else
  begin
    SetHide(False);
    SetNewPageBefore(False);
    SetNewPageAfter(False);
    SetKeepTogether(False);
    SetResetPageNAfter(False);
    SetPrintAtBottomOfPage(False);
    SetSuppress(False);
    SetReserveMinimumPageFooter(False);
  end;
  FFormulas.Clear;
end;
{------------------------------------------------------------------------------}
{ SetSection                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatItem.SetArea (const Value: TCrLookupString);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetHide                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatItem.SetHide (const Value: Boolean);
var
  SecOpt      : PESectionOptions;
  SectionCode : Smallint;
begin
  FHide := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(FArea, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
      'AreaFormat[' + IntToStr(FIndex) + '].SetHide <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get AreaFormat settings from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormat(Cr.FPrintJob, SectionCode, SecOpt) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'AreaFormat[' + IntToStr(FIndex) + '].SetHide <PEGetAreaFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {ShowArea}
  {translate "Hide" to "showArea" by inverting}
  if Ord(FHide) = SecOpt.showArea then
  begin
    SecOpt.showArea := Ord(not FHide);
    {Send AreaFormat to Report}
    
    if not Cr.FCrpeEngine.PESetAreaFormat(Cr.FPrintJob, SectionCode, SecOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'AreaFormat[' + IntToStr(FIndex) + '].SetHide <PESetAreaFormat>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetNewPageBefore                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatItem.SetNewPageBefore (const Value: Boolean);
var
  SecOpt      : PESectionOptions;
  SectionCode : Smallint;
begin
  FNewPageBefore := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(FArea, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
      'AreaFormat[' + IntToStr(FIndex) + '].SetNewPageBefore <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get AreaFormat settings from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormat(Cr.FPrintJob, SectionCode, SecOpt) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      'AreaFormat[' + IntToStr(FIndex) + '].SetNewPageBefore <PEGetAreaFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {NewPageBefore}
  if Ord(FNewPageBefore) <> SecOpt.newPageBefore then
  begin
    SecOpt.newPageBefore := Ord(FNewPageBefore);
    {Send AreaFormat to Report}
    
    if not Cr.FCrpeEngine.PESetAreaFormat(Cr.FPrintJob, SectionCode, SecOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'AreaFormat[' + IntToStr(FIndex) + '].SetNewPageBefore <PESetAreaFormat>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetNewPageAfter                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatItem.SetNewPageAfter (const Value: Boolean);
var
  SecOpt      : PESectionOptions;
  SectionCode : Smallint;
begin
  FNewPageAfter := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(FArea, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
      'AreaFormat[' + IntToStr(FIndex) + '].SetNewPageAfter <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get AreaFormat settings from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormat(Cr.FPrintJob, SectionCode, SecOpt) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      'AreaFormat[' + IntToStr(FIndex) + '].SetNewPageAfter <PEGetAreaFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {NewPageAfter}
  if Ord(FNewPageAfter) <> SecOpt.newPageAfter then
  begin
    SecOpt.newPageAfter := Ord(FNewPageAfter);
    {Send AreaFormat to Report}
    
    if not Cr.FCrpeEngine.PESetAreaFormat(Cr.FPrintJob, SectionCode, SecOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'AreaFormat[' + IntToStr(FIndex) + '].SetNewPageAfter <PESetAreaFormat>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetKeepTogether                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatItem.SetKeepTogether (const Value: Boolean);
var
  SecOpt      : PESectionOptions;
  SectionCode : Smallint;
begin
  FKeepTogether := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(FArea, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
      'AreaFormat[' + IntToStr(FIndex) + '].SetKeepTogether <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get AreaFormat settings from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormat(Cr.FPrintJob, SectionCode, SecOpt) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      'AreaFormat[' + IntToStr(FIndex) + '].SetKeepTogether <PEGetAreaFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {KeepTogether}
  if Ord(FKeepTogether) <> SecOpt.keepTogether then
  begin
    SecOpt.keepTogether := Ord(FKeepTogether);
    {Send AreaFormat to Report}
    
    if not Cr.FCrpeEngine.PESetAreaFormat(Cr.FPrintJob, SectionCode, SecOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'AreaFormat[' + IntToStr(FIndex) + '].SetKeepTogether <PESetAreaFormat>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetResetPageNAfter                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatItem.SetResetPageNAfter (const Value: Boolean);
var
  SecOpt      : PESectionOptions;
  SectionCode : Smallint;
begin
  FResetPageNAfter := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(FArea, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
      'AreaFormat[' + IntToStr(FIndex) + '].SetResetPageNAfter <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get AreaFormat settings from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormat(Cr.FPrintJob, SectionCode, SecOpt) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      'AreaFormat[' + IntToStr(FIndex) + '].SetResetPageNAfter <PEGetAreaFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {ResetPageNAfter}
  if Ord(FResetPageNAfter) <> SecOpt.resetPageNAfter then
  begin
    SecOpt.resetPageNAfter := Ord(FResetPageNAfter);
    {Send AreaFormat to Report}
    
    if not Cr.FCrpeEngine.PESetAreaFormat(Cr.FPrintJob, SectionCode, SecOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'AreaFormat[' + IntToStr(FIndex) + '].SetResetPageNAfter <PESetAreaFormat>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetPrintAtBottomOfPage                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatItem.SetPrintAtBottomOfPage (const Value: Boolean);
var
  SecOpt      : PESectionOptions;
  SectionCode : Smallint;
begin
  FPrintAtBottomOfPage := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(FArea, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
      'AreaFormat[' + IntToStr(FIndex) + '].SetPrintAtBottomOfPage <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get AreaFormat settings from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormat(Cr.FPrintJob, SectionCode, SecOpt) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      'AreaFormat[' + IntToStr(FIndex) + '].SetPrintAtBottomOfPage <PEGetAreaFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {PrintAtBottomOfPage}
  if Ord(FPrintAtBottomOfPage) <> SecOpt.printAtBottomOfPage then
  begin
    SecOpt.printAtBottomOfPage := Ord(FPrintAtBottomOfPage);
    {Send AreaFormat to Report}
    
    if not Cr.FCrpeEngine.PESetAreaFormat(Cr.FPrintJob, SectionCode, SecOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'AreaFormat[' + IntToStr(FIndex) + '].SetPrintAtBottomOfPage <PESetAreaFormat>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetSuppress                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatItem.SetSuppress (const Value: Boolean);
var
  SecOpt      : PESectionOptions;
  SectionCode : Smallint;
begin
  FSuppress := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(FArea, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
      'AreaFormat[' + IntToStr(FIndex) + '].SetSuppress <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get AreaFormat settings from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormat(Cr.FPrintJob, SectionCode, SecOpt) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      'AreaFormat[' + IntToStr(FIndex) + '].SetSuppress <PEGetAreaFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Visible}
  if Ord(FSuppress) = SecOpt.visible then
  begin
    SecOpt.visible := Ord(not FSuppress);
    {Send AreaFormat to Report}
    
    if not Cr.FCrpeEngine.PESetAreaFormat(Cr.FPrintJob, SectionCode, SecOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'AreaFormat[' + IntToStr(FIndex) + '].SetSuppress <PESetAreaFormat>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetNSections                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatItem.SetNSections (const Value: Smallint);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetReserveMinimumPageFooter                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormatItem.SetReserveMinimumPageFooter (const Value: Boolean);
var
  SecOpt      : PESectionOptions;
  SectionCode : Smallint;
begin
  FReserveMinimumPageFooter := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(FArea, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
       'AreaFormat[' + IntToStr(FIndex) +
       '].SetReserveMinimumPageFooter <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get AreaFormat settings from Report}
  
  if not Cr.FCrpeEngine.PEGetAreaFormat(Cr.FPrintJob, SectionCode, SecOpt) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'AreaFormat[' + IntToStr(FIndex) +
        '].SetReserveMinimumPageFooter <PEGetAreaFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {ReserveMinimumPageFooter}
  if Ord(FReserveMinimumPageFooter) <> SecOpt.reserveMinimumPageFooter then
  begin
    SecOpt.reserveMinimumPageFooter := Ord(FReserveMinimumPageFooter);
    {Send AreaFormat to Report}
    
    if not Cr.FCrpeEngine.PESetAreaFormat(Cr.FPrintJob, SectionCode, SecOpt) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'AreaFormat[' + IntToStr(FIndex) +
          '].SetReserveMinimumPageFooter <PESetAreaFormat>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SectionAsCode                                                                }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatItem.AreaAsCode : Smallint;
var
  AreaCode : Smallint;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  if not StrToSectionCode(FArea, AreaCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'AreaAsCode <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := AreaCode;
end;
{------------------------------------------------------------------------------}
{ SectionType                                                                  }
{------------------------------------------------------------------------------}
function TCrpeAreaFormatItem.AreaType : string;
begin
  Result := '';
  if Length(FArea) > 0 then
  begin
    if UpperCase(FArea[1]) = 'D' then
      Result := Copy(FArea,1,1)
    else
      Result := Copy(FArea,1,2);
  end;
end;


{******************************************************************************}
{ Class TCrpeAreaFormat                                                        }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeAreaFormat.Create;
begin
  inherited Create;
  FArea     := '';
  FAreas    := TStringList.Create;
  FItem        := TCrpeAreaFormatItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeAreaFormat.Destroy;
begin
  FAreas.Free;
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormat.Clear;
var
  i,j : integer;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    FArea  := '';
    FAreas.Clear;
    FItem.Clear;
  end
  else
  begin
    j := FIndex;
    for i := 0 to Count-1 do
      Items[i].Clear;
    SetIndex(j);
  end;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeAreaFormat.Count: integer;
var
  slSectionsN,
  slSectionsS : TStringList;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;
  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(Cr.FPrintJob, slSectionsN, slSectionsS, True) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_GET_SECTIONS,
       'AreaFormat.Count <GetSectionCodes>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := slSectionsN.Count;
  slSectionsN.Free;
  slSectionsS.Free;
end;
{------------------------------------------------------------------------------}
{ IndexOf                                                                      }
{------------------------------------------------------------------------------}
function TCrpeAreaFormat.IndexOf(AreaName: string): integer;
var
  iCurrent : integer;
  cnt      : integer;
begin
  Result := -1;
  {Store current index}
  iCurrent := FIndex;
  {Locate formula name}
  for cnt := 0 to (Count-1) do
  begin
    SetIndex(cnt);
    if CompareText(FArea, AreaName) = 0 then
    begin
      Result := cnt;
      Break;
    end;
  end;
  {Re-set index}
  SetIndex(iCurrent);
end;
{------------------------------------------------------------------------------}
{ ByName                                                                       }
{------------------------------------------------------------------------------}
function TCrpeAreaFormat.ByName (AreaName: string): TCrpeAreaFormatItem;
var
  i : integer;
begin
  Result := FItem;
  i := IndexOf(AreaName);
  if i = -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_AREAFORMAT_BY_NAME,
        'AreaFormat.ByName') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := GetItem(i);
end;
{------------------------------------------------------------------------------}
{ SetArea                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormat.SetArea (const Value: TCrLookupString);
var
  nIndex : integer;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Value) or (csLoading in Cr.ComponentState) then
  begin
    FIndex := -1;
    Exit;
  end;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
       'AreaFormat.Area := ' + Value) of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{  Names                                                                       }
{  - returns a list of Area Names.  Faster than looping through items.         }
{------------------------------------------------------------------------------}
function TCrpeAreaFormat.Names : TStrings;
var
  slSectionsN : TStringList;
  slSectionsS : TStringList;
begin
  FAreas.Clear;
  Result := FAreas;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;
  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(Cr.FPrintJob, slSectionsN, slSectionsS, True) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_GET_SECTIONS,
       'AreaFormat.GetSections <GetSectionCodes>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FAreas.AddStrings(slSectionsS);
  slSectionsN.Free;
  slSectionsS.Free;
  Result := FAreas;
end;
{------------------------------------------------------------------------------}
{ GetAreaAsCode                                                                }
{------------------------------------------------------------------------------}
function TCrpeAreaFormat.GetAreaAsCode: Smallint;
var
  AreaCode : Smallint;
begin
  StrToSectionCode(FArea, AreaCode);
  Result := AreaCode;
end;
{------------------------------------------------------------------------------}
{ SetAreaAsCode                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormat.SetAreaAsCode (const nArea: Smallint);
begin
  SetArea(Cr.SectionCodeToStringEx(nArea, True));
end;
{------------------------------------------------------------------------------}
{ AreaType                                                                     }
{------------------------------------------------------------------------------}
function TCrpeAreaFormat.AreaType : string;
begin
  Result := '';
  if Length(FArea) > 0 then
  begin
    if UpperCase(FArea[1]) = 'D' then
      Result := Copy(FArea,1,1)
    else
      Result := Copy(FArea,1,2);
  end;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeAreaFormat.SetIndex (nIndex: integer);
var
  SecOpt      : PESectionOptions;
  slSectionsN : TStringList;
  slSectionsS : TStringList;
  SectionCode : Smallint;
  nSections   : Smallint;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Clear;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;

  {Check that nIndex is in range}
  if nIndex > Count-1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
      'AreaFormat[' + IntToStr(nIndex) + '].SetIndex') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;
  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(Cr.FPrintJob, slSectionsN, slSectionsS, True) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_GET_SECTIONS,
       'AreaFormat.SetIndex <GetSectionCodes>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {This part obtains the Section information from a Report.}
  SectionCode := StrToInt(slSectionsN[nIndex]);
  
  if not Cr.FCrpeEngine.PEGetAreaFormat(Cr.FPrintJob, SectionCode, SecOpt) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'AreaFormat.SetIndex <PEGetAreaFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  PropagateIndex(nIndex);
  {Section}
  FArea := slSectionsS[nIndex];
  FItem.FArea := slSectionsS[nIndex];
  {Visible}
  case SecOpt.visible of
    0: FItem.FSuppress := True;
    1: FItem.FSuppress := False;
  end;
  {NewPageBefore}
  case SecOpt.newPageBefore of
    0 : FItem.FNewPageBefore := False;
    1 : FItem.FNewPageBefore := True;
    else
      FItem.FNewPageBefore := False;
  end;
  {NewPageAfter}
  case SecOpt.newPageAfter of
    0 : FItem.FNewPageAfter := False;
    1 : FItem.FNewPageAfter := True;
    else
      FItem.FNewPageAfter := False;
  end;
  {KeepTogether}
  case SecOpt.keepTogether of
    0 : FItem.FKeepTogether := False;
    1 : FItem.FKeepTogether := True;
    else
      FItem.FKeepTogether := False;
  end;
  {ResetPageNAfter}
  case SecOpt.resetPageNAfter of
    0 : FItem.FResetPageNAfter := False;
    1 : FItem.FResetPageNAfter := True;
    else
      FItem.FResetPageNAfter := False;
  end;
  {PrintAtBottomOfPage}
  case SecOpt.printAtBottomOfPage of
    0 : FItem.FPrintAtBottomOfPage := False;
    1 : FItem.FPrintAtBottomOfPage := True;
    else
      FItem.FPrintAtBottomOfPage := False;
  end;
  {ShowArea}
  case SecOpt.showArea of
    0 : FItem.FHide := True;
    1 : FItem.FHide := False;
    else
      FItem.FHide := False;
  end;
  {ReserveMinimumPageFooter}
  case SecOpt.reserveMinimumPageFooter of
    0 : FItem.FReserveMinimumPageFooter := False;
    1 : FItem.FReserveMinimumPageFooter := True;
    else
      FItem.FReserveMinimumPageFooter := False;
  end;
  slSectionsN.Free;
  slSectionsS.Free;

  {NSections}
  nSections := Cr.FCrpeEngine.PEGetNSectionsInArea(Cr.FPrintJob, SectionCode);
  if nSections = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'AreaFormat.SetIndex <PEGetNSectionsInArea>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FItem.FNSections := nSections;
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.AreaFormat[nIndex]                                            }
{------------------------------------------------------------------------------}
function TCrpeAreaFormat.GetItem(nIndex: integer) : TCrpeAreaFormatItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeSectionFontItem                                                   }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSectionFontItem.Create;
begin
  inherited Create;
  FSection       := '';
  FScope         := fsBoth;
  FName          := '';
  FPitch         := fpDefault;
  FFamily        := ffDefault;
  FCharSet       := fcDefault;
  FSize          := 0;
  FItalic        := cDefault;
  FUnderlined    := cDefault;
  FStrikeThrough := cDefault;
  FWeight        := fwDefault;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFontItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeSectionFontItem then
  begin
    Section       := TCrpeSectionFontItem(Source).Section;
    Scope         := TCrpeSectionFontItem(Source).Scope;
    Name          := TCrpeSectionFontItem(Source).Name;
    Pitch         := TCrpeSectionFontItem(Source).Pitch;
    Family        := TCrpeSectionFontItem(Source).Family;
    CharSet       := TCrpeSectionFontItem(Source).CharSet;
    Size          := TCrpeSectionFontItem(Source).Size;
    Italic        := TCrpeSectionFontItem(Source).Italic;
    Underlined    := TCrpeSectionFontItem(Source).Underlined;
    StrikeThrough := TCrpeSectionFontItem(Source).StrikeThrough;
    Weight        := TCrpeSectionFontItem(Source).Weight;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFontItem.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex         := -1;
    FSection       := '';
    FScope         := fsBoth;
    FName          := '';
    FPitch         := fpDefault;
    FFamily        := ffDefault;
    FCharSet       := fcDefault;
    FSize          := 0;
    FItalic        := cDefault;
    FUnderlined    := cDefault;
    FStrikeThrough := cDefault;
    FWeight        := fwDefault;
  end
  else
  begin
    SetScope(fsBoth);
    SetName('');
    SetPitch(fpDefault);
    SetFamily(ffDefault);
    SetCharSet(fcDefault);
    SetSize(0);
    SetItalic(cDefault);
    SetUnderlined(cDefault);
    SetStrikeThrough(cDefault);
    SetWeight(fwDefault);
  end;
end;
{------------------------------------------------------------------------------}
{ Send                                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFontItem.Send;
var
  SectionCode    : Smallint;
  nScope         : Smallint;
  sFont          : string;
  nFamily        : Smallint;
  nPitch         : Smallint;
  nCharSet       : Smallint;
  nSize          : Smallint;
  nItalic        : Smallint;
  nUnderlined    : Smallint;
  nStrikeThrough : Smallint;
  nWeight        : Smallint;
  Changed        : Boolean;
begin
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'Send <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Scope}
  nScope := PE_FIELDS or PE_TEXT;
  case FScope of
    fsFields : nScope := PE_FIELDS;
    fsText   : nScope := PE_TEXT;
    fsBoth   : nScope := PE_FIELDS or PE_TEXT;
  end;
  {Name}
  sFont := FName;
  {Family}
  nFamily := FF_DONTCARE;
  case FFamily of
    ffDefault : nFamily := FF_DONTCARE;
    ffRoman   : nFamily := FF_ROMAN;
    ffSwiss   : nFamily := FF_SWISS;
    ffModern  : nFamily := FF_MODERN;
    ffScript  : nFamily := FF_SCRIPT;
    ffDecorative : nFamily := FF_DECORATIVE;
  end;
  {Pitch}
  nPitch := DEFAULT_PITCH;
  case FPitch of
    fpDefault  : nPitch := DEFAULT_PITCH;
    fpVariable : nPitch := VARIABLE_PITCH;
    fpFixed    : nPitch := FIXED_PITCH;
  end;
  {CharSet}
  nCharSet := DEFAULT_CHARSET;
  case FCharSet of
    fcAnsi        : nCharSet := ANSI_CHARSET;
    fcDefault     : nCharSet := DEFAULT_CHARSET;
    fcSymbol      : nCharSet := SYMBOL_CHARSET;
    fcShiftJis    : nCharSet := SHIFTJIS_CHARSET;
    fcHangeul     : nCharSet := HANGEUL_CHARSET;
    fcChineseBig5 : nCharSet := CHINESEBIG5_CHARSET;
    fcOEM         : nCharSet := OEM_CHARSET;
  end;
  {Size}
  nSize := FSize;
  {Italic}
  nItalic := PE_UNCHANGED;
  case FItalic of
    cFalse   : nItalic := 0;
    cTrue    : nItalic := 1;
    cDefault : nItalic := PE_UNCHANGED;
  end;
  {Underlined}
  nUnderlined := PE_UNCHANGED;
  case FUnderlined of
    cFalse   : nUnderlined := 0;
    cTrue    : nUnderlined := 1;
    cDefault : nUnderlined := PE_UNCHANGED;
  end;
  {StrikeThrough}
  nStrikeThrough := PE_UNCHANGED;
  case FStrikeThrough of
    cFalse   : nStrikeThrough := 0;
    cTrue    : nStrikeThrough := 1;
    cDefault : nStrikeThrough := PE_UNCHANGED;
  end;
  {Weight}
  nWeight := FW_DONTCARE;   {no change}
  case FWeight of
    fwDefault    : nWeight := FW_DONTCARE;
    fwThin       : nWeight := FW_THIN;
    fwExtraLight : nWeight := FW_EXTRALIGHT;
    fwLight      : nWeight := FW_LIGHT;
    fwNormal     : nWeight := FW_NORMAL;
    fwMedium     : nWeight := FW_MEDIUM;
    fwSemiBold   : nWeight := FW_SEMIBOLD;
    fwBold       : nWeight := FW_BOLD;
    fwExtraBold  : nWeight := FW_EXTRABOLD;
    fwHeavy      : nWeight := FW_HEAVY;
  end;

  if IsStrEmpty(sFont) and (nFamily = FF_DONTCARE) and
     (nPitch = DEFAULT_PITCH) and (nCharSet = DEFAULT_CHARSET) and
     (nSize = 0) and (nItalic = PE_UNCHANGED) and (nUnderlined = PE_UNCHANGED) and
     (nStrikeThrough = PE_UNCHANGED) and (nWeight = FW_DONTCARE) then
    Changed := False
  else
    Changed := True;

  {Send the Font to the Report}
  if Changed then
  begin
    
    if not Cr.FCrpeEngine.PESetFont(Cr.FPrintJob, SectionCode, nScope, PChar(sFont), nFamily,
      nPitch, nCharSet, nSize, nItalic, nUnderlined, nStrikethrough, nWeight) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'Send <PESetFont>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetSection                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFontItem.SetSection (const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetScope                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFontItem.SetScope (const Value: TCrFontScope);
begin
  FScope := Value;
  Send;
end;
{------------------------------------------------------------------------------}
{ SetName                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFontItem.SetName (const Value: TFontName);
begin
  FName := Value;
  Send;
end;
{------------------------------------------------------------------------------}
{ SetPitch                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFontItem.SetPitch (const Value: TFontPitch);
begin
  FPitch := Value;
  Send;
end;
{------------------------------------------------------------------------------}
{ SetFamily                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFontItem.SetFamily (const Value: TCrFontFamily);
begin
  FFamily := Value;
  Send;
end;
{------------------------------------------------------------------------------}
{ SetCharSet                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFontItem.SetCharSet (const Value: TCrFontCharSet);
begin
  FCharSet := Value;
  Send;
end;
{------------------------------------------------------------------------------}
{ SetSize                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFontItem.SetSize (const Value: Smallint);
begin
  FSize := Value;
  Send;
end;
{------------------------------------------------------------------------------}
{ SetItalic                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFontItem.SetItalic (const Value: TCrBoolean);
begin
  FItalic := Value;
  Send;
end;
{------------------------------------------------------------------------------}
{ SetUnderlined                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFontItem.SetUnderlined (const Value: TCrBoolean);
begin
  FUnderlined := Value;
  Send;
end;
{------------------------------------------------------------------------------}
{ SetStrikeThrough                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFontItem.SetStrikeThrough (const Value: TCrBoolean);
begin
  FStrikeThrough := Value;
  Send;
end;
{------------------------------------------------------------------------------}
{ SetWeight                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFontItem.SetWeight (const Value: TCrFontWeight);
begin
  FWeight := Value;
  Send;
end;
{------------------------------------------------------------------------------}
{ SectionAsCode                                                                }
{------------------------------------------------------------------------------}
function TCrpeSectionFontItem.SectionAsCode : Smallint;
var
  SectionCode : Smallint;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  if not StrToSectionCode(FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SectionAsCode <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := SectionCode;
end;
{------------------------------------------------------------------------------}
{ SectionType                                                                  }
{------------------------------------------------------------------------------}
function TCrpeSectionFontItem.SectionType : string;
begin
  if Length(FSection) > 0 then
  begin
    if UpperCase(FSection[1]) = 'D' then
      Result := Copy(FSection,1,1)
    else
      Result := Copy(FSection,1,2);
  end;
end;


{******************************************************************************}
{ Class TCrpeSectionFont                                                       }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSectionFont.Create;
begin
  inherited Create;
  FItem := TCrpeSectionFontItem.Create;
  FSubClassList.Add(FItem);
  FSection := '';
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSectionFont.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFont.Clear;
var
  i,j : integer;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex   := -1;
    FSection := '';
    FItem.Clear;
  end
  else
  begin
    j := FIndex;
    for i := 0 to Count-1 do
      Items[i].Clear;
    SetIndex(j);
  end;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.Count: integer;
var
  slSectionsS : TStringList;
  slSectionsN : TStringList;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {This next block of code is needed to adjust the section codes list if
   a Report has more than 40 sections or 25 groups, which cannot be accessed
   by the Print Engine}
  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;
  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(Cr.FPrintJob, slSectionsN, slSectionsS, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        Cr.BuildErrorString(Self) + 'Count <GetSectionCodes>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := slSectionsN.Count;
  slSectionsN.Free;
  slSectionsS.Free;
end;
{------------------------------------------------------------------------------}
{ IndexOf                                                                      }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.IndexOf(SectionName: string): integer;
var
  iCurrent : integer;
  cnt      : integer;
begin
  Result := -1;
  {Store current index}
  iCurrent := FIndex;
  {Locate formula name}
  for cnt := 0 to (Count-1) do
  begin
    SetIndex(cnt);
    if CompareText(FSection, SectionName) = 0 then
    begin
      Result := cnt;
      Break;
    end;
  end;
  {Re-set index}
  SetIndex(iCurrent);
end;
{------------------------------------------------------------------------------}
{ SetSection                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFont.SetSection (const Value: string);
var
  nIndex : integer;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Value) or (csLoading in Cr.ComponentState) then
  begin
    FIndex := -1;
    Exit;
  end;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
        'SectionFont.Section := ' + Value) of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeSectionFont.SetIndex (nIndex: integer);
var
  slSectionsS : TStringList;
  slSectionsN : TStringList;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Clear;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;
  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(Cr.FPrintJob, slSectionsN, slSectionsS, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        'SectionFont.SetIndex <GetSectionCodes>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if nIndex > (slSectionsS.Count-1) then
  begin
    slSectionsS.Free;
    slSectionsN.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
      'SectionFont[' + IntToStr(nIndex) + ']') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end
  else
  begin
    PropagateIndex(nIndex);
    FSection             := slSectionsS[nIndex];
    FItem.FSection       := slSectionsS[nIndex];
    FItem.FScope         := fsBoth;
    FItem.FName          := '';
    FItem.FPitch         := fpDefault;
    FItem.FFamily        := ffDefault;
    FItem.FCharSet       := fcDefault;
    FItem.FSize          := 0;
    FItem.FItalic        := cDefault;
    FItem.FUnderlined    := cDefault;
    FItem.FStrikeThrough := cDefault;
    FItem.FWeight        := fwDefault;
    slSectionsS.Free;
    slSectionsN.Free;
  end;
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.SectionFormat[nIndex]                                         }
{------------------------------------------------------------------------------}
function TCrpeSectionFont.GetItem(nIndex: integer) : TCrpeSectionFontItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeSectionSizeItem                                                   }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSectionSizeItem.Create;
begin
  inherited Create;
  FSection := '';
  FHeight  := -1;
  FWidth   := -1;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSectionSizeItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeSectionSizeItem then
  begin
    Section := TCrpeSectionSizeItem(Source).Section;
    Height  := TCrpeSectionSizeItem(Source).Height;
    Width   := TCrpeSectionSizeItem(Source).Width;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSectionSizeItem.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex   := -1;
    FSection := '';
    FHeight  := -1;
    FWidth   := -1;
  end;
end;
{------------------------------------------------------------------------------}
{ SetSection                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeSectionSizeItem.SetSection (const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetHeight                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeSectionSizeItem.SetHeight (const Value: Smallint);
var
  nHeightNew,
  SectionCode,
  nHeight  : Smallint;
  bRet     : Bool;
begin
  FHeight := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Convert SectionName to Code}
  if not StrToSectionCode(FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetHeight <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get SectionSize}
  nHeight := 0;
  
  bRet := Cr.FCrpeEngine.PEGetSectionHeight(Cr.FPrintJob, SectionCode, nHeight);
  if not bRet then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetHeight <PEGetSectionHeight>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  nHeightNew := FHeight;
  {If Changed, set new Height}
  // Be aware that setting the height smaller than the
  // original section height that the Report was designed with,
  // will cause an error!}
  if nHeightNew <> nHeight then
  begin
    
    bRet := Cr.FCrpeEngine.PESetSectionHeight(Cr.FPrintJob, SectionCode, nHeightNew);
    if not bRet then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetHeight <PESetSectionHeight>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetWidth                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeSectionSizeItem.SetWidth (const Value: Smallint);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SectionAsCode                                                                }
{------------------------------------------------------------------------------}
function TCrpeSectionSizeItem.SectionAsCode : Smallint;
var
  SectionCode : Smallint;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  if not StrToSectionCode(FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SectionAsCode <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := SectionCode;
end;
{------------------------------------------------------------------------------}
{ SectionType                                                                  }
{------------------------------------------------------------------------------}
function TCrpeSectionSizeItem.SectionType : string;
begin
  Result := '';
  if Length(FSection) > 0 then
  begin
    if UpperCase(FSection[1]) = 'D' then
      Result := Copy(FSection,1,1)
    else
      Result := Copy(FSection,1,2);
  end;
end;


{******************************************************************************}
{ Class TCrpeSectionSize                                                       }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSectionSize.Create;
begin
  inherited Create;
  FSection := '';
  FItem := TCrpeSectionSizeItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSectionSize.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSectionSize.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex   := -1;
    FSection := '';
    FItem.Clear;
  end;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeSectionSize.Count: integer;
var
  slSectionsS : TStringList;
  slSectionsN : TStringList;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {This next block of code is needed to adjust the section codes list if
   a Report has more than 40 sections or 25 groups, which cannot be accessed
   by the Print Engine}
  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;
  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(Cr.FPrintJob, slSectionsN, slSectionsS, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        Cr.BuildErrorString(Self) + 'Count <GetSectionCodes>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := slSectionsN.Count;
  slSectionsN.Free;
  slSectionsS.Free;
end;
{------------------------------------------------------------------------------}
{ IndexOf                                                                      }
{------------------------------------------------------------------------------}
function TCrpeSectionSize.IndexOf(SectionName: string): integer;
var
  iCurrent : integer;
  cnt      : integer;
begin
  Result := -1;
  {Store current index}
  iCurrent := FIndex;
  {Locate formula name}
  for cnt := 0 to (Count-1) do
  begin
    SetIndex(cnt);
    if CompareText(FSection, SectionName) = 0 then
    begin
      Result := cnt;
      Break;
    end;
  end;
  {Re-set index}
  SetIndex(iCurrent);
end;
{------------------------------------------------------------------------------}
{ SetSection                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeSectionSize.SetSection (const Value: string);
var
  nIndex : integer;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Value) or (csLoading in Cr.ComponentState) then
  begin
    FIndex := -1;
    Exit;
  end;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
        'SectionSize.Section := ' + Value) of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeSectionSize.SetIndex (nIndex: integer);
var
  slSectionsN : TStringList;
  slSectionsS : TStringList;
  s1          : string;
  nHeight     : Smallint;
  nWidth      : Smallint;
  SectionCode : Smallint;
  bRet        : Bool;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Clear;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;

  {Check that nIndex is in range}
  if nIndex > Count-1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       Cr.BuildErrorString(Self) + 'SetIndex(' + IntToStr(nIndex) + ')') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;
  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(Cr.FPrintJob, slSectionsN, slSectionsS, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <GetSectionCodes>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {This part obtains the Section information from a Report.}
  SectionCode := StrToInt(slSectionsN[nIndex]);
  s1 := slSectionsS[nIndex];
  slSectionsN.Free;
  slSectionsS.Free;
  
  bRet := Cr.FCrpeEngine.PEGetSectionHeight(Cr.FPrintJob, SectionCode, nHeight);
  if not bRet then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' + IntToStr(nIndex) +
        ') <PEGetSectionHeight>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);
  FSection := s1;
  FItem.FSection := FSection;
  FItem.FHeight := nHeight;

  {Get Section Width}
  if not Cr.FCrpeEngine.PEGetSectionWidth(Cr.FPrintJob,SectionCode,nWidth) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' + IntToStr(nIndex) +
        ') <PEGetSectionWidth>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FItem.FWidth := nWidth;
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.SectionSize[nIndex]                                           }
{------------------------------------------------------------------------------}
function TCrpeSectionSize.GetItem(nIndex: integer) : TCrpeSectionSizeItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeSessionInfoItem                                                   }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSessionInfoItem.Create;
begin
  inherited Create;
  FUserID        := '';
  FDBPassword    := '';
  FUserPassword  := '';
  FSessionHandle := 0;
  FPropagate     := True;
  FPrevProp      := True;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSessionInfoItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeSessionInfoItem then
  begin
    UserID        := TCrpeSessionInfoItem(Source).UserID;
    DBPassword    := TCrpeSessionInfoItem(Source).DBPassword;
    UserPassword  := TCrpeSessionInfoItem(Source).UserPassword;
    SessionHandle := TCrpeSessionInfoItem(Source).SessionHandle;
    Propagate     := TCrpeSessionInfoItem(Source).Propagate;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSessionInfoItem.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex         := -1;
    FUserID        := '';
    FDBPassword    := '';
    FUserPassword  := '';
    FSessionHandle := 0;
    FPropagate     := True;
    FPrevProp      := True;
  end
  else
  begin
    SetUserID('');
    SetDBPassword('');
    SetUserPassword('');
    SetSessionHandle(0);
  end;
end;
{------------------------------------------------------------------------------}
{ Test                                                                         }
{------------------------------------------------------------------------------}
function TCrpeSessionInfoItem.Test : Boolean;
begin
  Result := False;
  if (Cr = nil) then Exit;
  {Check index and Table Count}
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Need to Test Table Connection first!}
  Cr.FTables[FIndex].Test;
  {Test SessionInfo Connectivity}
  
  Result := Cr.FCrpeEngine.PETestNthTableConnectivity(Cr.FPrintJob, FIndex);
  {If if failed, store the resulting error}
  if Result = False then
    Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'Test <PETestNthTableConnectivity>');
end;
{------------------------------------------------------------------------------}
{ SetUserName                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSessionInfoItem.SetUserID(const Value: string);
var
  SessInfo : PESessionInfo;
  xUserID  : string;
begin
  FUserID := Value;
  {Check Length}
  if Length(FUserID) > PE_SESS_USERID_LEN then
    FUserID := Copy(FUserID, 1, PE_SESS_USERID_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get SessionInfo from Report}
  
  if not Cr.FCrpeEngine.PEGetNthTableSessionInfo(Cr.FPrintJob, FIndex, SessInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SessionInfo.SetUserID <PEGetNthTableSessionInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {UserID}
  xUserID := String(SessInfo.UserID);
  if CompareStr(xUserID, FUserID) <> 0 then
  begin
    StrCopy(SessInfo.UserId, PChar(FUserID));
    {Set SessionInfo}
    
    if not Cr.FCrpeEngine.PESetNthTableSessionInfo(Cr.FPrintJob, FIndex, SessInfo, FPropagate) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
           'SessionInfo.SetUserID <PESetNthTableSessionInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end; { SetUserName }
{------------------------------------------------------------------------------}
{ SetDBPassword                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeSessionInfoItem.SetDBPassword(const Value: string);
var
  SessInfo  : PESessionInfo;
  sPassword : string;
begin
  FDBPassword := Value;
  {Check Length}
  if Length(FDBPassword) > PE_SESS_PASSWORD_LEN then
    FDBPassword := Copy(FDBPassword, 1, PE_SESS_PASSWORD_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get SessionInfo from Report}
  
  if not Cr.FCrpeEngine.PEGetNthTableSessionInfo(Cr.FPrintJob, FIndex, SessInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SessionInfo.SetDBPassword <PEGetNthTableSessionInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {DBPassword}
  if not IsStrEmpty(FDBPassword) then
    sPassword := FUserPassword + Chr(10) + FDBPassword;
  {Check Length}
  if Length(sPassword) > PE_SESS_PASSWORD_LEN then
    sPassword := Copy(sPassword, 1, PE_SESS_PASSWORD_LEN);
  if StrComp(SessInfo.Password, PChar(sPassword)) <> 0 then
  begin
    StrCopy(SessInfo.Password, PChar(sPassword));
    {Set SessionInfo}
    
    if not Cr.FCrpeEngine.PESetNthTableSessionInfo(Cr.FPrintJob, FIndex, SessInfo, FPropagate) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
           'SessionInfo.SetDBPassword <PESetNthTableSessionInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end; { SetDBPassword }
{------------------------------------------------------------------------------}
{ SetUserPassword                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeSessionInfoItem.SetUserPassword(const Value: string);
var
  SessInfo  : PESessionInfo;
  sPassword : string;
begin
  FUserPassword := Value;
  {Check Length}
  if Length(FUserPassword) > PE_SESS_PASSWORD_LEN then
    FUserPassword := Copy(FUserPassword, 1, PE_SESS_PASSWORD_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get SessionInfo from Report}
  
  if not Cr.FCrpeEngine.PEGetNthTableSessionInfo(Cr.FPrintJob, FIndex, SessInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SessionInfo.SetUserPassword <PEGetNthTableSessionInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {UserPassword}
  sPassword := Trim(FUserPassword);
  {DBPassword}
  if not IsStrEmpty(FDBPassword) then
    sPassword := FUserPassword + Chr(10) + FDBPassword;
  {Check Length}
  if Length(sPassword) > PE_SESS_PASSWORD_LEN then
    sPassword := Copy(sPassword, 1, PE_SESS_PASSWORD_LEN);
  if StrComp(SessInfo.Password, PChar(sPassword)) <> 0 then
  begin
    StrCopy(SessInfo.Password, PChar(sPassword));
    {Set SessionInfo}
    
    if not Cr.FCrpeEngine.PESetNthTableSessionInfo(Cr.FPrintJob, FIndex, SessInfo, FPropagate) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
           'SessionInfo.SetUserPassword <PESetNthTableSessionInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end; { SetUserPassword }
{------------------------------------------------------------------------------}
{ SetSessionHandle                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeSessionInfoItem.SetSessionHandle (const Value: DWord);
var
  SessInfo : PESessionInfo;
begin
  FSessionHandle := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get SessionInfo from Report}
  
  if not Cr.FCrpeEngine.PEGetNthTableSessionInfo(Cr.FPrintJob, FIndex, SessInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SessionInfo.SetHandle <PEGetNthTableSessionInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Handle}
  if SessInfo.SessionHandle <> FSessionHandle then
  begin
    SessInfo.SessionHandle := FSessionHandle;
    {Set SessionInfo}
    
    if not Cr.FCrpeEngine.PESetNthTableSessionInfo(Cr.FPrintJob, FIndex, SessInfo, FPropagate) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
           'SessionInfo.SetHandle <PESetNthTableSessionInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetPropagate                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeSessionInfoItem.SetPropagate (const Value: Boolean);
var
  SessInfo : PESessionInfo;
begin
  FPrevProp := FPropagate;
  FPropagate := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get SessionInfo from Report}
  
  if not Cr.FCrpeEngine.PEGetNthTableSessionInfo(Cr.FPrintJob, FIndex, SessInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SessionInfo.SetPropagate <PEGetNthTableSessionInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Propagate}
  if (FPrevProp <> FPropagate) and (FPropagate = True) then
  begin
    {Set SessionInfo}
    
    if not Cr.FCrpeEngine.PESetNthTableSessionInfo(Cr.FPrintJob, FIndex, SessInfo, FPropagate) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
           'SessionInfo.SetPropagate <PESetNthTableSessionInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ Class TCrpeSessionInfo                                                       }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSessionInfo.Create;
begin
  inherited Create;
  FItem := TCrpeSessionInfoItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSessionInfo.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSessionInfo.Clear;
var
  i,j : integer;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex   := -1;
    FItem.Clear;
  end
  else
  begin
    j := FIndex;
    for i := 0 to Count-1 do
      Items[i].Clear;
    SetIndex(j);
  end;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeSessionInfo.Count: integer;
var
  nTables : Smallint;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get the number of Tables}
  
  nTables := Cr.FCrpeEngine.PEGetNTables(Cr.FPrintJob);
  if (nTables = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SessionInfo.Count <PEGetNTables>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := nTables;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeSessionInfo.SetIndex (nIndex: integer);
var
  SInfo : PESessionInfo;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Clear;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;

  {Retrieve Session Info}
  
  if not Cr.FCrpeEngine.PEGetNthTableSessionInfo(Cr.FPrintJob, nIndex, SInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SessionInfo.SetIndex <PEGetNthTableSessionInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);
  FItem.FUserID := String(SInfo.UserID);
  FItem.FDBPassword := String(SInfo.Password);
  FItem.FUserPassword := '';
  FItem.FSessionHandle := 0;
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.SessionInfo[nIndex]                                           }
{------------------------------------------------------------------------------}
function TCrpeSessionInfo.GetItem(nIndex: integer) : TCrpeSessionInfoItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeGraphsItem                                                        }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGraphsItem.Create;
begin
  inherited Create;
  {Graph Item properties}
  FSectionGraphNum := -1;
  FSection         := '';
  FStyle           := unknownGraphType;
  FText            := TCrpeGraphText.Create;
  FOptionInfo      := TCrpeGraphOptionInfo.Create;
  FAxis            := TCrpeGraphAxis.Create;
  FSubClassList.Add(FText);
  FSubClassList.Add(FOptionInfo);
  FSubClassList.Add(FAxis);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeGraphsItem.Destroy;
begin
  FText.Free;
  FOptionInfo.Free;
  FAxis.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeGraphsItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeGraphsItem then
  begin
    Style := TCrpeGraphsItem(Source).Style;
    Text.Assign(TCrpeGraphsItem(Source).Text);
    OptionInfo.Assign(TCrpeGraphsItem(Source).OptionInfo);
    Axis.Assign(TCrpeGraphsItem(Source).Axis);
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGraphsItem.Clear;
begin
  inherited Clear;
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex           := -1;
    FSectionGraphNum := -1;
    FSection         := '';
    FStyle           := unknownGraphType;
  end;
  FText.Clear;
  FOptionInfo.Clear;
  FAxis.Clear;
end;
{------------------------------------------------------------------------------}
{ GetGraphType                                                                 }
{------------------------------------------------------------------------------}
function TCrpeGraphsItem.GetGraphType (nGraphType, nSubType: Smallint): TCrGraphType;
begin
  {Default to Unknown}
  Result := unknownGraphType;
  case nGraphType of
    PE_GT_BARCHART :
      begin
        case nSubType of
          PE_GST_SIDEBYSIDEBARCHART        : Result := barSideBySide;
          PE_GST_STACKEDBARCHART           : Result := barStacked;
          PE_GST_PERCENTBARCHART           : Result := barPercent;
          PE_GST_FAKED3DSIDEBYSIDEBARCHART : Result := bar3DSideBySide;
          PE_GST_FAKED3DSTACKEDBARCHART    : Result := bar3DStacked;
          PE_GST_FAKED3DPERCENTBARCHART    : Result := bar3DPercent;
          else {PE_GST_UNKNOWNSUBTYPECHART}
            Result := unknownBar;
        end;
      end;
    PE_GT_LINECHART :
      begin
        case nSubType of
          PE_GST_REGULARLINECHART               : Result := lineRegular;
          PE_GST_STACKEDLINECHART               : Result := lineStacked;
          PE_GST_PERCENTAGELINECHART            : Result := linePercent;
          PE_GST_LINECHARTWITHMARKERS           : Result := lineWithMarkers;
          PE_GST_STACKEDLINECHARTWITHMARKERS    : Result := lineStackedWithMarkers;
          PE_GST_PERCENTAGELINECHARTWITHMARKERS : Result := linePercentWithMarkers;
          else {PE_GST_UNKNOWNSUBTYPECHART}
            Result := unknownLine;
        end;
      end;
    PE_GT_AREACHART :
      begin
        case nSubType of
          PE_GST_ABSOLUTEAREACHART        : Result := areaAbsolute;
          PE_GST_STACKEDAREACHART         : Result := areaStacked;
          PE_GST_PERCENTAREACHART         : Result := areaPercent;
          PE_GST_FAKED3DABSOLUTEAREACHART : Result := area3DAbsolute;
          PE_GST_FAKED3DSTACKEDAREACHART  : Result := area3DStacked;
          PE_GST_FAKED3DPERCENTAREACHART  : Result := area3DPercent;
          else {PE_GST_UNKNOWNSUBTYPECHART}
            Result := unknownArea;
        end;
      end;
    PE_GT_PIECHART :
      begin
        case nSubType of
          PE_GST_REGULARPIECHART              : Result := pieRegular;
          PE_GST_FAKED3DREGULARPIECHART       : Result := pie3DRegular;
          PE_GST_MULTIPLEPIECHART             : Result := pieMultiple;
          PE_GST_MULTIPLEPROPORTIONALPIECHART : Result := pieMultiProp;
          else {PE_GST_UNKNOWNSUBTYPECHART}
            Result := unknownPie;
        end;
      end;
    PE_GT_DOUGHNUTCHART :
      begin
        case nSubType of
          PE_GST_REGULARDOUGHNUTCHART              : Result := doughnutRegular;
          PE_GST_MULTIPLEDOUGHNUTCHART             : Result := doughnutMultiple;
          PE_GST_MULTIPLEPROPORTIONALDOUGHNUTCHART : Result := doughnutMultiProp;
          else {PE_GST_UNKNOWNSUBTYPECHART}
            Result := unknownDoughnut;
        end;
      end;
    PE_GT_THREEDRISERCHART :
      begin
        case nSubType of
          PE_GST_THREEDREGULARCHART    : Result := ThreeDRegular;
          PE_GST_THREEDPYRAMIDCHART    : Result := ThreeDPyramid;
          PE_GST_THREEDOCTAGONCHART    : Result := ThreeDOctagon;
          PE_GST_THREEDCUTCORNERSCHART : Result := ThreeDCutCorners;
          else {PE_GST_UNKNOWNSUBTYPECHART}
            Result := unknown3DRiser;
        end;
      end;
    PE_GT_THREEDSURFACECHART :
      begin
        case nSubType of
          PE_GST_THREEDSURFACEREGULARCHART   : Result := ThreeDSurfaceRegular;
          PE_GST_THREEDSURFACEWITHSIDESCHART : Result := ThreeDSurfaceWithSides;
          PE_GST_THREEDSURFACEHONEYCOMBCHART : Result := ThreeDSurfaceHoneyComb;
          else {PE_GST_UNKNOWNSUBTYPECHART}
            Result := unknown3DSurface;
        end;
      end;
    PE_GT_SCATTERCHART :
      begin
        case nSubType of
          PE_GST_XYSCATTERCHART                   : Result := XYScatter;
          PE_GST_XYSCATTERDUALAXISCHART           : Result := XYScatterDualAxis;
          PE_GST_XYSCATTERWITHLABELSCHART         : Result := XYScatterLabeled;
          PE_GST_XYSCATTERDUALAXISWITHLABELSCHART : Result := XYScatterDualAxisLabeled;
          else {PE_GST_UNKNOWNSUBTYPECHART}
            Result := unknownXYScatter;
        end;
      end;
    PE_GT_RADARCHART :
      begin
        case nSubType of
          PE_GST_REGULARRADARCHART  : Result := radarRegular;
          PE_GST_STACKEDRADARCHART  : Result := radarStacked;
          PE_GST_RADARDUALAXISCHART : Result := radarDualAxis;
          else {PE_GST_UNKNOWNSUBTYPECHART}
            Result := unknownRadar;
        end;
      end;
    PE_GT_BUBBLECHART :
      begin
        case nSubType of
          PE_GST_REGULARBUBBLECHART  : Result := bubbleRegular;
          PE_GST_DUALAXISBUBBLECHART : Result := bubbleDualAxis;
          else {PE_GST_UNKNOWNSUBTYPECHART}
            Result := unknownBubble;
        end;
      end;
    PE_GT_STOCKCHART  :
      begin
        case nSubType of
          PE_GST_HIGHLOWCHART                  : Result := stockHiLo;
          PE_GST_HIGHLOWDUALAXISCHART          : Result := stockHiLoDualAxis;
          PE_GST_HIGHLOWOPENCHART              : Result := stockHiLoOpen;
          PE_GST_HIGHLOWOPENDUALAXISCHART      : Result := stockHiLoOpenDualAxis;
          PE_GST_HIGHLOWOPENCLOSECHART         : Result := stockHiLoOpenClose;
          PE_GST_HIGHLOWOPENCLOSEDUALAXISCHART : Result := stockHiLoOpenCloseDualAxis;
          else {PE_GST_UNKNOWNSUBTYPECHART}
            Result := unknownStockHiLo;
        end;
      end;
    PE_GT_USERDEFINEDCHART : Result := userDefinedGraph;
    PE_GT_UNKNOWNTYPECHART : Result := unknownGraphType;
  end;
end;
{------------------------------------------------------------------------------}
{ GetGraphTypeConst                                                            }
{------------------------------------------------------------------------------}
procedure TCrpeGraphsItem.GetGraphTypeConst (xGraphType: TCrGraphType;
  var nGraphType: Smallint; var nSubType: Smallint);
var
  i: integer;
begin
  for i := 0 to 1 do
  begin
    if i = 0 then
    begin
      {GraphType}
      case xGraphType of
        barSideBySide..bar3DPercent         : nGraphType := PE_GT_BARCHART;
        lineRegular..linePercentWithMarkers : nGraphType := PE_GT_LINECHART;
        areaAbsolute..area3DPercent         : nGraphType := PE_GT_AREACHART;
        pieRegular..pieMultiProp            : nGraphType := PE_GT_PIECHART;
        doughnutRegular..doughnutMultiProp  : nGraphType := PE_GT_DOUGHNUTCHART;
        ThreeDRegular..ThreeDCutCorners     : nGraphType := PE_GT_THREEDRISERCHART;
        ThreeDSurfaceRegular..ThreeDSurfaceHoneyComb : nGraphType := PE_GT_THREEDSURFACECHART;
        XYScatter..XYScatterDualAxisLabeled : nGraphType := PE_GT_SCATTERCHART;
        radarRegular..radarDualAxis         : nGraphType := PE_GT_RADARCHART;
        bubbleRegular..bubbleDualAxis       : nGraphType := PE_GT_BUBBLECHART;
        stockHiLo..stockHiLoOpenCloseDualAxis : nGraphType := PE_GT_STOCKCHART;
        userDefinedGraph : nGraphType := PE_GT_USERDEFINEDCHART;
        unknownGraphType : nGraphType := PE_GT_UNKNOWNTYPECHART;
      end
    end
    else
    begin
      {GraphSubType}
      case xGraphType of
        barSideBySide   : nSubType := PE_GST_SIDEBYSIDEBARCHART;
        barStacked      : nSubType := PE_GST_STACKEDBARCHART;
        barPercent      : nSubType := PE_GST_PERCENTBARCHART;
        bar3DSideBySide : nSubType := PE_GST_FAKED3DSIDEBYSIDEBARCHART;
        bar3DStacked    : nSubType := PE_GST_FAKED3DSTACKEDBARCHART;
        bar3DPercent    : nSubType := PE_GST_FAKED3DPERCENTBARCHART;
        lineRegular            : nSubType := PE_GST_REGULARLINECHART;
        lineStacked            : nSubType := PE_GST_STACKEDLINECHART;
        linePercent            : nSubType := PE_GST_PERCENTAGELINECHART;
        lineWithMarkers        : nSubType := PE_GST_LINECHARTWITHMARKERS;
        lineStackedWithMarkers : nSubType := PE_GST_STACKEDLINECHARTWITHMARKERS;
        linePercentWithMarkers : nSubType := PE_GST_PERCENTAGELINECHARTWITHMARKERS;
        areaAbsolute   : nSubType := PE_GST_ABSOLUTEAREACHART;
        areaStacked    : nSubType := PE_GST_STACKEDAREACHART;
        areaPercent    : nSubType := PE_GST_PERCENTAREACHART;
        area3DAbsolute : nSubType := PE_GST_FAKED3DABSOLUTEAREACHART;
        area3DStacked  : nSubType := PE_GST_FAKED3DSTACKEDAREACHART;
        area3DPercent  : nSubType := PE_GST_FAKED3DPERCENTAREACHART;
        pieRegular    : nSubType := PE_GST_REGULARPIECHART;
        pie3DRegular  : nSubType := PE_GST_FAKED3DREGULARPIECHART;
        pieMultiple   : nSubType := PE_GST_MULTIPLEPIECHART;
        pieMultiProp  : nSubType := PE_GST_MULTIPLEPROPORTIONALPIECHART;
        doughnutRegular    : nSubType := PE_GST_REGULARDOUGHNUTCHART;
        doughnutMultiple   : nSubType := PE_GST_MULTIPLEDOUGHNUTCHART;
        doughnutMultiProp  : nSubType := PE_GST_MULTIPLEPROPORTIONALDOUGHNUTCHART;
        ThreeDRegular           : nSubType := PE_GST_THREEDREGULARCHART;
        ThreeDPyramid           : nSubType := PE_GST_THREEDPYRAMIDCHART;
        ThreeDOctagon           : nSubType := PE_GST_THREEDOCTAGONCHART;
        ThreeDCutCorners        : nSubType := PE_GST_THREEDCUTCORNERSCHART;
        ThreeDSurfaceRegular    : nSubType := PE_GST_THREEDSURFACEREGULARCHART;
        ThreeDSurfaceWithSides  : nSubType := PE_GST_THREEDSURFACEWITHSIDESCHART;
        ThreeDSurfaceHoneyComb  : nSubType := PE_GST_THREEDSURFACEHONEYCOMBCHART;
        XYScatter                : nSubType := PE_GST_XYSCATTERCHART;
        XYScatterDualAxis        : nSubType := PE_GST_XYSCATTERDUALAXISCHART;
        XYScatterLabeled         : nSubType := PE_GST_XYSCATTERWITHLABELSCHART;
        XYScatterDualAxisLabeled : nSubType := PE_GST_XYSCATTERDUALAXISWITHLABELSCHART;
        radarRegular  : nSubType := PE_GST_REGULARRADARCHART;
        radarStacked  : nSubType := PE_GST_STACKEDRADARCHART;
        radarDualAxis : nSubType := PE_GST_RADARDUALAXISCHART;
        bubbleRegular  : nSubType := PE_GST_REGULARBUBBLECHART;
        bubbleDualAxis : nSubType := PE_GST_DUALAXISBUBBLECHART;
        stockHiLo                  : nSubType := PE_GST_HIGHLOWCHART;
        stockHiLoDualAxis          : nSubType := PE_GST_HIGHLOWDUALAXISCHART;
        stockHiLoOpen              : nSubType := PE_GST_HIGHLOWOPENCHART;
        stockHiLoOpenDualAxis      : nSubType := PE_GST_HIGHLOWOPENDUALAXISCHART;
        stockHiLoOpenClose         : nSubType := PE_GST_HIGHLOWOPENCLOSECHART;
        stockHiLoOpenCloseDualAxis : nSubType := PE_GST_HIGHLOWOPENCLOSEDUALAXISCHART;
        userDefinedGraph : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
        unknownBar       : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
        unknownLine      : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
        unknownArea      : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
        unknownPie       : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
        unknownDoughnut  : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
        unknown3DRiser   : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
        unknown3DSurface : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
        unknownXYScatter : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
        unknownRadar     : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
        unknownBubble    : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
        unknownStockHiLo : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
        unknownGraphType : nSubType := PE_GST_UNKNOWNSUBTYPECHART;
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetSectionGraphNum                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeGraphsItem.SetSectionGraphNum (const Value: Smallint);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetStyle                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeGraphsItem.SetStyle (const Value: TCrGraphType);
var
  nGraph,
  SectionCode   : Smallint;
  GraphTypeInfo : PEGraphTypeInfo;
  nGType        : Smallint;
  nSubType      : Smallint;
begin
  FStyle := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'Graphs.SetStyle <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphType}
  
  if not Cr.FCrpeEngine.PEGetGraphTypeInfo(Cr.FPrintJob, SectionCode, nGraph, GraphTypeInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Graphs.SetStyle <PEGetGraphTypeInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Style}
  nSubType := PE_GST_UNKNOWNSUBTYPECHART;
  GetGraphTypeConst(FStyle, nGType, nSubType);

  {Compare}
  if (GraphTypeInfo.graphType <> nGType) or
     (GraphTypeInfo.graphSubtype <> nSubType) then
  begin
    GraphTypeInfo.graphType := nGType;
    GraphTypeInfo.graphSubType := nSubType;
    {Send GraphTypeInfo to Report}
    
    if not Cr.FCrpeEngine.PESetGraphTypeInfo(Cr.FPrintJob, SectionCode, nGraph, GraphTypeInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Graphs.SetStyle <PESetGraphTypeInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SectionAsCode                                                                }
{------------------------------------------------------------------------------}
function TCrpeGraphsItem.SectionAsCode : Smallint;
var
  SectionCode : Smallint;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  if not StrToSectionCode(FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SectionAsCode <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := SectionCode;
end;
{------------------------------------------------------------------------------}
{ SectionType                                                                  }
{------------------------------------------------------------------------------}
function TCrpeGraphsItem.SectionType : string;
begin
  Result := '';
  if Length(FSection) > 0 then
  begin
    if UpperCase(FSection[1]) = 'D' then
      Result := Copy(FSection,1,1)
    else
      Result := Copy(FSection,1,2);
  end;
end;


{******************************************************************************}
{ Class TCrpeGraphs                                                            }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGraphs.Create;
begin
  inherited Create;
  FObjectType      := otGraph;
  FFieldObjectType := oftNone;
  FItem            := TCrpeGraphsItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeGraphs.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGraphs.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    Handle := 0;
    FItem.Clear;
  end;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeGraphs.Count : integer;
var
  i             : Smallint;
  SectionCode   : Smallint;
  slSectionsN,
  slSectionsS   : TStringList;
  cnt1          : Smallint;
  nGraphs       : integer;
  GraphTypeInfo : PEGraphTypeInfo;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;
  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(Cr.FPrintJob, slSectionsN, slSectionsS, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        'Graphs.Count <GetSectionCodes>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  nGraphs := 0;
  {Loop through sections}
  for i := 0 to (slSectionsS.Count - 1) do
  begin
    {Loop through possible 10 graphs per section. Could be
     more, but this seems like a reasonable limit}
    for cnt1 := 0 to 9 do
    begin
      SectionCode := StrToInt(slSectionsN[i]);
      {Get GraphTypeInfo}
      
      if Cr.FCrpeEngine.PEGetGraphTypeInfo(Cr.FPrintJob, SectionCode, cnt1, GraphTypeInfo) then
        Inc(nGraphs);
    end;
  end;
  slSectionsN.Free;
  slSectionsS.Free;
  Result := nGraphs;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeGraphs.SetIndex (nIndex: integer);
var
  i             : Smallint;
  SectionCode   : Smallint;
  slSectionsN,
  slSectionsS   : TStringList;
  cnt1          : Smallint;
  nGraph        : integer;
  GraphTypeInfo : PEGraphTypeInfo;
  bGraphFound   : Bool; 
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Clear;
    Exit;
  end;
  inherited SetIndex(nIndex);
  if not Cr.OpenPrintJob then Exit;

  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       'Graphs.SetIndex(' + IntToStr(nIndex) + ')') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  bGraphFound := false; 

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;
  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(Cr.FPrintJob, slSectionsN, slSectionsS, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        'Graphs.SetIndex(' + IntToStr(nIndex) + ') <GetSectionCodes>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  nGraph := 0;
  {Loop through sections}
  for i := 0 to (slSectionsS.Count - 1) do
  begin
    {Loop through possible 10 graphs per section. Could be
     more, but this seems like a reasonable limit}
    for cnt1 := 0 to 9 do
    begin
      SectionCode := StrToInt(slSectionsN[i]);
      {Get GraphTypeInfo}
      
      if Cr.FCrpeEngine.PEGetGraphTypeInfo(Cr.FPrintJob, SectionCode, cnt1, GraphTypeInfo) then
      begin
        if nGraph = nIndex then
        begin
          PropagateIndex(nIndex);
          Item.FSectionGraphNum := cnt1;
          //Item.FSection := slSectionsS[i];
          Item.FStyle := Item.GetGraphType(GraphTypeInfo.graphType,
            GraphTypeInfo.graphSubtype);
          {Graph Subclasses}
          Item.FText.GetText;
          Item.FOptionInfo.GetOptionInfo;
          Item.FAxis.GetAxis;
          bGraphFound := True;
          Break;
        end
        else
          Inc(nGraph);
      end;
    end;
    if bGraphFound = True then
      Break;
  end;
  slSectionsN.Free;
  slSectionsS.Free;
end;
{------------------------------------------------------------------------------}
{ GetItems                                                                     }
{   - This is the default property and can be also set                         }
{      via Crpe1.Graphs[nIndex]                                                }
{------------------------------------------------------------------------------}
function TCrpeGraphs.GetItems(nIndex: integer) : TCrpeGraphsItem;
begin
  SetIndex(nIndex);
  Result := TCrpeGraphsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeGraphs.GetItem : TCrpeGraphsItem;
begin
  Result := TCrpeGraphsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ SetItem                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeGraphs.SetItem (const nItem: TCrpeGraphsItem);
begin
  FItem.Assign(nItem);
end;


{******************************************************************************}
{ Class TCrpeGraphOptionInfo                                                   }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGraphOptionInfo.Create;
begin
  inherited Create;
  FColor        := gcColor;
  FLegend       := glRight; { showLegend and LegendPosition }
  { Pie Charts and Doughut Charts }
  FPieSize      := gpsAverage;
  FPieSlice     := gslNone;
  { Bar Chart }
  FBarSize      := gbsLarge;
  FBarDirection := bdVertical;
  { Markers (used for line and bar charts) }
  FMarkerSize   := gmsMedium;
  FMarkerShape  := gshRectangle;
  { Data Points }
  FDataPoints   := gdpNone;
  FNumberFormat := gnfNoDecimal;
  { 3D }
  FViewingAngle := gvaStandard;
  FLegendLayout := gllPercentage;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.Assign(Source: TPersistent);
begin
  if Source is TCrpeGraphOptionInfo then
  begin
    Color        := TCrpeGraphOptionInfo(Source).Color;
    Legend       := TCrpeGraphOptionInfo(Source).Legend;
    { Pie Charts and Doughut Charts }
    PieSize      := TCrpeGraphOptionInfo(Source).PieSize;
    PieSlice     := TCrpeGraphOptionInfo(Source).PieSlice;
    { Bar Chart }
    BarSize      := TCrpeGraphOptionInfo(Source).BarSize;
    BarDirection := TCrpeGraphOptionInfo(Source).BarDirection;
    { Markers (used for line and bar charts) }
    MarkerSize   := TCrpeGraphOptionInfo(Source).MarkerSize;
    MarkerShape  := TCrpeGraphOptionInfo(Source).MarkerShape;
    { Data Points }
    DataPoints   := TCrpeGraphOptionInfo(Source).DataPoints;
    NumberFormat := TCrpeGraphOptionInfo(Source).NumberFormat;
    { 3D }
    ViewingAngle := TCrpeGraphOptionInfo(Source).ViewingAngle;
    LegendLayout := TCrpeGraphOptionInfo(Source).LegendLayout;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex            := -1;
    Handle            := 0;
    FColor            := gcColor;
    FLegend           := glRight; { showLegend and LegendPosition }
    { Pie Charts and Doughut Charts }
    FPieSize          := gpsAverage;
    FPieSlice         := gslNone;
    { Bar Chart }
    FBarSize          := gbsLarge;
    FBarDirection     := bdVertical;
    { Markers (used for line and bar charts) }
    FMarkerSize       := gmsMedium;
    FMarkerShape      := gshRectangle;
    { Data Points }
    FDataPoints       := gdpNone;
    FNumberFormat     := gnfNoDecimal;
    { 3D }
    FViewingAngle     := gvaStandard;
    FLegendLayout := gllPercentage;
  end;
end;
{------------------------------------------------------------------------------}
{ SetColor                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetColor (const Value: TCrGraphColor);
var
  nGraph       : Smallint;
  SectionCode  : Smallint;
  GrOptionInfo : PEGraphOptionInfo;
  iTmp         : integer;
begin
  FColor := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphOptionInfo.SetColor <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphOptionInfo from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphOptionInfo.SetColor <PEGetGraphOptionInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {GraphColor}
  iTmp := PE_UNCHANGED;
  case FColor of
    gcColor      : iTmp := PE_GCR_COLORCHART;
    gcMonochrome : iTmp := PE_GCR_BLACKANDWHITECHART;
  end;
  if GrOptionInfo.graphColor <> iTmp then
  begin
    GrOptionInfo.graphColor := iTmp;
    {Send the GraphOptionInfo to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphOptionInfo.SetColor <PESetGraphOptionInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetLegend                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetLegend (const Value: TCrGraphLegend);
var
  nGraph       : Smallint;
  SectionCode  : Smallint;
  GrOptionInfo : PEGraphOptionInfo;
  iTmp         : integer;
  Changed      : Boolean;
begin
  FLegend := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then  Exit;
  Changed := False;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphOptionInfo.SetLegend <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphOptionInfo from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphOptionInfo.SetLegend <PEGetGraphOptionInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Legend}
  iTmp := -1;
  case FLegend of
    glNone         : iTmp := -1;
    glUpperRight   : iTmp := PE_GLP_PLACEUPPERRIGHT;
    glBottomCenter : iTmp := PE_GLP_PLACEBOTTOMCENTER;
    glTopCenter    : iTmp := PE_GLP_PLACETOPCENTER;
    glRight        : iTmp := PE_GLP_PLACERIGHT;
    glLeft         : iTmp := PE_GLP_PLACELEFT;
    glCustom       : iTmp := GrOptionInfo.legendPosition; {cannot send Custom}
  end;
  if iTmp = -1 then {glNone}
  begin
    {If the Legend is set to show, turn it off}
    if GrOptionInfo.showLegend <> 0 then
    begin
      GrOptionInfo.showLegend := 0;
      Changed := True;
    end;
  end
  else
  begin
    if GrOptionInfo.legendPosition <> iTmp then
    begin
      GrOptionInfo.legendPosition := iTmp;
      Changed := True;
    end;
  end;

  {This guards against an obscure out-of-range(5) value with older(?) graphs}
  if (GrOptionInfo.legendPosition < PE_GLP_PLACEUPPERRIGHT) or
     (GrOptionInfo.legendPosition > PE_GLP_PLACELEFT) then
    GrOptionInfo.legendPosition := PE_GLP_PLACEUPPERRIGHT;

  {Send the GraphOptionInfo to the Report}
  if Changed then
  begin
    
    if not Cr.FCrpeEngine.PESetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphOptionInfo.SetLegend <PESetGraphOptionInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetPieSize                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetPieSize (const Value: TCrGraphPieSize);
var
  nGraph       : Smallint;
  SectionCode  : Smallint;
  GrOptionInfo : PEGraphOptionInfo;
  iTmp         : integer;
begin
  FPieSize := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphOptionInfo.SetPieSize <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphOptionInfo from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphOptionInfo.SetPieSize <PEGetGraphOptionInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {PieSize}
  iTmp := PE_UNCHANGED;
  case FPieSize of
    gpsMinimum : iTmp := PE_GPS_MINIMUMPIESIZE;
    gpsSmall   : iTmp := PE_GPS_SMALLPIESIZE;
    gpsAverage : iTmp := PE_GPS_AVERAGEPIESIZE;
    gpsLarge   : iTmp := PE_GPS_LARGEPIESIZE;
    gpsMaximum : iTmp := PE_GPS_MAXIMUMPIESIZE;
  end;
  if GrOptionInfo.pieSize <> iTmp then
  begin
    GrOptionInfo.pieSize := iTmp;
    {Send the GraphOptionInfo to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphOptionInfo.SetPieSize <PESetGraphOptionInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetPieSlice                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetPieSlice (const Value: TCrGraphPieSlice);
var
  nGraph       : Smallint;
  SectionCode  : Smallint;
  GrOptionInfo : PEGraphOptionInfo;
  iTmp         : integer;
begin
  FPieSlice := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphOptionInfo.SetPieSlice <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphOptionInfo from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphOptionInfo.SetPieSlice <PEGetGraphOptionInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {PieSlice}
  iTmp := PE_UNCHANGED;
  case FPieSlice of
    gslNone  : iTmp := PE_GDPS_NODETACHMENT;
    gslSmall : iTmp := PE_GDPS_SMALLESTSLICE;
    gslLarge : iTmp := PE_GDPS_LARGESTSLICE;
  end;
  if GrOptionInfo.detachedPieSlice <> iTmp then
  begin
    GrOptionInfo.detachedPieSlice := iTmp;
    {Send the GraphOptionInfo to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphOptionInfo.SetPieSlice <PESetGraphOptionInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetBarSize                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetBarSize (const Value: TCrGraphBarSize);
var
  nGraph       : Smallint;
  SectionCode  : Smallint;
  GrOptionInfo : PEGraphOptionInfo;
  iTmp         : integer;
begin
  FBarSize := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphOptionInfo.SetBarSize <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphOptionInfo from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphOptionInfo.SetBarSize <PEGetGraphOptionInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {BarSize}
  iTmp := PE_UNCHANGED;
  case FBarSize of
    gbsMinimum : iTmp := PE_GBS_MINIMUMBARSIZE;
    gbsSmall   : iTmp := PE_GBS_SMALLBARSIZE;
    gbsAverage : iTmp := PE_GBS_AVERAGEBARSIZE;
    gbsLarge   : iTmp := PE_GBS_LARGEBARSIZE;
    gbsMaximum : iTmp := PE_GBS_MAXIMUMBARSIZE;
  end;
  if GrOptionInfo.barSize <> iTmp then
  begin
    GrOptionInfo.barSize := iTmp;
    {Send the GraphOptionInfo to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphOptionInfo.SetBarSize <PESetGraphOptionInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetBarDirection                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetBarDirection (const Value: TCrGraphBarDirection);
var
  nGraph       : Smallint;
  SectionCode  : Smallint;
  GrOptionInfo : PEGraphOptionInfo;
  iTmp         : integer;
begin
  FBarDirection := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphOptionInfo.SetBarDirection <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphOptionInfo from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphOptionInfo.SetBarDirection <PEGetGraphOptionInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {BarDirection}
  iTmp := Ord(FBarDirection);
  if GrOptionInfo.verticalBars <> iTmp then
  begin
    GrOptionInfo.verticalBars := iTmp;
    {Send the GraphOptionInfo to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphOptionInfo.SetBarDirection <PESetGraphOptionInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetMarkerSize                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetMarkerSize (const Value: TCrGraphMarkerSize);
var
  nGraph       : Smallint;
  SectionCode  : Smallint;
  GrOptionInfo : PEGraphOptionInfo;
  iTmp         : integer;
begin
  FMarkerSize := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphOptionInfo.SetMarkerSize <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphOptionInfo from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphOptionInfo.SetMarkerSize <PEGetGraphOptionInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {MarkerSize}
  iTmp := PE_UNCHANGED;
  case FMarkerSize of
    gmsSmall       : iTmp := PE_GMS_SMALLMARKERS;
    gmsMediumSmall : iTmp := PE_GMS_MEDIUMSMALLMARKERS;
    gmsMedium      : iTmp := PE_GMS_MEDIUMMARKERS;
    gmsMediumLarge : iTmp := PE_GMS_MEDIUMLARGEMARKERS;
    gmsLarge       : iTmp := PE_GMS_LARGEMARKERS;
  end;
  if GrOptionInfo.markerSize <> iTmp then
  begin
    GrOptionInfo.markerSize := iTmp;
    {Send the GraphOptionInfo to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphOptionInfo.SetMarkerSize <PESetGraphOptionInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetMarkerShape                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetMarkerShape (const Value: TCrGraphMarkerShape);
var
  nGraph       : Smallint;
  SectionCode  : Smallint;
  GrOptionInfo : PEGraphOptionInfo;
  iTmp         : integer;
begin
  FMarkerShape := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphOptionInfo.SetMarkerShape <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphOptionInfo from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphOptionInfo.SetMarkerShape <PEGetGraphOptionInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {MarkerShape}
  iTmp := PE_UNCHANGED;
  case FMarkerShape of
    gshRectangle : iTmp := PE_GMSP_RECTANGLESHAPE;
    gshCircle    : iTmp := PE_GMSP_CIRCLESHAPE;
    gshDiamond   : iTmp := PE_GMSP_DIAMONDSHAPE;
    gshTriangle  : iTmp := PE_GMSP_TRIANGLESHAPE;
  end;
  if GrOptionInfo.markerShape <> iTmp then
  begin
    GrOptionInfo.markerShape := iTmp;
    {Send the GraphOptionInfo to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphOptionInfo.SetMarkerShape <PESetGraphOptionInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDataPoints                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetDataPoints (const Value: TCrGraphDataPoints);
var
  nGraph       : Smallint;
  SectionCode  : Smallint;
  GrOptionInfo : PEGraphOptionInfo;
  iTmp         : integer;
begin
  FDataPoints := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphOptionInfo.SetDataPoints <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphOptionInfo from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphOptionInfo.SetDataPoints <PEGetGraphOptionInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {DataPoints}
  iTmp := PE_UNCHANGED;
  case FDataPoints of
    gdpNone      : iTmp := PE_GDP_NONE;
    gdpShowLabel : iTmp := PE_GDP_SHOWLABEL;
    gdpShowValue : iTmp := PE_GDP_SHOWVALUE;
  end;
  if GrOptionInfo.dataPoints <> iTmp then
  begin
    GrOptionInfo.dataPoints := iTmp;
    {Send the GraphOptionInfo to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphOptionInfo.SetDataPoints <PESetGraphOptionInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetNumberFormat                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetNumberFormat (const Value: TCrGraphNumberFormat);
var
  nGraph       : Smallint;
  SectionCode  : Smallint;
  GrOptionInfo : PEGraphOptionInfo;
  iTmp         : integer;
begin
  FNumberFormat := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphOptionInfo.SetNumberFormat <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphOptionInfo from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphOptionInfo.SetNumberFormat <PEGetGraphOptionInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {NumberFormat}
  iTmp := PE_UNCHANGED;
  case FNumberFormat of
    gnfNoDecimal          : iTmp := PE_GNF_NODECIMAL;
    gnfOneDecimal         : iTmp := PE_GNF_ONEDECIMAL;
    gnfTwoDecimal         : iTmp := PE_GNF_TWODECIMAL;
    gnfUnknownType        : iTmp := PE_GNF_UNKNOWNTYPE;
    gnfCurrencyTwoDecimal : iTmp := PE_GNF_CURRENCYTWODECIMAL;
    gnfPercentNoDecimal   : iTmp := PE_GNF_PERCENTNODECIMAL;
    gnfPercentOneDecimal  : iTmp := PE_GNF_PERCENTONEDECIMAL;
    gnfPercentTwoDecimal  : iTmp := PE_GNF_PERCENTTWODECIMAL;
    gnfOther              : iTmp := PE_GNF_OTHER;   
  end;
  if GrOptionInfo.dataValueNumberFormat <> iTmp then
  begin
    GrOptionInfo.dataValueNumberFormat := iTmp;
    {Send the GraphOptionInfo to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphOptionInfo.SetNumberFormat <PESetGraphOptionInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetViewingAngle                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetViewingAngle (const Value: TCrGraphViewingAngle);
var
  nGraph       : Smallint;
  SectionCode  : Smallint;
  GrOptionInfo : PEGraphOptionInfo;
  iTmp         : integer;
begin
  FViewingAngle := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphOptionInfo.SetViewingAngle <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphOptionInfo from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphOptionInfo.SetViewingAngle <PEGetGraphOptionInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {ViewingAngle}
  iTmp := PE_UNCHANGED;
  case FViewingAngle of
    gvaStandard      : iTmp := PE_GVA_STANDARDVIEW;
    gvaTall          : iTmp := PE_GVA_TALLVIEW;
    gvaTop           : iTmp := PE_GVA_TOPVIEW;
    gvaDistorted     : iTmp := PE_GVA_DISTORTEDVIEW;
    gvaShort         : iTmp := PE_GVA_SHORTVIEW;
    gvaGroupEye      : iTmp := PE_GVA_GROUPEYEVIEW;
    gvaGroupEmphasis : iTmp := PE_GVA_GROUPEMPHASISVIEW;
    gvaFewSeries     : iTmp := PE_GVA_FEWSERIESVIEW;
    gvaFewGroups     : iTmp := PE_GVA_FEWGROUPSVIEW;
    gvaDistortedStd  : iTmp := PE_GVA_DISTORTEDSTDVIEW;
    gvaThickGroups   : iTmp := PE_GVA_THICKGROUPSVIEW;
    gvaShorter       : iTmp := PE_GVA_SHORTERVIEW;
    gvaThickSeries   : iTmp := PE_GVA_THICKSERIESVIEW;
    gvaThickStd      : iTmp := PE_GVA_THICKSTDVIEW;
    gvaBirdsEye      : iTmp := PE_GVA_BIRDSEYEVIEW;
    gvaMax           : iTmp := PE_GVA_MAXVIEW;
  end;
  if GrOptionInfo.viewingAngle <> iTmp then
  begin
    GrOptionInfo.viewingAngle := iTmp;
    {Send the GraphOptionInfo to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphOptionInfo.SetViewingAngle <PESetGraphOptionInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetLegendLayout                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.SetLegendLayout (const Value: TCrGraphLegendLayout);
var
  nGraph       : Smallint;
  SectionCode  : Smallint;
  GrOptionInfo : PEGraphOptionInfo;
  iTmp         : integer;
begin
  FLegendLayout := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetLegendLayout <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphOptionInfo from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetLegendLayout <PEGetGraphOptionInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  iTmp := PE_UNCHANGED;
  case FLegendLayout of
    gllPercentage : iTmp := PE_GLL_PERCENTAGE;
    gllAmount     : iTmp := PE_GLL_AMOUNT;
    gllCustom     : iTmp := PE_GLL_CUSTOM;
  end;

  if GrOptionInfo.legendLayout <> iTmp then
  begin
    GrOptionInfo.legendLayout := iTmp;
    {Send the GraphOptionInfo to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetLegendLayout <PESetGraphOptionInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetOptionInfo                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphOptionInfo.GetOptionInfo;
var
  GrOptionInfo : PEGraphOptionInfo;
  SectionCode  : Smallint;
  nGraph       : integer;
begin
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphOptionInfo.GetOptionInfo <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphOptionInfo}
  
  if Cr.FCrpeEngine.PEGetGraphOptionInfo(Cr.FPrintJob, SectionCode, nGraph, GrOptionInfo) then
  begin
    {GraphColor}
    FColor := gcColor;
    case GrOptionInfo.graphColor of
      PE_GCR_COLORCHART         : FColor := gcColor;
      PE_GCR_BLACKANDWHITECHART : FColor := gcMonochrome;
    end;
    {ShowLegend and LegendPosition}
    FLegend := glRight;
    case GrOptionInfo.showLegend of
      0: FLegend := glNone;
      1: begin
           case GrOptionInfo.legendPosition of
             PE_GLP_PLACEUPPERRIGHT   : FLegend := glUpperright;
             PE_GLP_PLACEBOTTOMCENTER : FLegend := glBottomCenter;
             PE_GLP_PLACETOPCENTER    : FLegend := glTopCenter;
             PE_GLP_PLACERIGHT        : FLegend := glRight;
             PE_GLP_PLACELEFT         : FLegend := glLeft;
           end;
         end;
    end;
    {PieSize}
    FPieSize := gpsAverage;
    case GrOptionInfo.pieSize of
      PE_GPS_MINIMUMPIESIZE : FPieSize := gpsMinimum;
      PE_GPS_SMALLPIESIZE   : FPieSize := gpsSmall;
      PE_GPS_AVERAGEPIESIZE : FPieSize := gpsAverage;
      PE_GPS_LARGEPIESIZE   : FPieSize := gpsLarge;
      PE_GPS_MAXIMUMPIESIZE : FPieSize := gpsMaximum;
    end;
    {PieSlice}
    FPieSlice := gslNone;
    case GrOptionInfo.detachedPieSlice of
      PE_GDPS_NODETACHMENT  : FPieSlice := gslNone;
      PE_GDPS_SMALLESTSLICE : FPieSlice := gslSmall;
      PE_GDPS_LARGESTSLICE  : FPieSlice := gslLarge;
    end;
    {BarSize}
    FBarSize := gbsLarge;
    case GrOptionInfo.barSize of
      PE_GBS_MINIMUMBARSIZE : FBarSize := gbsMinimum;
      PE_GBS_SMALLBARSIZE   : FBarSize := gbsSmall;
      PE_GBS_AVERAGEBARSIZE : FBarSize := gbsAverage;
      PE_GBS_LARGEBARSIZE   : FBarSize := gbsLarge;
      PE_GBS_MAXIMUMBARSIZE : FBarSize := gbsMaximum;
    end;
    {VerticalBars}
    FBarDirection := bdVertical;
    case GrOptionInfo.verticalBars of
      0: FBarDirection := bdHorizontal;
      1: FBarDirection := bdVertical;
    end;
    {MarkerSize}
    FMarkerSize := gmsMedium;
    case GrOptionInfo.markerSize of
      PE_GMS_SMALLMARKERS       : FMarkerSize := gmsSmall;
      PE_GMS_MEDIUMSMALLMARKERS : FMarkerSize := gmsMediumSmall;
      PE_GMS_MEDIUMMARKERS      : FMarkerSize := gmsMedium;
      PE_GMS_MEDIUMLARGEMARKERS : FMarkerSize := gmsMediumLarge;
      PE_GMS_LARGEMARKERS       : FMarkerSize := gmsLarge;
    end;
    {MarkerShape}
    FMarkerShape := gshRectangle;
    case GrOptionInfo.markerShape of
      PE_GMSP_RECTANGLESHAPE : FMarkerShape := gshRectangle;
      PE_GMSP_CIRCLESHAPE    : FMarkerShape := gshCircle;
      PE_GMSP_DIAMONDSHAPE   : FMarkerShape := gshDiamond;
      PE_GMSP_TRIANGLESHAPE  : FMarkerShape := gshTriangle;
    end;
    {DataPoints}
    FDataPoints := gdpNone;
    case GrOptionInfo.dataPoints of
      PE_GDP_NONE      : FDataPoints := gdpNone;
      PE_GDP_SHOWLABEL : FDataPoints := gdpShowLabel;
      PE_GDP_SHOWVALUE : FDataPoints := gdpShowValue;
      PE_GDP_SHOWLABELVALUE : FDataPoints := gdpShowLabelValue;
    end;
    {NumberFormat}
    FNumberFormat := gnfNoDecimal;
    case GrOptionInfo.dataValueNumberFormat of
      PE_GNF_NODECIMAL          : FNumberFormat := gnfNoDecimal;
      PE_GNF_ONEDECIMAL         : FNumberFormat := gnfOneDecimal;
      PE_GNF_TWODECIMAL         : FNumberFormat := gnfTwoDecimal;
      PE_GNF_UNKNOWNTYPE        : FNumberFormat := gnfUnknownType;
      PE_GNF_CURRENCYTWODECIMAL : FNumberFormat := gnfCurrencyTwoDecimal;
      PE_GNF_PERCENTNODECIMAL   : FNumberFormat := gnfPercentNoDecimal;
      PE_GNF_PERCENTONEDECIMAL  : FNumberFormat := gnfPercentOneDecimal;
      PE_GNF_PERCENTTWODECIMAL  : FNumberFormat := gnfPercentTwoDecimal;
      PE_GNF_OTHER              : FNumberFormat := gnfOther;
    end;
    {ViewingAngle}
    FViewingAngle := gvaStandard;
    case GrOptionInfo.viewingAngle of
      PE_GVA_STANDARDVIEW      : FViewingAngle := gvaStandard;
      PE_GVA_TALLVIEW          : FViewingAngle := gvaTall;
      PE_GVA_TOPVIEW           : FViewingAngle := gvaTop;
      PE_GVA_DISTORTEDVIEW     : FViewingAngle := gvaDistorted;
      PE_GVA_SHORTVIEW         : FViewingAngle := gvaShort;
      PE_GVA_GROUPEYEVIEW      : FViewingAngle := gvaGroupEye;
      PE_GVA_GROUPEMPHASISVIEW : FViewingAngle := gvaGroupEmphasis;
      PE_GVA_FEWSERIESVIEW     : FViewingAngle := gvaFewSeries;
      PE_GVA_FEWGROUPSVIEW     : FViewingAngle := gvaFewGroups;
      PE_GVA_DISTORTEDSTDVIEW  : FViewingAngle := gvaDistortedStd;
      PE_GVA_THICKGROUPSVIEW   : FViewingAngle := gvaThickGroups;
      PE_GVA_SHORTERVIEW       : FViewingAngle := gvaShorter;
      PE_GVA_THICKSERIESVIEW   : FViewingAngle := gvaThickSeries;
      PE_GVA_THICKSTDVIEW      : FViewingAngle := gvaThickStd;
      PE_GVA_BIRDSEYEVIEW      : FViewingAngle := gvaBirdsEye;
      PE_GVA_MAXVIEW           : FViewingAngle := gvaMax;
    end;
    {ViewingAngle}
    FLegendLayout := gllPercentage;
    case GrOptionInfo.legendLayout of
      PE_GLL_PERCENTAGE : FLegendLayout := gllPercentage;
      PE_GLL_AMOUNT     : FLegendLayout := gllAmount;
      PE_GLL_CUSTOM     : FLegendLayout := gllCustom;
    end;
  end;
end;


{******************************************************************************}
{ Class TCrpeGraphAxis                                                         }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGraphAxis.Create;
begin
  inherited Create;
  { Grid Lines }
  FGridLineX        := gglNone;
  FGridLineY        := gglMajor;
  FGridLineY2       := gglNone;
  FGridLineZ        := gglNone;
  { Auto Range }
  FDataValuesY      := gdvAutomatic;
  FDataValuesY2     := gdvAutomatic;
  FDataValuesZ      := gdvAutomatic;
  { Min/Max Values }
  FMinY             := -1;
  FMaxY             := -1;
  FMinY2            := -1;
  FMaxY2            := -1;
  FMinZ             := -1;
  FMaxZ             := -1;
  { Number Format }
  FNumberFormatY    := gnfNoDecimal;
  FNumberFormatY2   := gnfNoDecimal;
  FNumberFormatZ    := gnfNoDecimal;
  { Automatic Division }
  FDivisionTypeY    := gdvAutomatic;
  FDivisionTypeY2   := gdvAutomatic;
  FDivisionTypeZ    := gdvAutomatic;
  { Manual Division }
  FDivisionsY       := -1;
  FDivisionsY2      := -1;
  FDivisionsZ       := -1;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.Assign(Source: TPersistent);
begin
  if Source is TCrpeGraphAxis then
  begin
    { Grid Lines }
    GridLineX        := TCrpeGraphAxis(Source).GridLineX;
    GridLineY        := TCrpeGraphAxis(Source).GridLineY;
    GridLineY2       := TCrpeGraphAxis(Source).GridLineY2;
    GridLineZ        := TCrpeGraphAxis(Source).GridLineZ;
    { Auto Range }
    DataValuesY      := TCrpeGraphAxis(Source).DataValuesY;
    DataValuesY2     := TCrpeGraphAxis(Source).DataValuesY2;
    DataValuesZ      := TCrpeGraphAxis(Source).DataValuesZ;
    { Min/Max Values }
    MinY             := TCrpeGraphAxis(Source).MinY;
    MaxY             := TCrpeGraphAxis(Source).MaxY;
    MinY2            := TCrpeGraphAxis(Source).MinY2;
    MaxY2            := TCrpeGraphAxis(Source).MaxY2;
    MinZ             := TCrpeGraphAxis(Source).MinZ;
    MaxZ             := TCrpeGraphAxis(Source).MaxZ;
    { Number Format }
    NumberFormatY    := TCrpeGraphAxis(Source).NumberFormatY;
    NumberFormatY2   := TCrpeGraphAxis(Source).NumberFormatY2;
    NumberFormatZ    := TCrpeGraphAxis(Source).NumberFormatZ;
    { Automatic Division }
    DivisionTypeY    := TCrpeGraphAxis(Source).DivisionTypeY;
    DivisionTypeY2   := TCrpeGraphAxis(Source).DivisionTypeY2;
    DivisionTypeZ    := TCrpeGraphAxis(Source).DivisionTypeZ;
    { Manual Division }
    DivisionsY       := TCrpeGraphAxis(Source).DivisionsY;
    DivisionsY2      := TCrpeGraphAxis(Source).DivisionsY2;
    DivisionsZ       := TCrpeGraphAxis(Source).DivisionsZ;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex            := -1;
    Handle            := 0;
    { Grid Lines }
    FGridLineX        := gglNone;
    FGridLineY        := gglMajor;
    FGridLineY2       := gglNone;
    FGridLineZ        := gglNone;
    { Auto Range }
    FDataValuesY      := gdvAutomatic;
    FDataValuesY2     := gdvAutomatic;
    FDataValuesZ      := gdvAutomatic;
    { Min/Max Values }
    FMinY             := -1;
    FMaxY             := -1;
    FMinY2            := -1;
    FMaxY2            := -1;
    FMinZ             := -1;
    FMaxZ             := -1;
    { Number Format }
    FNumberFormatY    := gnfNoDecimal;
    FNumberFormatY2   := gnfNoDecimal;
    FNumberFormatZ    := gnfNoDecimal;
    { Automatic Division }
    FDivisionTypeY    := gdvAutomatic;
    FDivisionTypeY2   := gdvAutomatic;
    FDivisionTypeZ    := gdvAutomatic;
    { Manual Division }
    FDivisionsY       := -1;
    FDivisionsY2      := -1;
    FDivisionsZ       := -1;
  end;
end;
{------------------------------------------------------------------------------}
{ SetGridLineX                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetGridLineX (const Value: TCrGraphGridLines);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
  iTmp           : integer;
begin
  FGridLineX := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetGridLineX <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetGridLineX <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {GridLines}
  iTmp := PE_UNCHANGED;
  case FGridLineX of
    gglNone          : iTmp := PE_GGT_NOGRIDLINES;
    gglMinor         : iTmp := PE_GGT_MINORGRIDLINES;
    gglMajor         : iTmp := PE_GGT_MAJORGRIDLINES;
    gglMajorAndMinor : iTmp := PE_GGT_MAJORANDMINORGRIDLINES;
  end;
  if GraphAxisInfo.groupAxisGridLine <> iTmp then
  begin
    GraphAxisInfo.groupAxisGridLine := iTmp;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetGridLineX <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetGridLineY                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetGridLineY (const Value: TCrGraphGridLines);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
  iTmp           : integer;
begin
  FGridLineY := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetGridLineY <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetGridLineY <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {GridLines}
  iTmp := PE_UNCHANGED;
  case FGridLineY of
    gglNone          : iTmp := PE_GGT_NOGRIDLINES;
    gglMinor         : iTmp := PE_GGT_MINORGRIDLINES;
    gglMajor         : iTmp := PE_GGT_MAJORGRIDLINES;
    gglMajorAndMinor : iTmp := PE_GGT_MAJORANDMINORGRIDLINES;
  end;
  if GraphAxisInfo.dataAxisYGridLine <> iTmp then
  begin
    GraphAxisInfo.dataAxisYGridLine := iTmp;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetGridLineY <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetGridLineY2                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetGridLineY2 (const Value: TCrGraphGridLines);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
  iTmp           : integer;
begin
  FGridLineY2 := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetGridLineY2 <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetGridLineY2 <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {GridLines}
  iTmp := PE_UNCHANGED;
  case FGridLineY2 of
    gglNone          : iTmp := PE_GGT_NOGRIDLINES;
    gglMinor         : iTmp := PE_GGT_MINORGRIDLINES;
    gglMajor         : iTmp := PE_GGT_MAJORGRIDLINES;
    gglMajorAndMinor : iTmp := PE_GGT_MAJORANDMINORGRIDLINES;
  end;
  if GraphAxisInfo.dataAxisY2GridLine <> iTmp then
  begin
    GraphAxisInfo.dataAxisY2GridLine := iTmp;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetGridLineY2 <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetGridLineZ                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetGridLineZ (const Value: TCrGraphGridLines);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
  iTmp           : integer;
begin
  FGridLineZ := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetGridLineZ <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetGridLineZ <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {GridLines}
  iTmp := PE_UNCHANGED;
  case FGridLineZ of
    gglNone          : iTmp := PE_GGT_NOGRIDLINES;
    gglMinor         : iTmp := PE_GGT_MINORGRIDLINES;
    gglMajor         : iTmp := PE_GGT_MAJORGRIDLINES;
    gglMajorAndMinor : iTmp := PE_GGT_MAJORANDMINORGRIDLINES;
  end;
  if GraphAxisInfo.seriesAxisGridline <> iTmp then
  begin
    GraphAxisInfo.seriesAxisGridline := iTmp;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetGridLineZ <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDataValuesY                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetDataValuesY (const Value: TCrGraphDVType);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
  iTmp           : integer;
begin
  FDataValuesY := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetDataValuesY <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetDataValuesY <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {DataValues - AutoRange}
  iTmp := Ord(FDataValuesY);
  if iTmp = 2 then
    iTmp := 0
  else
    iTmp := 1;
  if GraphAxisInfo.dataAxisYAutoRange <> iTmp then
  begin
    GraphAxisInfo.dataAxisYAutoRange := iTmp;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetDataValuesY <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDataValuesY2                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetDataValuesY2 (const Value: TCrGraphDVType);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
  iTmp           : integer;
begin
  FDataValuesY2 := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetDataValuesY2 <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetDataValuesY2 <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {DataValues - AutoRange}
  iTmp := Ord(FDataValuesY2);
  if iTmp = 2 then
    iTmp := 0
  else
    iTmp := 1;
  if GraphAxisInfo.dataAxisY2AutoRange <> iTmp then
  begin
    GraphAxisInfo.dataAxisY2AutoRange := iTmp;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetDataValuesY2 <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDataValuesZ                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetDataValuesZ (const Value: TCrGraphDVType);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
  iTmp           : integer;
begin
  FDataValuesZ := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetDataValuesZ <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetDataValuesZ <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {DataValues - AutoRange}
  iTmp := Ord(FDataValuesY2);
  if iTmp = 2 then
    iTmp := 0
  else
    iTmp := 1;
  if GraphAxisInfo.dataAxisY2AutoRange <> iTmp then
  begin
    GraphAxisInfo.dataAxisY2AutoRange := iTmp;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetDataValuesZ <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetMinY                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetMinY (const Value: Double);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
begin
  FMinY := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetMinY <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetMinY <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Min/Max}
  if GraphAxisInfo.dataAxisYMinValue <> FMinY then
  begin
    GraphAxisInfo.dataAxisYMinValue := FMinY;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetMinY <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetMaxY                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetMaxY (const Value: Double);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
begin
  FMaxY := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetMaxY <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetMaxY <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Min/Max}
  if GraphAxisInfo.dataAxisYMaxValue <> FMaxY then
  begin
    GraphAxisInfo.dataAxisYMaxValue := FMaxY;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetMaxY <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetMinY2                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetMinY2 (const Value: Double);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
begin
  FMinY2 := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetMinY2 <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetMinY2 <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Min/Max}
  if GraphAxisInfo.dataAxisY2MinValue <> FMinY2 then
  begin
    GraphAxisInfo.dataAxisY2MinValue := FMinY2;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetMinY2 <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetMaxY2                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetMaxY2 (const Value: Double);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
begin
  FMaxY2 := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetMaxY2 <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetMaxY2 <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Min/Max}
  if GraphAxisInfo.dataAxisY2MaxValue <> FMaxY2 then
  begin
    GraphAxisInfo.dataAxisY2MaxValue := FMaxY2;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetMaxY2 <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetMinZ                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetMinZ (const Value: Double);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
begin
  FMinZ := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetMinZ <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetMinZ <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Min/Max}
  if GraphAxisInfo.seriesAxisMinValue <> FMinZ then
  begin
    GraphAxisInfo.seriesAxisMinValue := FMinZ;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetMinZ <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetMaxZ                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetMaxZ (const Value: Double);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
begin
  FMaxZ := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetMaxZ <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetMaxZ <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Min/Max}
  if GraphAxisInfo.seriesAxisMaxValue <> FMaxZ then
  begin
    GraphAxisInfo.seriesAxisMaxValue := FMaxZ;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetMaxZ <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetNumberFormatY                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetNumberFormatY (const Value: TCrGraphNumberFormat);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
  iTmp           : integer;
begin
  FNumberFormatY := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetNumberFormatY <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetNumberFormatY <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {NumberFormat}
  iTmp := PE_UNCHANGED;
  case FNumberFormatY of
    gnfNoDecimal          : iTmp := PE_GNF_NODECIMAL;
    gnfOneDecimal         : iTmp := PE_GNF_ONEDECIMAL;
    gnfTwoDecimal         : iTmp := PE_GNF_TWODECIMAL;
    gnfUnknownType        : iTmp := PE_GNF_UNKNOWNTYPE;
    gnfCurrencyTwoDecimal : iTmp := PE_GNF_CURRENCYTWODECIMAL;
    gnfPercentNoDecimal   : iTmp := PE_GNF_PERCENTNODECIMAL;
    gnfPercentOneDecimal  : iTmp := PE_GNF_PERCENTONEDECIMAL;
    gnfPercentTwoDecimal  : iTmp := PE_GNF_PERCENTTWODECIMAL;
    gnfOther              : iTmp := PE_GNF_OTHER;
  end;
  if GraphAxisInfo.dataAxisYNumberFormat <> iTmp then
  begin
    GraphAxisInfo.dataAxisYNumberFormat := iTmp;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetNumberFormatY <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetNumberFormatY2                                                            }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetNumberFormatY2 (const Value: TCrGraphNumberFormat);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
  iTmp           : integer;
begin
  FNumberFormatY2 := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetNumberFormatY2 <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetNumberFormatY2 <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {NumberFormat}
  iTmp := PE_UNCHANGED;
  case FNumberFormatY2 of
    gnfNoDecimal          : iTmp := PE_GNF_NODECIMAL;
    gnfOneDecimal         : iTmp := PE_GNF_ONEDECIMAL;
    gnfTwoDecimal         : iTmp := PE_GNF_TWODECIMAL;
    gnfUnknownType        : iTmp := PE_GNF_UNKNOWNTYPE;
    gnfCurrencyTwoDecimal : iTmp := PE_GNF_CURRENCYTWODECIMAL;
    gnfPercentNoDecimal   : iTmp := PE_GNF_PERCENTNODECIMAL;
    gnfPercentOneDecimal  : iTmp := PE_GNF_PERCENTONEDECIMAL;
    gnfPercentTwoDecimal  : iTmp := PE_GNF_PERCENTTWODECIMAL;
    gnfOther              : iTmp := PE_GNF_OTHER;  
  end;
  if GraphAxisInfo.dataAxisY2NumberFormat <> iTmp then
  begin
    GraphAxisInfo.dataAxisY2NumberFormat := iTmp;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetNumberFormatY2 <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetNumberFormatZ                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetNumberFormatZ (const Value: TCrGraphNumberFormat);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
  iTmp           : integer;
begin
  FNumberFormatZ := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetNumberFormatZ <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetNumberFormatZ <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {NumberFormat}
  iTmp := PE_UNCHANGED;
  case FNumberFormatZ of
    gnfNoDecimal          : iTmp := PE_GNF_NODECIMAL;
    gnfOneDecimal         : iTmp := PE_GNF_ONEDECIMAL;
    gnfTwoDecimal         : iTmp := PE_GNF_TWODECIMAL;
    gnfUnknownType        : iTmp := PE_GNF_UNKNOWNTYPE;
    gnfCurrencyTwoDecimal : iTmp := PE_GNF_CURRENCYTWODECIMAL;
    gnfPercentNoDecimal   : iTmp := PE_GNF_PERCENTNODECIMAL;
    gnfPercentOneDecimal  : iTmp := PE_GNF_PERCENTONEDECIMAL;
    gnfPercentTwoDecimal  : iTmp := PE_GNF_PERCENTTWODECIMAL;
    gnfOther              : iTmp := PE_GNF_OTHER;  
  end;
  if GraphAxisInfo.seriesAxisNumberFormat <> iTmp then
  begin
    GraphAxisInfo.seriesAxisNumberFormat := iTmp;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetNumberFormatZ <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDivisionTypeY                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetDivisionTypeY (const Value: TCrGraphDVType);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
  iTmp           : integer;
begin
  FDivisionTypeY := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetDivisionTypeY <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetDivisionTypeY <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Automatic Division}
  iTmp := Ord(FDivisionTypeY);
  if iTmp = 2 then
    iTmp := PE_ADM_MANUAL
  else
    iTmp := PE_ADM_AUTOMATIC;
  if GraphAxisInfo.dataAxisYAutomaticDivision <> iTmp then
  begin
    GraphAxisInfo.dataAxisYAutomaticDivision := iTmp;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetDivisionTypeY <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDivisionTypeY2                                                            }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetDivisionTypeY2 (const Value: TCrGraphDVType);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
  iTmp           : integer;
begin
  FDivisionTypeY2 := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetDivisionTypeY2 <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetDivisionTypeY2 <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Automatic Division}
  iTmp := Ord(FDivisionTypeY2);
  if iTmp = 2 then
    iTmp := PE_ADM_MANUAL
  else
    iTmp := PE_ADM_AUTOMATIC;
  if GraphAxisInfo.dataAxisY2AutomaticDivision <> iTmp then
  begin
    GraphAxisInfo.dataAxisY2AutomaticDivision := iTmp;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetDivisionTypeY2 <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDivisionTypeZ                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetDivisionTypeZ (const Value: TCrGraphDVType);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
  iTmp           : integer;
begin
  FDivisionTypeZ := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetDivisionTypeZ <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetDivisionTypeZ <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Automatic Division}
  iTmp := Ord(FDivisionTypeZ);
  if iTmp = 2 then
    iTmp := PE_ADM_MANUAL
  else
    iTmp := PE_ADM_AUTOMATIC;
  if GraphAxisInfo.seriesAxisAutomaticDivision <> iTmp then
  begin
    GraphAxisInfo.seriesAxisAutomaticDivision := iTmp;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetDivisionTypeZ <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDivisionsY                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetDivisionsY (const Value: LongInt);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
begin
  FDivisionsY := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetDivisionsY <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetDivisionsY <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Manual Division}
  if GraphAxisInfo.dataAxisYManualDivision <> FDivisionsY then
  begin
    GraphAxisInfo.dataAxisYManualDivision := FDivisionsY;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetDivisionsY <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDivisionsY2                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetDivisionsY2 (const Value: LongInt);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
begin
  FDivisionsY2 := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetDivisionsY2 <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetDivisionsY2 <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Manual Division}
  if GraphAxisInfo.dataAxisY2ManualDivision <> FDivisionsY2 then
  begin
    GraphAxisInfo.dataAxisY2ManualDivision := FDivisionsY2;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetDivisionsY2 <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDivisionsZ                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.SetDivisionsZ (const Value: LongInt);
var
  nGraph         : Smallint;
  SectionCode    : Smallint;
  GraphAxisInfo  : PEGraphAxisInfo;
begin
  FDivisionsZ := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.SetDivisionsZ <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis from Report}
  
  if not Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'GraphAxis.SetDivisionsZ <PEGetGraphAxisInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Manual Division}
  if GraphAxisInfo.seriesAxisManualDivision <> FDivisionsZ then
  begin
    GraphAxisInfo.seriesAxisManualDivision := FDivisionsZ;
    {Send the GraphAxis to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphAxis.SetDivisionsZ <PESetGraphAxisInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetAxis                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeGraphAxis.GetAxis;
var
  GraphAxisInfo : PEGraphAxisInfo;
  SectionCode   : Smallint;
  nGraph        : Smallint;

  procedure SetGridLine(iRpt: Smallint; var glVCL: TCrGraphGridLines);
  begin
    glVCL := gglNone;
    case iRpt of
      PE_GGT_NOGRIDLINES            : glVCL := gglNone;
      PE_GGT_MINORGRIDLINES         : glVCL := gglMinor;
      PE_GGT_MAJORGRIDLINES         : glVCL := gglMajor;
      PE_GGT_MAJORANDMINORGRIDLINES : glVCL := gglMajorAndMinor;
    end;
  end;

  procedure SetDataValues(iRpt: Smallint; var dvVCL: TCrGraphDVType);
  begin
    dvVCL := gdvAutomatic;
    case iRpt of
      0 : dvVCL := gdvManual;
      1 : dvVCL := gdvAutomatic;
    end;
  end;

  procedure SetNumberFormat(iRpt: Smallint; var nfVCL: TCrGraphNumberFormat);
  begin
    nfVCL := gnfNoDecimal;
    case iRpt of
      PE_GNF_NODECIMAL          : nfVCL := gnfNoDecimal;
      PE_GNF_ONEDECIMAL         : nfVCL := gnfOneDecimal;
      PE_GNF_TWODECIMAL         : nfVCL := gnfTwoDecimal;
      PE_GNF_UNKNOWNTYPE        : nfVCL := gnfUnknownType;
      PE_GNF_CURRENCYTWODECIMAL : nfVCL := gnfCurrencyTwoDecimal;
      PE_GNF_PERCENTNODECIMAL   : nfVCL := gnfPercentNoDecimal;
      PE_GNF_PERCENTONEDECIMAL  : nfVCL := gnfPercentOneDecimal;
      PE_GNF_PERCENTTWODECIMAL  : nfVCL := gnfPercentTwoDecimal;
      PE_GNF_OTHER              : nfVCL := gnfOther;
    end;
  end;

  procedure SetAutomaticDivision(iRpt: Smallint; var adVCL: TCrGraphDVType);
  begin
    adVCL := gdvAutomatic;
    case iRpt of
      PE_ADM_AUTOMATIC : adVCL := gdvAutomatic;
      PE_ADM_MANUAL    : adVCL := gdvManual;
    end;
  end;

begin
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Number}
  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphAxis.GetAxis <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get GraphAxis}
  
  if Cr.FCrpeEngine.PEGetGraphAxisInfo(Cr.FPrintJob, SectionCode, nGraph, GraphAxisInfo) then
  begin
    {GridLines}
    SetGridLine(GraphAxisInfo.groupAxisGridLine, FGridLineX);
    SetGridLine(GraphAxisInfo.dataAxisYGridLine, FGridLineY);
    SetGridLine(GraphAxisInfo.dataAxisY2GridLine, FGridLineY2);
    SetGridLine(GraphAxisInfo.seriesAxisGridLine, FGridLineZ);
    {DataValues - AutoRange}
    SetDataValues(GraphAxisInfo.dataAxisYAutoRange, FDataValuesY);
    SetDataValues(GraphAxisInfo.dataAxisY2AutoRange, FDataValuesY2);
    SetDataValues(GraphAxisInfo.seriesAxisAutoRange, FDataValuesZ);
    {Min/Max}
    FMinY  := GraphAxisInfo.dataAxisYMinValue;
    FMaxY  := GraphAxisInfo.dataAxisYMaxValue;
    FMinY2 := GraphAxisInfo.dataAxisY2MinValue;
    FMaxY2 := GraphAxisInfo.dataAxisY2MaxValue;
    FMinZ  := GraphAxisInfo.seriesAxisMinValue;
    FMaxZ  := GraphAxisInfo.seriesAxisMaxValue;
    {NumberFormat}
    SetNumberFormat(GraphAxisInfo.dataAxisYNumberFormat, FNumberFormatY);
    SetNumberFormat(GraphAxisInfo.dataAxisY2NumberFormat, FNumberFormatY2);
    SetNumberFormat(GraphAxisInfo.seriesAxisNumberFormat, FNumberFormatZ);
    {Automatic Division}
    SetAutomaticDivision(GraphAxisInfo.dataAxisYAutomaticDivision, FDivisionTypeY);
    SetAutomaticDivision(GraphAxisInfo.dataAxisY2AutomaticDivision, FDivisionTypeY2);
    SetAutomaticDivision(GraphAxisInfo.seriesAxisAutomaticDivision, FDivisionTypeZ);
    {Manual Division}
    FDivisionsY  := GraphAxisInfo.dataAxisYManualDivision;
    FDivisionsY2 := GraphAxisInfo.dataAxisY2ManualDivision;
    FDivisionsZ  := GraphAxisInfo.seriesAxisManualDivision;
  end;
end;


{******************************************************************************}
{ Class TCrpeGraphText                                                         }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeGraphText.Create;
begin
  inherited Create;
  FTitle            := '';
  FSubTitle         := '';
  FFootNote         := '';
  FGroupsTitle      := '';
  FSeriesTitle      := '';
  FXAxisTitle       := '';
  FYAxisTitle       := '';
  FZAxisTitle       := '';
  FTitleFont        := TCrpeFont.Create;
  FSubTitleFont     := TCrpeFont.Create;
  FFootNoteFont     := TCrpeFont.Create;
  FGroupsTitleFont  := TCrpeFont.Create;
  FDataTitleFont    := TCrpeFont.Create;
  FLegendFont       := TCrpeFont.Create;
  FGroupLabelsFont  := TCrpeFont.Create;
  FDataLabelsFont   := TCrpeFont.Create;
  xFont             := TCrpeFont.Create;
  {OnChange events - when TFont changes we need to send changes to CRPE}
  FTitleFont.OnChange       := OnChangeTitleFont;
  FSubTitleFont.OnChange    := OnChangeSubTitleFont;
  FFootNoteFont.OnChange    := OnChangeFootNoteFont;
  FDataTitleFont.OnChange   := OnChangeDataTitleFont;
  FLegendFont.OnChange      := OnChangeLegendFont;
  FGroupLabelsFont.OnChange := OnChangeGroupLabelsFont;
  FDataLabelsFont.OnChange  := OnChangeDataLabelsFont;
  FTitleFont.OnChange       := OnChangeTitleFont;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeGraphText.Destroy;
begin
  FTitleFont.OnChange := nil;
  FSubTitleFont.OnChange := nil;
  FFootNoteFont.OnChange := nil;
  FGroupsTitleFont.OnChange := nil;
  FDataTitleFont.OnChange := nil;
  FLegendFont.OnChange := nil;
  FGroupLabelsFont.OnChange := nil;
  FDataLabelsFont.OnChange := nil;
  FTitleFont.Free;
  FSubTitleFont.Free;
  FFootNoteFont.Free;
  FGroupsTitleFont.Free;
  FDataTitleFont.Free;
  FLegendFont.Free;
  FGroupLabelsFont.Free;
  FDataLabelsFont.Free;
  xFont.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.Assign(Source: TPersistent);
begin
  if Source is TCrpeGraphText then
  begin
    Title       := TCrpeGraphText(Source).Title;
    SubTitle    := TCrpeGraphText(Source).SubTitle;
    FootNote    := TCrpeGraphText(Source).FootNote;
    GroupsTitle := TCrpeGraphText(Source).GroupsTitle;
    SeriesTitle := TCrpeGraphText(Source).SeriesTitle;
    XAxisTitle  := TCrpeGraphText(Source).XAxisTitle;
    YAxisTitle  := TCrpeGraphText(Source).YAxisTitle;
    ZAxisTitle  := TCrpeGraphText(Source).ZAxisTitle;
    TitleFont.Assign(TCrpeGraphText(Source).TitleFont);
    SubTitleFont.Assign(TCrpeGraphText(Source).SubTitleFont);
    FootNoteFont.Assign(TCrpeGraphText(Source).FootNoteFont);
    GroupsTitleFont.Assign(TCrpeGraphText(Source).GroupsTitleFont);
    DataTitleFont.Assign(TCrpeGraphText(Source).DataTitleFont);
    LegendFont.Assign(TCrpeGraphText(Source).LegendFont);
    GroupLabelsFont.Assign(TCrpeGraphText(Source).GroupLabelsFont);
    DataLabelsFont.Assign(TCrpeGraphText(Source).DataLabelsFont);
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex                := -1;
    Handle                := 0;
    FTitle                := '';
    FSubTitle             := '';
    FFootNote             := '';
    FGroupsTitle          := '';
    FSeriesTitle          := '';
    FXAxisTitle           := '';
    FYAxisTitle           := '';
    FZAxisTitle           := '';
    FTitleFont.Name       := '';
    FSubTitleFont.Name    := '';
    FFootNoteFont.Name    := '';
    FGroupsTitleFont.Name := '';
    FDataTitleFont.Name   := '';
    FLegendFont.Name      := '';
    FGroupLabelsFont.Name := '';
    FDataLabelsFont.Name  := '';
    FTitleFont.Size       := 0;
    FSubTitleFont.Size    := 0;
    FFootNoteFont.Size    := 0;
    FGroupsTitleFont.Size := 0;
    FDataTitleFont.Size   := 0;
    FLegendFont.Size      := 0;
    FGroupLabelsFont.Size := 0;
    FDataLabelsFont.Size  := 0;
  end
  else
  begin
    SetTitle('');
    SetSubTitle('');
    SetFootNote('');
    SetGroupsTitle('');
    SetSeriesTitle('');
    SetXAxisTitle('');
    SetYAxisTitle('');
    SetZAxisTitle('');
  end;
end;
{------------------------------------------------------------------------------}
{ CompareFonts                                                                 }
{  - Compares Font info from Report and VCL to see if changed                  }
{------------------------------------------------------------------------------}
function TCrpeGraphText.CompareFonts(RptFontInfo: PEFontColorInfo;
  var RptFont: TCrpeFont; FontArea: Word): Boolean;
var
  xFont : TCrpeFont;
begin
  Result := False;
  {Store the Report settings}
  RptFont.Name := String(RptFontInfo.faceName);
  RptFont.Charset := RptFontInfo.charSet;
  {Font Color}
  if RptFontInfo.color = PE_NO_COLOR then
    RptFont.Color := clNone
  else
    RptFont.Color := TColor(RptFontInfo.color);
  RptFont.Pitch := TFontPitch(RptFontInfo.fontPitch);
  RptFont.Size := RptFontInfo.pointSize;
  RptFont.ActualSize := TwipsToPoints(RptFontInfo.twipSize);
  RptFont.Style := [];
  if RptFontInfo.isItalic <> 0 then
    RptFont.Style := RptFont.Style + [fsItalic];
  if RptFontInfo.isStruckOut <> 0 then
    RptFont.Style := RptFont.Style + [fsStrikeOut];
  if RptFontInfo.isUnderlined <> 0 then
    RptFont.Style := RptFont.Style + [fsUnderline];
  if RptFontInfo.weight > FW_NORMAL then
    RptFont.Style := RptFont.Style + [fsBold];
  {We ignore RptFontInfo.FontFamily}

  {Get VCL Font settings}
  case FontArea of
    PE_GTF_TITLEFONT       : xFont := FTitleFont;
    PE_GTF_SUBTITLEFONT    : xFont := FSubTitleFont;
    PE_GTF_FOOTNOTEFONT    : xFont := FFootNoteFont;
    PE_GTF_GROUPSTITLEFONT : xFont := FGroupsTitleFont;
    PE_GTF_DATATITLEFONT   : xFont := FDataTitleFont;
    PE_GTF_LEGENDFONT      : xFont := FLegendFont;
    PE_GTF_GROUPLABELSFONT : xFont := FGroupLabelsFont;
    PE_GTF_DATALABELSFONT  : xFont := FDataLabelsFont;
    else
      xFont := FTitleFont;
  end;

  {Compare VCL and Rpt settings}
  {Name}
  if xFont.Name <> RptFont.Name then
    Result := True;
  {CharSet}
  if xFont.Charset <> RptFont.Charset then
    Result := True;
  {Color}
  if xFont.Color <> RptFont.Color then
    Result := True;
  {Pitch}
  if xFont.Pitch <> RptFont.Pitch then
    Result := True;
  {Size}
  if xFont.Size <> 0 then
  begin
    if xFont.Size <> RptFont.Size then
      Result := True;
  end;
  {Size}
  if xFont.ActualSize <> 0 then
  begin
    if xFont.ActualSize <> RptFont.ActualSize then
      Result := True;
  end;
  {Style}
  if xFont.Style <> RptFont.Style then
    Result := True;
end;
{------------------------------------------------------------------------------}
{ CopyFontInfo                                                                 }
{  - Copies font information from VCL's TCrpeFont to PEFontColorInfo           }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.CopyFontInfo(var FontInfo: PEFontColorInfo;
  VCLFont: TCrpeFont);
begin
  {Name}
  StrPCopy(FontInfo.faceName, VCLFont.Name);
  {Family - No equivalent in TFont}
  FontInfo.fontFamily := FF_DONTCARE;
  {Pitch}
  FontInfo.fontPitch := Ord(VCLFont.Pitch);
  {Charset - only applies in Delphi 3 and higher}
  FontInfo.charSet := VCLFont.Charset;
  {Size}
  FontInfo.pointSize := VCLFont.Size;
  {Style: Italic, Underline, StrikeOut, Bold(weight)}
  if fsItalic in VCLFont.Style then
    FontInfo.isItalic := 1
  else
    FontInfo.isItalic := 0;
  if fsUnderline in VCLFont.Style then
    FontInfo.isUnderlined := 1
  else
    FontInfo.isUnderlined := 0;
  if fsStrikeOut in VCLFont.Style then
    FontInfo.isStruckOut := 1
  else
    FontInfo.isStruckOut := 0;
  if fsBold in VCLFont.Style then
    FontInfo.weight := FW_BOLD
  else
    FontInfo.weight := FW_NORMAL;
  {Font Color}
  if VCLFont.Color = clNone then
    FontInfo.color := PE_NO_COLOR
  else
    FontInfo.color := ColorToRGB(VCLFont.Color);
  {TwipSize}
  FontInfo.twipSize := PointsToTwips(VCLFont.ActualSize);
end;
{------------------------------------------------------------------------------}
{ SetTitle                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetTitle (const Value: string);
var
  SectionCode : Smallint;
  xTitle      : string;
  hTitle      : Hwnd;
  iTitle      : Smallint;
  pTitle      : PChar;
  nGraph      : Smallint;
begin
  FTitle := Value;
  {Check Length}
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphText.SetTitle <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Retrieve Graph Title}
  
  if Cr.FCrpeEngine.PEGetGraphTextInfo(Cr.FPrintJob, SectionCode, nGraph,
    PE_GTT_TITLE, hTitle, iTitle) then
  begin
    pTitle := StrAlloc(iTitle);
    if not Cr.FCrpeEngine.PEGetHandleString(hTitle, pTitle, iTitle) then
    begin
      StrDispose(pTitle);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphText.SetTitle <PEGetHandleString>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    xTitle := String(pTitle);
    StrDispose(pTitle);
  end;

  {Title}
  if xTitle <> FTitle then
  begin
    xTitle := FTitle;
    {Set the GraphText to the Report}
    {Set Text}
    
    if not Cr.FCrpeEngine.PESetGraphTextInfo(Cr.FPrintJob, SectionCode, nGraph,
      PE_GTT_TITLE, PChar(xTitle)) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphText.SetTitle <PESetGraphTextInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetSubTitle                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetSubTitle (const Value: string);
var
  SectionCode : Smallint;
  xSubTitle   : string;
  hTitle      : Hwnd;
  iTitle      : Smallint;
  pTitle      : PChar;
  nGraph      : Smallint;
begin
  FSubTitle := Value;
  {Check Length}
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphText.SetSubTitle <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  
  if Cr.FCrpeEngine.PEGetGraphTextInfo(Cr.FPrintJob, SectionCode, nGraph,
    PE_GTF_SUBTITLEFONT, hTitle, iTitle) then
  begin
    {Get the Text}
    pTitle := StrAlloc(iTitle);
    if not Cr.FCrpeEngine.PEGetHandleString(hTitle, pTitle, iTitle) then
    begin
      StrDispose(pTitle);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphText.SetSubTitle <PEGetHandleString>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    xSubTitle := String(pTitle);
    StrDispose(pTitle);
  end;

  {SubTitle}
  if xSubTitle <> FSubTitle then
  begin
    xSubTitle := FSubTitle;
    {Set the GraphText to the Report}
    {Set Text}
    
    if not Cr.FCrpeEngine.PESetGraphTextInfo(Cr.FPrintJob, SectionCode, nGraph,
      PE_GTT_SUBTITLE, PChar(xSubTitle)) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphText.SetSubTitle <PESetGraphTextInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetFootNote                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetFootNote (const Value: string);
var
  SectionCode : Smallint;
  xFootNote   : string;
  hTitle      : Hwnd;
  iTitle      : Smallint;
  pTitle      : PChar;
  nGraph      : Smallint;
begin
  FFootNote := Value;
  {Check Length}
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphText.SetFootNote <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  
  if Cr.FCrpeEngine.PEGetGraphTextInfo(Cr.FPrintJob, SectionCode, nGraph,
    PE_GTT_FOOTNOTE, hTitle, iTitle) then
  begin
    {Get the Text}
    pTitle := StrAlloc(iTitle);
    if not Cr.FCrpeEngine.PEGetHandleString(hTitle, pTitle, iTitle) then
    begin
      StrDispose(pTitle);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphText.SetFootNote <PEGetHandleString>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    xFootNote := String(pTitle);
    StrDispose(pTitle);
  end;

  {FootNote}
  if xFootNote <> FFootNote then
  begin
    xFootNote := FFootNote;
    {Set the GraphText to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphTextInfo(Cr.FPrintJob, SectionCode, nGraph,
      PE_GTT_FOOTNOTE, PChar(xFootNote)) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphText.SetFootNote <PESetGraphTextInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetGroupsTitle                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetGroupsTitle (const Value: string);
var
  SectionCode  : Smallint;
  xGroupsTitle : string;
  hTitle       : Hwnd;
  iTitle       : Smallint;
  pTitle       : PChar;
  nGraph       : Smallint;
begin
  FGroupsTitle := Value;
  {Check Length}
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphText.SetGroupsTitle <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  
  if Cr.FCrpeEngine.PEGetGraphTextInfo(Cr.FPrintJob, SectionCode, nGraph,
    PE_GTT_GROUPSTITLE, hTitle, iTitle) then
  begin
    {Get the Text}
    pTitle := StrAlloc(iTitle);
    if not Cr.FCrpeEngine.PEGetHandleString(hTitle, pTitle, iTitle) then
    begin
      StrDispose(pTitle);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphText.SetGroupsTitle <PEGetHandleString>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    xGroupsTitle := String(pTitle);
    StrDispose(pTitle);
  end;

  {GroupsTitle}
  if xGroupsTitle <> FGroupsTitle then
  begin
    xGroupsTitle := FGroupsTitle;
    {Set the GraphText to the Report}
    {Set Text}
    
    if not Cr.FCrpeEngine.PESetGraphTextInfo(Cr.FPrintJob, SectionCode, nGraph,
      PE_GTT_GROUPSTITLE, PChar(xGroupsTitle)) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphText.SetGroupsTitle <PESetGraphTextInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetSeriesTitle                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetSeriesTitle (const Value: string);
var
  SectionCode  : Smallint;
  xSeriesTitle : string;
  hTitle       : Hwnd;
  iTitle       : Smallint;
  pTitle       : PChar;
  nGraph      : Smallint;
begin
  FSeriesTitle := Value;
  {Check Length}
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphText.SetSeriesTitle <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  
  if Cr.FCrpeEngine.PEGetGraphTextInfo(Cr.FPrintJob, SectionCode, nGraph,
    PE_GTT_SERIESTITLE, hTitle, iTitle) then
  begin
    {Get the Text}
    pTitle := StrAlloc(iTitle);
    if not Cr.FCrpeEngine.PEGetHandleString(hTitle, pTitle, iTitle) then
    begin
      StrDispose(pTitle);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphText.SetSeriesTitle <PEGetHandleString>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    xSeriesTitle:= String(pTitle);
    StrDispose(pTitle);
  end;

  {SeriesTitle}
  if xSeriesTitle <> FSeriesTitle then
  begin
    xSeriesTitle := FSeriesTitle;
    {Set the GraphText to the Report}
    {Set Text}
    
    if not Cr.FCrpeEngine.PESetGraphTextInfo(Cr.FPrintJob, SectionCode, nGraph,
      PE_GTT_SERIESTITLE, PChar(xSeriesTitle)) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphText.SetSeriesTitle <PESetGraphTextInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetXAxisTitle                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetXAxisTitle (const Value: string);
var
  SectionCode : Smallint;
  xXAxisTitle : string;
  hTitle          : Hwnd;
  iTitleLen       : Smallint;
  pTitle          : PChar;
  nGraph      : Smallint;
begin
  FXAxisTitle := Value;
  {Check Length}
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphText.SetXAxisTitle <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  
  if Cr.FCrpeEngine.PEGetGraphTextInfo(Cr.FPrintJob, SectionCode, nGraph,
    PE_GTT_XAXISTITLE, hTitle, iTitleLen) then
  begin
    {Get the Text}
    pTitle := StrAlloc(iTitleLen);
    if not Cr.FCrpeEngine.PEGetHandleString(hTitle, pTitle, iTitleLen) then
    begin
      StrDispose(pTitle);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphText.SetXAxisTitle <PEGetHandleString>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    xXAxisTitle := String(pTitle);
    StrDispose(pTitle);
  end;

  {XAxis}
  if xXAxisTitle <> FXAxisTitle then
  begin
    xXAxisTitle := FXAxisTitle;
    {Set the GraphText to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphTextInfo(Cr.FPrintJob, SectionCode, nGraph,
      PE_GTT_XAXISTITLE, PChar(xXAxisTitle)) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphText.SetXAxisTitle <PESetGraphTextInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetYAxisTitle                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetYAxisTitle (const Value: string);
var
  SectionCode : Smallint;
  xYAxisTitle : string;
  hTitle      : Hwnd;
  iTitle      : Smallint;
  pTitle      : PChar;
  nGraph      : Smallint;
begin
  FYAxisTitle := Value;
  {Check Length}
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphText.SetYAxisTitle <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  
  if Cr.FCrpeEngine.PEGetGraphTextInfo(Cr.FPrintJob, SectionCode, nGraph,
    PE_GTT_YAXISTITLE, hTitle, iTitle) then
  begin
    {Get the Text}
    pTitle := StrAlloc(iTitle);
    if not Cr.FCrpeEngine.PEGetHandleString(hTitle, pTitle, iTitle) then
    begin
      StrDispose(pTitle);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphText.SetYAxisTitle <PEGetHandleString>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    xYAxisTitle := String(pTitle);
    StrDispose(pTitle);
  end;

  {YAxis}
  if xYAxisTitle <> FYAxisTitle then
  begin
    xYAxisTitle := FYAxisTitle;
    {Set the GraphText to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphTextInfo(Cr.FPrintJob, SectionCode, nGraph,
      PE_GTT_YAXISTITLE, PChar(xYAxisTitle)) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphText.SetYAxisTitle <PESetGraphTextInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetZAxisTitle                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetZAxisTitle (const Value: string);
var
  SectionCode     : Smallint;
  xZAxisTitle     : string;
  hTitle          : Hwnd;
  iTitle          : Smallint;
  pTitle          : PChar;
  nGraph          : Smallint;
begin
  FZAxisTitle := Value;
  {Check Length}
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphText.SetZAxisTitle <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  
  if Cr.FCrpeEngine.PEGetGraphTextInfo(Cr.FPrintJob, SectionCode, nGraph,
    PE_GTT_ZAXISTITLE, hTitle, iTitle) then
  begin
    {Get the Text}
    pTitle := StrAlloc(iTitle);
    if not Cr.FCrpeEngine.PEGetHandleString(hTitle, pTitle, iTitle) then
    begin
      StrDispose(pTitle);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphText.SetZAxisTitle <PEGetHandleString>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    xZAxisTitle := String(pTitle);
    StrDispose(pTitle);
  end;

  {ZAxis}
  if xZAxisTitle <> FZAxisTitle then
  begin
    xZAxisTitle := FZAxisTitle;
    {Set the GraphText to the Report}
    
    if not Cr.FCrpeEngine.PESetGraphTextInfo(Cr.FPrintJob, SectionCode, nGraph,
      PE_GTT_ZAXISTITLE, PChar(xZAxisTitle)) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'GraphText.SetZAxisTitle <PESetGraphTextInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetTitleFont                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetTitleFont (const Value: TCrpeFont);
var
  FontColorInfo : PEFontColorInfo;
  SectionCode   : Smallint;
  xTitleFont    : TCrpeFont;
  nGraph        : Smallint;
begin
  FTitleFont.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    FTitleFont.OnChange := OnChangeTitleFont;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphText.SetTitleFont <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get the GraphTextFont information}
  if Cr.FCrpeEngine.PEGetGraphFontInfo(Cr.FPrintJob, SectionCode, nGraph,
    PE_GTF_TITLEFONT, FontColorInfo) then
  begin
    xTitleFont := TCrpeFont.Create;
    if CompareFonts(FontColorInfo, xTitleFont, PE_GTF_TITLEFONT) then
    begin
      {Set FontInfo}
      CopyFontInfo(FontColorInfo, xTitleFont);
      if not Cr.FCrpeEngine.PESetGraphFontInfo(Cr.FPrintJob, SectionCode, nGraph,
        PE_GTF_TITLEFONT, FontColorInfo) then
      begin
        xTitleFont.Free;
        FTitleFont.OnChange := OnChangeTitleFont;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'GraphText.SetTitleFont <PESetGraphFontInfo>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
    end;
    xTitleFont.Free;
  end;
end;
{------------------------------------------------------------------------------}
{ SetSubTitleFont                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetSubTitleFont (const Value: TCrpeFont);
var
  FontColorInfo : PEFontColorInfo;
  SectionCode   : Smallint;
  xSubTitleFont : TCrpeFont;
  nGraph        : Smallint;
begin
  FSubTitleFont.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    FSubTitleFont.OnChange := OnChangeSubTitleFont;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphText.SetSubTitleFont <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get the GraphTextFont information}
  
  if Cr.FCrpeEngine.PEGetGraphFontInfo(Cr.FPrintJob, SectionCode, nGraph,
    PE_GTF_SUBTITLEFONT, FontColorInfo) then
  begin
    xSubTitleFont := TCrpeFont.Create;
    if CompareFonts(FontColorInfo, xSubTitleFont, PE_GTF_SUBTITLEFONT) then
    begin
      {Set FontInfo}
      CopyFontInfo(FontColorInfo, xSubTitleFont);

      if not Cr.FCrpeEngine.PESetGraphFontInfo(Cr.FPrintJob, SectionCode, nGraph,
        PE_GTF_SUBTITLEFONT, FontColorInfo) then
      begin
        FSubTitleFont.OnChange := OnChangeSubTitleFont;
        xSubTitleFont.Free;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'GraphText.SetSubTitleFont <PESetGraphFontInfo>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
    end;
    xSubTitleFont.Free;
  end;
end;
{------------------------------------------------------------------------------}
{ SetFootNote                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetFootNoteFont (const Value: TCrpeFont);
var
  FontColorInfo : PEFontColorInfo;
  SectionCode   : Smallint;
  xFootNoteFont : TCrpeFont;
  nGraph        : Smallint;
begin
  FFootNoteFont.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    FFootNoteFont.OnChange := OnChangeFootNoteFont;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphText.SetFootNoteFont <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get the GraphTextFont information}
  
  if Cr.FCrpeEngine.PEGetGraphFontInfo(Cr.FPrintJob, SectionCode, nGraph,
    PE_GTF_FOOTNOTEFONT, FontColorInfo) then
  begin
    xFootNoteFont := TCrpeFont.Create;
    if CompareFonts(FontColorInfo, xFootNoteFont, PE_GTF_FOOTNOTEFONT) then
    begin
      {Set FontInfo}
      CopyFontInfo(FontColorInfo, xFootNoteFont);
      
      if not Cr.FCrpeEngine.PESetGraphFontInfo(Cr.FPrintJob, SectionCode, nGraph,
        PE_GTF_FOOTNOTEFONT, FontColorInfo) then
      begin
        FFootNoteFont.OnChange := OnChangeFootNoteFont;
        xFootNoteFont.Free;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'GraphText.SetFootNoteFont <PESetGraphFontInfo>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
    end;
    xFootNoteFont.Free;
  end;
end;
{------------------------------------------------------------------------------}
{ SetGroupsTitle                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetGroupsTitleFont (const Value: TCrpeFont);
var
  FontColorInfo    : PEFontColorInfo;
  SectionCode      : Smallint;
  xGroupsTitleFont : TCrpeFont;
  nGraph           : Smallint;
begin
  FGroupsTitleFont.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    FGroupsTitleFont.OnChange := OnChangeGroupsTitleFont;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphText.SetGroupsTitleFont <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get the GraphTextFont information}
  
  if Cr.FCrpeEngine.PEGetGraphFontInfo(Cr.FPrintJob, SectionCode, nGraph,
    PE_GTF_GROUPSTITLEFONT, FontColorInfo) then
  begin
    xGroupsTitleFont := TCrpeFont.Create;
    if CompareFonts(FontColorInfo, xGroupsTitleFont, PE_GTF_GROUPSTITLEFONT) then
    begin
      {Set FontInfo}
      CopyFontInfo(FontColorInfo, xGroupsTitleFont);
      
      if not Cr.FCrpeEngine.PESetGraphFontInfo(Cr.FPrintJob, SectionCode, nGraph,
        PE_GTF_GROUPSTITLEFONT, FontColorInfo) then
      begin
        FGroupsTitleFont.OnChange := OnChangeGroupsTitleFont;
        xGroupsTitleFont.Free;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'GraphText.SetGroupsTitleFont <PESetGraphFontInfo>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
    end;
    xGroupsTitleFont.Free;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDataTitleFont                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetDataTitleFont (const Value: TCrpeFont);
var
  FontColorInfo  : PEFontColorInfo;
  SectionCode    : Smallint;
  xDataTitleFont : TCrpeFont;
  nGraph         : Smallint;
begin
  FDataTitleFont.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    FDataTitleFont.OnChange := OnChangeDataTitleFont;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphText.SetDataTitleFont <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get the GraphTextFont information}
  
  if Cr.FCrpeEngine.PEGetGraphFontInfo(Cr.FPrintJob, SectionCode, nGraph,
    PE_GTF_DATATITLEFONT, FontColorInfo) then
  begin
    xDataTitleFont := TCrpeFont.Create;
    if CompareFonts(FontColorInfo, xDataTitleFont, PE_GTF_DATATITLEFONT) then
    begin
      {Set FontInfo}
      CopyFontInfo(FontColorInfo, xDataTitleFont);
      
      if not Cr.FCrpeEngine.PESetGraphFontInfo(Cr.FPrintJob, SectionCode, nGraph,
        PE_GTF_DATATITLEFONT, FontColorInfo) then
      begin
        FDataTitleFont.OnChange := OnChangeDataTitleFont;
        xDataTitleFont.Free;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'GraphText.SetDataTitleFont <PESetGraphFontInfo>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
    end;
    xDataTitleFont.Free;
  end;
end;
{------------------------------------------------------------------------------}
{ SetLegendFont                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetLegendFont (const Value: TCrpeFont);
var
  FontColorInfo : PEFontColorInfo;
  SectionCode   : Smallint;
  xLegendFont   : TCrpeFont;
  nGraph        : Smallint;
begin
  FLegendFont.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    FLegendFont.OnChange := OnChangeLegendFont;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphText.SetLegendFont <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get the GraphTextFont information}
  
  if Cr.FCrpeEngine.PEGetGraphFontInfo(Cr.FPrintJob, SectionCode, nGraph,
    PE_GTF_LEGENDFONT, FontColorInfo) then
  begin
    xLegendFont := TCrpeFont.Create;
    if CompareFonts(FontColorInfo, xLegendFont, PE_GTF_LEGENDFONT) then
    begin
      {Set FontInfo}
      CopyFontInfo(FontColorInfo, xLegendFont);
      
      if not Cr.FCrpeEngine.PESetGraphFontInfo(Cr.FPrintJob, SectionCode, nGraph,
        PE_GTF_LEGENDFONT, FontColorInfo) then
      begin
        FLegendFont.OnChange := OnChangeLegendFont;
        xLegendFont.Free;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'GraphText.SetLegendFont <PESetGraphFontInfo>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
    end;
    xLegendFont.Free;
  end;
end;
{------------------------------------------------------------------------------}
{ SetGroupLabelsFont                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetGroupLabelsFont (const Value: TCrpeFont);
var
  FontColorInfo    : PEFontColorInfo;
  SectionCode      : Smallint;
  xGroupLabelsFont : TCrpeFont;
  nGraph           : Smallint;
begin
  FGroupLabelsFont.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    FGroupLabelsFont.OnChange := OnChangeGroupLabelsFont;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphText.SetGroupLabelsFont <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get the GraphTextFont information}
  
  if Cr.FCrpeEngine.PEGetGraphFontInfo(Cr.FPrintJob, SectionCode, nGraph,
    PE_GTF_GROUPLABELSFONT, FontColorInfo) then
  begin
    xGroupLabelsFont := TCrpeFont.Create;
    if CompareFonts(FontColorInfo, xGroupLabelsFont, PE_GTF_GROUPLABELSFONT) then
    begin
      {Set FontInfo}
      CopyFontInfo(FontColorInfo, xGroupLabelsFont);
      
      if not Cr.FCrpeEngine.PESetGraphFontInfo(Cr.FPrintJob, SectionCode, nGraph,
        PE_GTF_GROUPLABELSFONT, FontColorInfo) then
      begin
        FGroupLabelsFont.OnChange := OnChangeGroupLabelsFont;
        xGroupLabelsFont.Free;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'GraphText.SetGroupLabelsFont <PESetGraphFontInfo>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
    end;
    xGroupLabelsFont.Free;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDataLabelsFont                                                            }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.SetDataLabelsFont (const Value: TCrpeFont);
var
  FontColorInfo   : PEFontColorInfo;
  SectionCode     : Smallint;
  xDataLabelsFont : TCrpeFont;
  nGraph          : Smallint;
begin
  FDataLabelsFont.Assign(Value);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    FDataLabelsFont.OnChange := OnChangeDataLabelsFont;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphText.SetDataLabelsFont <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get the GraphTextFont information}
  
  if Cr.FCrpeEngine.PEGetGraphFontInfo(Cr.FPrintJob, SectionCode, nGraph,
    PE_GTF_DATALABELSFONT, FontColorInfo) then
  begin
    xDataLabelsFont := TCrpeFont.Create;
    if CompareFonts(FontColorInfo, xDataLabelsFont, PE_GTF_DATALABELSFONT) then
    begin
      {Set FontInfo}
      CopyFontInfo(FontColorInfo, xDataLabelsFont);

      if not Cr.FCrpeEngine.PESetGraphFontInfo(Cr.FPrintJob, SectionCode, nGraph,
        PE_GTF_DATALABELSFONT, FontColorInfo) then
      begin
        FDataLabelsFont.OnChange := OnChangeDataLabelsFont;
        xDataLabelsFont.Free;
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
            'GraphText.SetDataLabelsFont <PESetGraphFontInfo>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
    end;
    xDataLabelsFont.Free;
  end;
end;
{------------------------------------------------------------------------------}
{ OnChangeTitleFont                                                            }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.OnChangeTitleFont (Sender: TObject);
begin
  FTitleFont.OnChange := nil;
  xFont.Assign(FTitleFont);
  SetTitleFont(xFont);
  FTitleFont.OnChange := OnChangeTitleFont;
end;
{------------------------------------------------------------------------------}
{ OnChangeSubTitleFont                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.OnChangeSubTitleFont (Sender: TObject);
begin
  FSubTitleFont.OnChange := nil;
  xFont.Assign(FSubTitleFont);
  SetSubTitleFont(xFont);
  FSubTitleFont.OnChange := OnChangeSubTitleFont;
end;
{------------------------------------------------------------------------------}
{ OnChangeFootNoteFont                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.OnChangeFootNoteFont (Sender: TObject);
begin
  FFootNoteFont.OnChange := nil;
  xFont.Assign(FFootNoteFont);
  SetFootNoteFont(xFont);
  FFootNoteFont.OnChange := OnChangeFootNoteFont;
end;
{------------------------------------------------------------------------------}
{ OnChangeGroupsTitleFont                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.OnChangeGroupsTitleFont (Sender: TObject);
begin
  FGroupsTitleFont.OnChange := nil;
  xFont.Assign(FGroupsTitleFont);
  SetGroupsTitleFont(xFont);
  FGroupsTitleFont.OnChange := OnChangeGroupsTitleFont;
end;
{------------------------------------------------------------------------------}
{ OnChangeDataTitleFont                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.OnChangeDataTitleFont (Sender: TObject);
begin
  FDataTitleFont.OnChange := nil;
  xFont.Assign(FDataTitleFont);
  SetDataTitleFont(xFont);
  FDataTitleFont.OnChange := OnChangeDataTitleFont;
end;
{------------------------------------------------------------------------------}
{ OnChangeLegendFont                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.OnChangeLegendFont (Sender: TObject);
begin
  FLegendFont.OnChange := nil;
  xFont.Assign(FLegendFont);
  SetLegendFont(xFont);
  FLegendFont.OnChange := OnChangeLegendFont;
end;
{------------------------------------------------------------------------------}
{ OnChangeGroupLabelsFont                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.OnChangeGroupLabelsFont (Sender: TObject);
begin
  FGroupLabelsFont.OnChange := nil;
  xFont.Assign(FGroupLabelsFont);
  SetGroupLabelsFont(xFont);
  FGroupLabelsFont.OnChange := OnChangeGroupLabelsFont;
end;
{------------------------------------------------------------------------------}
{ OnChangeDataLabelsFont                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.OnChangeDataLabelsFont (Sender: TObject);
begin
  FDataLabelsFont.OnChange := nil;
  xFont.Assign(FDataLabelsFont);
  SetDataLabelsFont(xFont);
  FDataLabelsFont.OnChange := OnChangeDataLabelsFont;
end;
{------------------------------------------------------------------------------}
{ GetText                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeGraphText.GetText;
const
  PETextArray : array[0..7] of Word = (PE_GTT_TITLE, PE_GTT_SUBTITLE,
    PE_GTT_FOOTNOTE, PE_GTT_SERIESTITLE, PE_GTT_GROUPSTITLE,
    PE_GTT_XAXISTITLE, PE_GTT_YAXISTITLE, PE_GTT_ZAXISTITLE);
  PEFontArray: array[0..7] of Word = (PE_GTF_TITLEFONT, PE_GTF_SUBTITLEFONT,
    PE_GTF_FOOTNOTEFONT, PE_GTF_GROUPSTITLEFONT, PE_GTF_DATATITLEFONT,
    PE_GTF_LEGENDFONT, PE_GTF_GROUPLABELSFONT, PE_GTF_DATALABELSFONT);
type
  TVCLGraphTextArray = array[0..7] of string;
var
  FontColorInfo   : PEFontColorInfo;
  hTitle          : Hwnd;
  iTitle          : Smallint;
  pTitle          : PChar;
  TextArray       : TVCLGraphTextArray;
  SectionCode     : Smallint;
  nGraph          : Smallint;
  HasText         : Boolean;
  xFont           : TCrpeFont;
  iIndex          : Smallint;
begin
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  nGraph := TCrpeGraphsItem(Parent).FSectionGraphNum;
  {Convert SectionName to Code}
  if not StrToSectionCode(TCrpeGraphsItem(Parent).FSection, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'GraphText.GetText <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  HasText := False;
  {Loop through the GraphText calls for each title type}
  for iIndex := 0 to High(PETextArray) do
  begin
    {Initialize Text Array}
    TextArray[iIndex] := '';
    
    if Cr.FCrpeEngine.PEGetGraphTextInfo(Cr.FPrintJob, SectionCode, nGraph,
        PETextArray[iIndex], hTitle, iTitle) then
    begin
      {Get the Text}
      pTitle := StrAlloc(iTitle);
      if not Cr.FCrpeEngine.PEGetHandleString(hTitle, pTitle, iTitle) then
      begin
        StrDispose(pTitle);
        case Cr.GetErrorMsg(0,errNoOption,errEngine,'',
            'GraphText.GetText <PEGetHandleString>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
      TextArray[iIndex] := String(pTitle);
      StrDispose(pTitle);
      HasText := True;
    end;
  end;

  {If Text was retrieved, copy to VCL}
  if HasText then
  begin
    FTitle := TextArray[0];
    FSubTitle := TextArray[1];
    FFootNote := TextArray[2];
    FSeriesTitle := TextArray[3];
    FGroupsTitle := TextArray[4];
    FXAxisTitle := TextArray[5];
    FYAxisTitle := TextArray[6];
    FZAxisTitle := TextArray[7];
  end;

  {Get the GraphTextFont information}
  for iIndex := 0 to High(PEFontArray) do
  begin
    
    if Cr.FCrpeEngine.PEGetGraphFontInfo(Cr.FPrintJob, SectionCode, nGraph,
      PEFontArray[iIndex], FontColorInfo) then
    begin
      xFont := TCrpeFont.Create;
      xFont.Name := String(FontColorInfo.faceName);
      xFont.Charset := FontColorInfo.charSet;
      if FontColorInfo.color = PE_NO_COLOR then
        xFont.Color := clNone
      else
        xFont.Color := TColor(FontColorInfo.color);
      xFont.Pitch := TFontPitch(FontColorInfo.fontPitch);
      xFont.Size := FontColorInfo.pointSize;
      xFont.Style := [];
      if FontColorInfo.isItalic <> 0 then
        xFont.Style := xFont.Style + [fsItalic];
      if FontColorInfo.isStruckOut <> 0 then
        xFont.Style := xFont.Style + [fsStrikeOut];
      if FontColorInfo.isUnderlined <> 0 then
        xFont.Style := xFont.Style + [fsUnderline];
      if FontColorInfo.weight > FW_NORMAL then
        xFont.Style := xFont.Style + [fsBold];
      {We ignore FontColorInfo.FontFamily}
      case PEFontArray[iIndex] of
        PE_GTF_TITLEFONT       : FTitleFont.Assign(xFont);
        PE_GTF_SUBTITLEFONT    : FSubTitleFont.Assign(xFont);
        PE_GTF_FOOTNOTEFONT    : FFootNoteFont.Assign(xFont);
        PE_GTF_GROUPSTITLEFONT : FGroupsTitleFont.Assign(xFont);
        PE_GTF_DATATITLEFONT   : FDataTitleFont.Assign(xFont);
        PE_GTF_LEGENDFONT      : FLegendFont.Assign(xFont);
        PE_GTF_GROUPLABELSFONT : FGroupLabelsFont.Assign(xFont);
        PE_GTF_DATALABELSFONT  : FDataLabelsFont.Assign(xFont);
      end;
      xFont.Free;
    end;
  end;
end;


{******************************************************************************}
{ Class TCrpeSubreportLinksItem                                                }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSubreportLinksItem.Create;
begin
  inherited Create;
  FMainReportFieldName := '';
  FSubreportFieldName  := '';
  FParamFieldName      := '';
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSubreportLinksItem.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.ReportName) or (FIndex < 1) or (Parent.FIndex < 1) or (Handle = 0) then
  begin
    FIndex               := -1;
    FMainReportFieldName := '';
    FSubreportFieldName  := '';
    FParamFieldName      := '';
  end;
end;
{------------------------------------------------------------------------------}
{ StatusIsGo                                                                   }
{------------------------------------------------------------------------------}
function TCrpeSubreportLinksItem.StatusIsGo;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if Handle = 0 then Exit;
  if not Cr.OpenPrintJob then Exit;
  if Parent.FIndex < 1 then Exit;
  if FIndex < 0 then Exit;
  Result := True;
end;
{------------------------------------------------------------------------------}
{ SetMainReportFieldName                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSubreportLinksItem.SetMainReportFieldName (const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetSubreportFieldName                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSubreportLinksItem.SetSubreportFieldName (const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetParamFieldName                                                            }
{------------------------------------------------------------------------------}
procedure TCrpeSubreportLinksItem.SetParamFieldName (const Value: string);
begin
  {Read only}
end;


{******************************************************************************}
{ Class TCrpeSubreportLinks                                                    }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSubreportLinks.Create;
begin
  inherited Create;
  FItem := TCrpeSubreportLinksItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSubreportLinks.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeSubreportLinks.Count : integer;
begin
  Result := TCrpeSubreportsItem(Parent).FNLinks;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSubreportLinks.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) or (Handle = 0) then
  begin
    FIndex := -1;
    Handle :=  0;
  end;
  FItem.Clear;
end;
{------------------------------------------------------------------------------}
{ StatusIsGo                                                                   }
{------------------------------------------------------------------------------}
function TCrpeSubreportLinks.StatusIsGo: boolean;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if (csLoading in Cr.ComponentState) then Exit;
  if FIndex < 0 then Exit;
  if Handle = 0 then Exit;
  if not Cr.JobIsOpen then Exit;
  if Parent.FIndex < 1 then Exit;
  Result := True;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeSubreportLinks.SetIndex (nIndex: integer);
var
  LinkInfo : PESubreportLinkInfo;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Clear;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;

  {Get LinkInfo}
  
  if not Cr.FCrpeEngine.PEGetNthSubreportLinkEx(Cr.PrintJobs(0), Handle, nIndex, LinkInfo) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + '.SetIndex(' + IntToStr(nIndex) +
        ') <PEGetNthSubreportLinkEx>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FItem.FMainReportFieldName := String(LinkInfo.mainReportFieldName);
  FItem.FSubreportFieldName := String(LinkInfo.subreportFieldName);
  FItem.FParamFieldName := String(LinkInfo.promptVarFieldName);
  PropagateIndex(nIndex);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeSubreportLinks.GetItem (nIndex: integer) : TCrpeSubreportLinksItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeSubreportsItem                                                    }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSubreportsItem.Create;
begin
  inherited Create;
  {Subreport specific variables}
  FName                := '';
  FNLinks              := 0;
  FOnDemand            := False;
  FOnDemandCaption     := '';
  FPreviewTabCaption   := '';
  FIsExternal          := False;
  FReImportWhenOpening := True;
  FLinks               := TCrpeSubreportLinks.Create;
  FSubClassList.Add(FLinks);
end;
{------------------------------------------------------------------------------}
{ Destroy                                                                      }
{------------------------------------------------------------------------------}
destructor TCrpeSubreportsItem.Destroy;
begin
  FLinks.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSubreportsItem.Clear;
begin
  inherited Clear;
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.ReportName) or (FIndex < 1) or (Handle = 0) then
  begin
    FIndex               := 0;
    FName                := '';
    FNLinks              := 0;
    FOnDemand            := False;
    FOnDemandCaption     := '';
    FPreviewTabCaption   := '';
    FIsExternal          := False;
    FReImportWhenOpening := True;
  end;
end;
{------------------------------------------------------------------------------}
{ ReImport                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeSubreportsItem.ReImport;
var
  b1,b2 : Bool;
begin
  if not StatusIsGo(FIndex) then Exit;

  
  b1 := False;
  b2 := True;
  if not Cr.FCrpeEngine.PEReimportSubreport(Cr.FPrintJob, Handle, b1, b2) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'ReImport <PEReimportSubreport>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetName                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeSubreportsItem.SetName (const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetNLinks                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeSubreportsItem.SetNLinks (const Value: Smallint);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetOnDemand                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeSubreportsItem.SetOnDemand (const Value: Boolean);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetOnDemandCaption                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeSubreportsItem.SetOnDemandCaption (const Value: string);
var
  hText : HWnd;
  iText : Smallint;
  pText : PChar;
  sText : string;
begin
  if IsQuoted(Value) then
    FOnDemandCaption := Value
  else
    FOnDemandCaption := QuotedStr(Value);
  if not StatusIsGo(FIndex) then Exit;

  {Get OnDemandCaption}
  if not Cr.FCrpeEngine.PEGetObjectFormatFormula(Cr.PrintJobs(0), Handle, PE_FFN_CAPTION_ODS,
    hText, iText) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
      'Subreports[' + IntToStr(FIndex) + '].SetOnDemandCaption <PEGetObjectFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Text}
  pText := GlobalLock(hText);
  sText := WideCharToString(PWideChar(pText));
  GlobalUnlock(hText);
  GlobalFree(hText);

  if CompareStr(sText, FOnDemandCaption) <> 0 then
  begin
    if not Cr.FCrpeEngine.PESetObjectFormatFormula (Cr.PrintJobs(0), Handle,
      PE_FFN_CAPTION_ODS, PChar(FOnDemandCaption)) then
    begin
      case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'Subreports[' + IntToStr(FIndex) + '].SetOnDemandCaption <PESetObjectFormatFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetPreviewTabCaption                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeSubreportsItem.SetPreviewTabCaption (const Value: string);
var
  hText : HWnd;
  iText : Smallint;
  pText : PChar;
  sText : string;
begin
  if IsQuoted(Value) then
    FPreviewTabCaption := Value
  else
    FPreviewTabCaption := QuotedStr(Value);
  if not StatusIsGo(FIndex) then Exit;

  {Get PreviewTabCaption}
  if not Cr.FCrpeEngine.PEGetObjectFormatFormula(Cr.PrintJobs(0), Handle, PE_FFN_CAPTION_PREVIEWTAB,
    hText, iText) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
      'Subreports[' + IntToStr(FIndex) + '].SetPreviewTabCaption <PEGetObjectFormatFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Text}
  pText := GlobalLock(hText);
  sText := WideCharToString(PWideChar(pText));
  GlobalUnlock(hText);
  GlobalFree(hText);

  if CompareStr (sText, FPreviewTabCaption) <> 0 then
  begin
    if not Cr.FCrpeEngine.PESetObjectFormatFormula (Cr.PrintJobs(0), Handle,
      PE_FFN_CAPTION_PREVIEWTAB, PChar(FPreviewTabCaption)) then
    begin
      case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'Subreports[' + IntToStr(FIndex) + '].SetPreviewTabCaption <PESetObjectFormatFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetIsExternal                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeSubreportsItem.SetIsExternal (const Value: Boolean);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetReImportWhenOpening                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSubreportsItem.SetReImportWhenOpening (const Value: Boolean);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ Reference Properties                                                         }
{------------------------------------------------------------------------------}
function TCrpeSubreportsItem.GetDetailCopies: Smallint;
begin
  Result := Cr.FDetailCopies;
end;
procedure TCrpeSubreportsItem.SetDetailCopies(const Value: Smallint);
begin
  Cr.FDetailCopies := Value;
end;
function TCrpeSubreportsItem.GetReportTitle: string;
begin
  Result := Cr.FReportTitle;
end;
procedure TCrpeSubreportsItem.SetReportTitle(const Value: string);
begin
  Cr.FReportTitle := Value;
end;
{------------------------------------------------------------------------------}
{ Reference Method: Variable                                                   }
{------------------------------------------------------------------------------}
function TCrpeSubreportsItem.PrintJob : Smallint;
begin
  Result := Cr.FPrintJob;  {read-only}
end;
{------------------------------------------------------------------------------}
{ Reference Methods: Classes                                                   }
{------------------------------------------------------------------------------}
function TCrpeSubreportsItem.Margins : TCrpeMargins;
begin
  Result := Cr.FMargins;
end;
function TCrpeSubreportsItem.Connect : TCrpeConnect;
begin
  Result := Cr.FConnect;
end;
function TCrpeSubreportsItem.LogOnInfo : TCrpeLogonInfo;
begin
  Result := Cr.FLogOnInfo;
end;
function TCrpeSubreportsItem.SectionFont : TCrpeSectionFont;
begin
  Result := Cr.FSectionFont;
end;
function TCrpeSubreportsItem.SectionFormat : TCrpeSectionFormat;
begin
  Result := Cr.FSectionFormat;
end;
function TCrpeSubreportsItem.AreaFormat : TCrpeAreaFormat;
begin
  Result := Cr.FAreaFormat;
end;
function TCrpeSubreportsItem.SectionSize : TCrpeSectionSize;
begin
  Result := Cr.FSectionSize;
end;
function TCrpeSubreportsItem.Selection : TCrpeSelection;
begin
  Result := Cr.FSelection;
end;
function TCrpeSubreportsItem.GroupSelection : TCrpeGroupSelection;
begin
  Result := Cr.FGroupSelection;
end;
function TCrpeSubreportsItem.SortFields : TCrpeSortFields;
begin
  Result := Cr.FSortFields;
end;
function TCrpeSubreportsItem.GroupSortFields : TCrpeGroupSortFields;
begin
  Result := Cr.FGroupSortFields;
end;
function TCrpeSubreportsItem.Groups : TCrpeGroups;
begin
  Result := Cr.FGroups;
end;
function TCrpeSubreportsItem.SQL : TCrpeSQL;
begin
  Result := Cr.FSQL;
end;
function TCrpeSubreportsItem.SQLExpressions : TCrpeSQLExpressions;
begin
  Result := Cr.FSQLExpressions;
end;
function TCrpeSubreportsItem.Formulas : TCrpeFormulas;
begin
  Result := Cr.FFormulas;
end;
function TCrpeSubreportsItem.Tables : TCrpeTables;
begin
  Result := Cr.FTables;
end;
function TCrpeSubreportsItem.ParamFields : TCrpeParamFields;
begin
  Result := Cr.FParamFields;
end;
function TCrpeSubreportsItem.SessionInfo : TCrpeSessionInfo;
begin
  Result := Cr.FSessionInfo;
end;
function TCrpeSubreportsItem.Graphs : TCrpeGraphs;
begin
  Result := Cr.FGraphs;
end;
function TCrpeSubreportsItem.GlobalOptions : TCrpeGlobalOptions;
begin
  Result := Cr.FGlobalOptions;
end;
function TCrpeSubreportsItem.ReportOptions : TCrpeReportOptions;
begin
  Result := Cr.FReportOptions;
end;
{Objects}
function TCrpeSubreportsItem.Lines : TCrpeLines;
begin
  Result := Cr.FLines;
end;
function TCrpeSubreportsItem.Boxes : TCrpeBoxes;
begin
  Result := Cr.FBoxes;
end;

function TCrpeSubreportsItem.TextObjects : TCrpeTextObjects;
begin
  Result := Cr.FTextObjects;
end;

function TCrpeSubreportsItem.OleObjects : TCrpeOleObjects;
begin
  Result := Cr.FOleObjects;
end;
function TCrpeSubreportsItem.CrossTabs : TCrpeCrossTabs;
begin
  Result := Cr.FCrossTabs;
end;
function TCrpeSubreportsItem.Maps : TCrpeMaps;
begin
  Result := Cr.FMaps;
end;
function TCrpeSubreportsItem.OLAPCubes : TCrpeOLAPCubes;
begin
  Result := Cr.FOLAPCubes;
end;
{Field Objects}
function TCrpeSubreportsItem.Pictures : TCrpePictures;
begin
  Result := Cr.FPictures;
end;
function TCrpeSubreportsItem.DatabaseFields : TCrpeDatabaseFields;
begin
  Result := Cr.FDatabaseFields;
end;
function TCrpeSubreportsItem.SummaryFields : TCrpeSummaryFields;
begin
  Result := Cr.FSummaryFields;
end;
function TCrpeSubreportsItem.SpecialFields : TCrpeSpecialFields;
begin
  Result := Cr.FSpecialFields;
end;
function TCrpeSubreportsItem.GroupNameFields : TCrpeGroupNameFields;
begin
  Result := Cr.FGroupNameFields;
end;
function TCrpeSubreportsItem.RunningTotals : TCrpeRunningTotals;
begin
  Result := Cr.FRunningTotals;
end;


{******************************************************************************}
{ Class TCrpeSubreports                                                        }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSubreports.Create;
begin
  inherited Create;
  {Set inherited ObjectContainer properties}
  FObjectType      := otSubreport;
  FFieldObjectType := oftNone;
  {Subreport specific variables}
  FIndex       := 0;
  FName        := '';
  FNames       := TStringList.Create;
  FSubExecute  := False;
  FItem        := TCrpeSubreportsItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destroy                                                                      }
{------------------------------------------------------------------------------}
destructor TCrpeSubreports.Destroy;
begin
  FNames.Free;
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSubreports.Clear;
var
  sName : string;
begin
  if (Cr = nil) then Exit;
  if (Cr.FPrintJob = 0) or (FIndex < 1) then
  begin
    sName := Cr.FReportName;
    Cr.FReportName := '';
    {Subreport specific variables}
    FIndex := 0;
    FName := '';
    FNames.Clear;
    FItem.Clear;

  {** Clear Report-Specific properties **}
    Cr.FPrintDate.Clear;
    Cr.FSummaryInfo.Clear;
    {General Classes shared by Main and Subreports}
    {Graphs}
    Cr.FGraphs.Clear;
    {Group/Sort}
    Cr.FSortFields.Clear;
    Cr.FGroupSortFields.Clear;
    Cr.FGroups.Clear;
    {Margins}
    Cr.FMargins.Clear;
    {ReportOptions}
    Cr.FReportOptions.Clear;
    {Section/Area Format}
    Cr.FAreaFormat.Clear;
    Cr.FSectionSize.Clear;
    Cr.FSectionFont.Clear;
    Cr.FSectionFormat.Clear;
    {Selection}
    Cr.FSelection.Clear;
    Cr.FGroupSelection.Clear;
    {SessionInfo}
    Cr.FSessionInfo.Clear;
    {SQL}
    Cr.FConnect.Clear;
    Cr.FLogOnInfo.Clear;
    Cr.FSQL.FQuery.Clear;
    Cr.FSQLExpressions.Clear;
    {Tables}
    Cr.FTables.Clear;

    {Field Objects}
    Cr.FDatabaseFields.Clear;
    Cr.FFormulas.Clear;
    Cr.FSummaryFields.Clear;
    Cr.FSpecialFields.Clear;
    Cr.FGroupNameFields.Clear;
    Cr.FParamFields.Clear;
    {Expressions cleared with SQL}
    Cr.FRunningTotals.Clear;

    {Other Objects}
    Cr.FTextObjects.Clear;
    Cr.FLines.Clear;
    Cr.FBoxes.Clear;
    Cr.FOleObjects.Clear;
    Cr.FCrossTabs.Clear;
    Cr.FPictures.Clear;
    Cr.FMaps.Clear;
    Cr.FOLAPCubes.Clear;

    {Restore ReportName}
    Cr.FReportName := sName;
  end;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeSubreports.Count : integer;
var
  slSectionsN : TStringList;
  slSectionsS : TStringList;
  SectionCode : Smallint;
  i,i2        : integer;
  nSubreports : integer;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;
  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(Cr.PrintJobs(0), slSectionsN, slSectionsS, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        'Subreports.Count <GetSectionCodes>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through the Sections}
  nSubreports := 1; {initialize to 1 for main Report}
  for i := 0 to (slSectionsN.Count - 1) do
  begin
    SectionCode := StrToInt(slSectionsN[i]);
    
    i2 := Cr.FCrpeEngine.PEGetNSubreportsInSection(Cr.PrintJobs(0), SectionCode);
    nSubreports := nSubreports + i2;
  end;
  slSectionsN.Free;
  slSectionsS.Free;
  Result := nSubreports;
end;
{------------------------------------------------------------------------------}
{ IndexOf                                                                      }
{------------------------------------------------------------------------------}
function TCrpeSubreports.IndexOf(SubreportName: string): integer;
var
  cnt : integer;
begin
  Result := -1;
  if FNames.Count > 0 then
  begin
    {Locate subreport name}
    for cnt := 0 to FNames.Count-1 do
    begin
      if CompareText(FNames[cnt], SubreportName) = 0 then
      begin
        Result := cnt + 1;
        Break;
      end;
    end;
  end;
  if Result = -1 then
  begin
    Names;
    {Locate subreport name}
    for cnt := 0 to FNames.Count-1 do
    begin
      if CompareText(FNames[cnt], SubreportName) = 0 then
      begin
        Result := cnt + 1;
        Break;
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ByName                                                                       }
{------------------------------------------------------------------------------}
function TCrpeSubreports.ByName (SubreportName: string): TCrpeSubreportsItem;
var
  i : integer;
begin
  Result := GetItem;
  i := IndexOf(SubreportName);
  if i = -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBREPORT_BY_NAME,
        'Subreports.ByName') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := GetItems(i);
end;
{------------------------------------------------------------------------------}
{  Names                                                                       }
{  - returns a list of Subreport Names.  Faster than looping through items.    }
{  - does not include the Main Report (Subreports[0]).                         }
{------------------------------------------------------------------------------}
function TCrpeSubreports.Names : TStrings;
var
  SubreportHandle : LongInt;
  SubreportInfo   : PESubreportInfo;
  slSectionsN     : TStringList;
  slSectionsS     : TStringList;
  nSubreports     : Smallint;
  SectionCode     : Smallint;
  i1, i2          : integer;
begin
  FNames.Clear;
  Result := FNames;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;
  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(Cr.PrintJobs(0), slSectionsN, slSectionsS, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        'Subreports.GetNames <GetSectionCodes>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through the Sections}
  for i1 := 0 to (slSectionsS.Count - 1) do
  begin
    SectionCode := StrToInt(slSectionsN[i1]);
    
    nSubReports := Cr.FCrpeEngine.PEGetNSubreportsInSection(Cr.PrintJobs(0), SectionCode);
    if nSubReports > 0 then
    begin
      for i2 := 0 to nSubReports - 1 do
      begin
        {Get the Subreport Handle}
        
        SubreportHandle := Cr.FCrpeEngine.PEGetNthSubreportInSection(Cr.PrintJobs(0), SectionCode, i2);
        if SubreportHandle = 0 then
        begin
          slSectionsN.Free;
          slSectionsS.Free;
          case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
              'Subreports.GetNames <PEGetNthSubreportInSection>') of
            errIgnore : Continue;
            errAbort  : Abort;
            errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
        {Get the Subreport Name}
        
        if not Cr.FCrpeEngine.PEGetSubreportInfo(Cr.PrintJobs(0), SubreportHandle, SubreportInfo) then
        begin
          slSectionsN.Free;
          slSectionsS.Free;
          case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
              'Subreports.GetNames <PEGetSubreportInfo>') of
            errIgnore : Exit;
            errAbort  : Abort;
            errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
          end;
        end;
        FNames.Add(String(SubreportInfo.SubreportName));
      end;
    end;
  end;
  slSectionsN.Free;
  slSectionsS.Free;
  Result := FNames;
end;
{------------------------------------------------------------------------------}
{ SetName                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeSubreports.SetName (const Value: string);
var
  nIndex : integer;
begin
  if (Cr = nil) then Exit;
  if (csLoading in Cr.ComponentState) then Exit;
  {Main Report has no name}
  if IsStrEmpty(Value) then
  begin
    SetIndex(0);
    Exit;
  end;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
        'Subreports.Name := ' + Value) of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeSubreports.SetIndex (nIndex: integer);
var
  SubreportHandle : LongInt;
  SubreportInfo   : PESubreportInfo;
  slSectionsN     : TStringList;
  slSectionsS     : TStringList;
  nSubreports     : Smallint;
  nSubReport      : Smallint;
  SectionCode     : Smallint;
  i1, i2          : integer;
  iText           : Smallint;
  hText           : HWnd;
  pText           : PChar;
  nSub            : integer;
  objectInfo      : PEObjectInfo;
  FoundIt         : Boolean;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(0);
    Clear;
    Exit;
  end;

  {If we are setting the main Report (0), update and exit}
  if nIndex = 0 then
  begin
    {Update Indexes}
    PropagateIndex(nIndex);
    {Clear other properties}
    PropagateHandle(0);
    FName := '';
    Item.FName := '';
    Item.FNLinks := 0;
    Item.FOnDemand := False;
    Item.FIsExternal := False;
    Item.FReImportWhenOpening := True;
    {No Object properties for Main Report}
    Item.FLeft := 0;
    Item.FWidth := 0;
    Item.FHeight := 0;
    Item.FTop := 0;
    Item.FSection := '';
    {Update PrintJob Numbers}
    if not Cr.OpenPrintJob then Exit;
    Cr.FPrintJob := Cr.PrintJobs(0);
    {Clear these in case there are similar items in Sub and Main Reports}
    Cr.FFormulas.FNames.Clear;
    Cr.FRunningTotals.FNames.Clear;
    Cr.FSQLExpressions.FNames.Clear;
    Cr.FSectionFormat.FSectionNames.Clear;
    Cr.FAreaFormat.FAreas.Clear;
    Exit;
  end;

  {Otherwise, we are dealing with a definite Subreport..index > 0}
  {Store the current index}
  nSubreport := FIndex;
  {Make sure the main Report Job is open first}
  FIndex := 0;
  if not Cr.OpenPrintJob then Exit;
  {Restore the current index}
  FIndex := nSubreport;

  {See if the Index specified is greater than the number of Subreports}
  if nIndex > (Count - 1) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
      'Subreports[' + IntToStr(nIndex) + ']') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Setup the SectionCode lists}
  {This list holds the SectionCode numbers: 3000, etc.}
  slSectionsN := TStringList.Create;
  {This list holds the SectionCode strings: GH1a, etc.}
  slSectionsS := TStringList.Create;
  {Retrieve Section Codes}
  if not Cr.GetSectionCodes(Cr.PrintJobs(0), slSectionsN, slSectionsS, False) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_ALLOCATE_MEMORY,
        'Subreports.SetIndex <GetSectionCodes>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through the Sections}
  FoundIt := False;
  nSubreport := 1;
  i2 := 0;
  SectionCode := 0;
  for i1 := 0 to (slSectionsN.Count - 1) do
  begin
    SectionCode := StrToInt(slSectionsN[i1]);
    
    nSubReports := Cr.FCrpeEngine.PEGetNSubreportsInSection(Cr.PrintJobs(0), SectionCode);
    if nSubReports < 1 then Continue;
    {Loop through Subreports}
    for i2 := 0 to nSubReports - 1 do
    begin
      {If the Subreport is not the one wanted, continue}
      if nSubreport = nIndex then
      begin
        FoundIt := True;
        Break;
      end;
      Inc(nSubreport);
    end;
    if FoundIt then Break;
  end;
  slSectionsN.Free;
  slSectionsS.Free;

  {Subreport could not be found, raise error}
  if not FoundIt then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
      'Subreports[' + IntToStr(nIndex) + ']') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {We found it...get the Subreport Handle}
  
  SubreportHandle := Cr.FCrpeEngine.PEGetNthSubreportInSection(Cr.PrintJobs(0), SectionCode, i2);
  if SubreportHandle = 0 then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'Subreports.SetIndex <PEGetNthSubreportInSection>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get the Subreport Name}

  if not Cr.FCrpeEngine.PEGetSubreportInfo(Cr.PrintJobs(0), SubreportHandle, SubreportInfo) then
  begin
    slSectionsN.Free;
    slSectionsS.Free;
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'Subreports.SetIndex <PEGetSubreportInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  FName := String(SubreportInfo.SubreportName);
  Item.FName := String(SubreportInfo.SubreportName);

  Item.FNLinks := SubreportInfo.NLinks;
  if SubreportInfo.IsOnDemand > 0 then
    Item.FOnDemand := True;

  case SubreportInfo.IsExternal of
    0 : Item.FIsExternal := False;
    1 : Item.FIsExternal := True;
    else
      Item.FIsExternal := False;
  end;
  case SubreportInfo.reimportOption of
    0 : Item.FReImportWhenOpening := False;
    1 : Item.FReImportWhenOpening := True;
    else
      Item.FReImportWhenOpening := True;
  end;
  PropagateIndex(nIndex);
  {Update PrintJob Numbers}
  while nIndex > (Cr.FPrintJobs.Count - 1) do
    Cr.FPrintJobs.Add('0');

  {Open the Subreport PrintJob}
  Cr.OpenPrintJob;
  Cr.FPrintJob := Cr.PrintJobs(nIndex);

  {Get Object properties - switch to Main Job again}
  nSubreport := Cr.FPrintJob;
  nSub := FIndex;
  Cr.FPrintJob := Cr.PrintJobs(0);

  {Clear these in case there are similar items in Sub and Main Reports}
  Cr.FFormulas.FNames.Clear;
  Cr.FRunningTotals.FNames.Clear;
  Cr.FSQLExpressions.FNames.Clear;
  Cr.FSectionFormat.FSectionNames.Clear;
  Cr.FAreaFormat.FAreas.Clear;

  Handle := Cr.GetObjectHandle(nIndex-1, FObjectType, FFieldObjectType);
  if Handle = 0 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
       Cr.BuildErrorString(Self) + 'SetIndex(' + IntToStr(nIndex) + ')') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateHandle(Handle);

  if not Cr.FCrpeEngine.PEGetObjectInfo(Cr.FPrintJob, Handle, objectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' + IntToStr(nIndex) + ') <PEGetObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  FItem.Left := objectInfo.xOffset;
  FItem.Top := objectInfo.yOffset;
  FItem.Width := objectInfo.width;
  FItem.Height := objectInfo.height;
  FItem.Section := Cr.SectionCodeToStringEx(objectInfo.sectionCode, False);

  {Get OnDemandCaption}
  if not Cr.FCrpeEngine.PEGetObjectFormatFormula(Cr.PrintJobs(0), Handle, PE_FFN_CAPTION_ODS,
    hText, iText) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'Subreports.SetIndex(' + IntToStr(nIndex) +
        ') <PEGetObjectFormatFormula - OnDemandCaption>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Text}
  pText := GlobalLock(hText);
  Item.FOnDemandCaption := WideCharToString(PWideChar(pText));
  GlobalUnlock(hText);
  GlobalFree(hText);

  {Get PreviewTabCaption}
  if not Cr.FCrpeEngine.PEGetObjectFormatFormula(Cr.PrintJobs(0), Handle, PE_FFN_CAPTION_PREVIEWTAB,
    hText, iText) then
  begin
    case Cr.GetErrorMsg(Cr.PrintJobs(0),errNoOption,errEngine,'',
        'Subreports.SetIndex(' + IntToStr(nIndex) +
        ') <PEGetObjectFormatFormula - PreviewTabCaption>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get Text}
  pText := GlobalLock(hText);
  Item.FPreviewTabCaption := WideCharToString(PWideChar(pText));
  GlobalUnlock(hText);
  GlobalFree(hText);

  {Format/Border}
  if csDesigning in Cr.ComponentState then
  begin
    FItem.Border.GetBorder;
    FItem.Format.GetFormat;
  end;

  {Switch to Subreport}
  FIndex := nSub;
  Cr.FPrintJob := nSubreport;

  {Update SubClass Indexes}
  if Cr.FGraphs.FIndex > (Cr.FGraphs.Count-1) then
    Cr.FGraphs.SetIndex(-1);
  if Cr.FSortFields.FIndex > (Cr.FSortFields.Count-1) then
    Cr.FSortFields.SetIndex(-1);
  if Cr.FGroupSortFields.FIndex > (Cr.FGroupSortFields.Count-1) then
    Cr.FGroupSortFields.SetIndex(-1);
  if Cr.FGroups.FIndex > (Cr.FGroups.Count-1) then
    Cr.FGroups.SetIndex(-1);
  if Cr.FAreaFormat.FIndex > (Cr.FAreaFormat.Count-1) then
    Cr.FAreaFormat.SetIndex(-1);
  if Cr.FSectionSize.FIndex > (Cr.FSectionSize.Count-1) then
    Cr.FSectionSize.SetIndex(-1);
  if Cr.FSectionFont.FIndex > (Cr.FSectionFont.Count-1) then
    Cr.FSectionFont.SetIndex(-1);
  if Cr.FSectionFormat.FIndex > (Cr.FSectionFormat.Count-1) then
    Cr.FSectionFormat.SetIndex(-1);
  if Cr.FSessionInfo.FIndex > (Cr.FSessionInfo.Count-1) then
    Cr.FSessionInfo.SetIndex(-1);
  if Cr.FLogOnInfo.FIndex > (Cr.FLogOnInfo.Count-1) then
    Cr.FLogOnInfo.SetIndex(-1);
  if Cr.FSQLExpressions.FIndex > (Cr.FSQLExpressions.Count-1) then
    Cr.FSQLExpressions.SetIndex(-1);
  if Cr.FTables.FIndex > (Cr.FTables.Count-1) then
    Cr.FTables.SetIndex(-1);
  if Cr.FDatabaseFields.FIndex > (Cr.FDatabaseFields.Count-1) then
    Cr.FDatabaseFields.SetIndex(-1);
  if Cr.FFormulas.FIndex > (Cr.FFormulas.Count-1) then
    Cr.FFormulas.SetIndex(-1);
  if Cr.FSummaryFields.FIndex > (Cr.FSummaryFields.Count-1) then
    Cr.FSummaryFields.SetIndex(-1);
  if Cr.FSpecialFields.FIndex > (Cr.FSpecialFields.Count-1) then
    Cr.FSpecialFields.SetIndex(-1);
  if Cr.FGroupNameFields.FIndex > (Cr.FGroupNameFields.Count-1) then
    Cr.FGroupNameFields.SetIndex(-1);
  if Cr.FRunningTotals.FIndex > (Cr.FRunningTotals.Count-1) then
    Cr.FRunningTotals.SetIndex(-1);
  if Cr.FTextObjects.FIndex > (Cr.FTextObjects.Count-1) then
    Cr.FTextObjects.SetIndex(-1);
  if Cr.FLines.FIndex > (Cr.FLines.Count-1) then
    Cr.FLines.SetIndex(-1);
  if Cr.FBoxes.FIndex > (Cr.FBoxes.Count-1) then
    Cr.FBoxes.SetIndex(-1);
  if Cr.FOleObjects.FIndex > (Cr.FOleObjects.Count-1) then
    Cr.FOleObjects.SetIndex(-1);
  if Cr.FCrossTabs.FIndex > (Cr.FCrossTabs.Count-1) then
    Cr.FCrossTabs.SetIndex(-1);
  if Cr.FPictures.FIndex > (Cr.FPictures.Count-1) then
    Cr.FPictures.SetIndex(-1);
  if Cr.FMaps.FIndex > (Cr.FMaps.Count-1) then
    Cr.FMaps.SetIndex(-1);
  if Cr.FOLAPCubes.FIndex > (Cr.FOLAPCubes.Count-1) then
    Cr.FOLAPCubes.SetIndex(-1);
end;
{------------------------------------------------------------------------------}
{ GetItems                                                                     }
{   - This is the default property and can be also set                         }
{      via Crpe1.Subreports[nIndex]                                            }
{------------------------------------------------------------------------------}
function TCrpeSubreports.GetItems(nIndex: integer) : TCrpeSubreportsItem;
begin
  SetIndex(nIndex);
  Result := TCrpeSubreportsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeSubreports.GetItem : TCrpeSubreportsItem;
begin
  Result := TCrpeSubreportsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ SetItem                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeSubreports.SetItem (const nItem: TCrpeSubreportsItem);
begin
  FItem.Assign(nItem);
end;


{******************************************************************************}
{ Class TCrpeTabStopsItem                                                      }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeTabStopsItem.Create;
begin
  inherited Create;
  FAlignment := haDefault;
  FOffset    := -1;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeTabStopsItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeTabStopsItem then
  begin
    Alignment := TCrpeTabStopsItem(Source).Alignment;
    Offset    := TCrpeTabStopsItem(Source).Offset;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeTabStopsItem.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex     := -1;
    Handle     := 0;
    FAlignment := haDefault;
    FOffset    := -1;
  end;
end;
{------------------------------------------------------------------------------}
{ StatusIsGo                                                                   }
{------------------------------------------------------------------------------}
function TCrpeTabStopsItem.StatusIsGo : Boolean;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if Handle = 0 then Exit;
  if FIndex < 0 then Exit;
  if not Cr.JobIsOpen then Exit;
  Result := True;
end;
{------------------------------------------------------------------------------}
{ SetAlignment                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeTabStopsItem.SetAlignment (const Value: TCrHorizontalAlignment);
var
  TabStopInfo : PETabStopInfo;
begin
  FAlignment := Value;
  if not StatusIsGo then Exit;

  
  if not Cr.FCrpeEngine.PEGetNthTabStopInfo (Cr.FPrintJob, Handle,
    Parent.FIndex, FIndex, TabStopInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetAlignment <PEGetNthTabStopInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if TabStopInfo.alignment <> Ord(FAlignment) then
  begin
    TabStopInfo.alignment := Ord(FAlignment);
    
    if not Cr.FCrpeEngine.PESetNthTabStopInfo(Cr.FPrintJob, Handle,
      Parent.FIndex, FIndex, TabStopInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
           Cr.BuildErrorString(Self) + 'SetAlignment <PESetNthTabStopInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetOffset                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeTabStopsItem.SetOffset (const Value: LongInt);
var
  TabStopInfo : PETabStopInfo;
begin
  FOffset := Value;
  if not StatusIsGo then Exit;

  
  if not Cr.FCrpeEngine.PEGetNthTabStopInfo (Cr.FPrintJob, Handle,
    Parent.Parent.FIndex, FIndex, TabStopInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetOffset <PEGetNthTabStopInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if TabStopInfo.xOffset <> FOffset then
  begin
    TabStopInfo.xOffset := FOffset;
    
    if not Cr.FCrpeEngine.PESetNthTabStopInfo(Cr.FPrintJob, Handle,
      Parent.Parent.FIndex, FIndex, TabStopInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
           Cr.BuildErrorString(Self) + 'SetOffset <PESetNthTabStopInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ Class TCrpeTabStops                                                          }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeTabStops.Create;
begin
  inherited Create;
  FItem  := TCrpeTabStopsItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeTabStops.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeTabStops.Clear;
var
  i : integer;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    Handle := 0;
    FItem.Clear;
  end
  else
  begin
    for i := Count-1 downto 0 do
      Delete(i);
    FIndex := -1;
  end;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeTabStops.Count : integer;
var
  nTabStops : Smallint;
begin
  Result := 0;
  if Handle = 0 then Exit;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  
  nTabStops := Cr.FCrpeEngine.PEGetNTabStopsInParagraph (Cr.FPrintJob, Handle,
    Parent.FIndex);
  if nTabStops = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'Count <PEGetNTabStopsInParagraph>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := nTabStops;
end;
{------------------------------------------------------------------------------}
{ Add                                                                          }
{------------------------------------------------------------------------------}
function TCrpeTabStops.Add (Alignment: TCrHorizontalAlignment;
  Offset: LongInt): integer;
var
  TabStopInfo : PETabStopInfo;
begin
  Result := -1;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Add the TabStop}
  TabStopInfo.alignment := Ord(Alignment);
  TabStopInfo.xOffset := Offset;
  
  if not Cr.FCrpeEngine.PEAddTabStop(Cr.FPrintJob, Handle, Parent.FIndex,
    TabStopInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'Add <PEAddTabStop>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  SetIndex(Count-1);
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Delete                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeTabStops.Delete (nTab: integer);
begin
  if Handle = 0 then Exit;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Delete the TabStop}
  
  if not Cr.FCrpeEngine.PEDeleteNthTabStop(Cr.FPrintJob, Handle,
    Parent.FIndex, nTab) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'Delete(' +
        IntToStr(nTab) + ') <PEDeleteNthTabStop>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Decrement index if necessary}
  if FIndex = Count then
    SetIndex(FIndex-1);
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeTabStops.SetIndex (nIndex: integer);
var
  TabStopInfo : PETabStopInfo;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Clear;
    Exit;
  end;
  if Handle = 0 then Exit;
  if not Cr.OpenPrintJob then Exit;

  {This part obtains the TabStop information from a Report}
  
  if not Cr.FCrpeEngine.PEGetNthTabStopInfo (Cr.FPrintJob, Handle,
    Parent.FIndex, nIndex, TabStopInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetIndex(' +
         IntToStr(nIndex) + ') <PEGetNthTabStopInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);
  FItem.FAlignment := TCrHorizontalAlignment(TabStopInfo.alignment);
  FItem.FOffset := TabStopInfo.xOffset;
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeTabStops.GetItem(nIndex: integer) : TCrpeTabStopsItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeParagraphsItem                                                    }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeParagraphsItem.Create;
begin
  inherited Create;
  FAlignment       := haDefault;
  FIndentFirstLine := 0;
  FIndentLeft      := 0;
  FIndentRight     := 0;
  FTextStart       := 0; {Read only}
  FTextEnd         := 0; {Read only}
  FTabStops        := TCrpeTabStops.Create;
  FSubClassList.Add(FTabStops);
end;
{------------------------------------------------------------------------------}
{ Destroy                                                                      }
{------------------------------------------------------------------------------}
destructor TCrpeParagraphsItem.Destroy;
begin
  FTabStops.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeParagraphsItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeParagraphsItem then
  begin
    Alignment       := TCrpeParagraphsItem(Source).Alignment;
    IndentFirstLine := TCrpeParagraphsItem(Source).IndentFirstLine;
    IndentLeft      := TCrpeParagraphsItem(Source).IndentLeft;
    IndentRight     := TCrpeParagraphsItem(Source).IndentRight;
    TextStart       := TCrpeParagraphsItem(Source).TextStart;
    TextEnd         := TCrpeParagraphsItem(Source).TextEnd;
    TabStops.Assign(TCrpeParagraphsItem(Source).TabStops);
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeParagraphsItem.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex           := -1;
    Handle           := 0;
    FAlignment       := haDefault;
    FIndentFirstLine := 0;
    FIndentLeft      := 0;
    FIndentRight     := 0;
    FTextStart       := 0; {Read only}
    FTextEnd         := 0; {Read only}
  end
  else
  begin
    SetAlignment(haDefault);
    SetIndentFirstLine(0);
    SetIndentLeft(0);
    SetIndentRight(0);
  end;
  FTabStops.Clear;
end;
{------------------------------------------------------------------------------}
{ StatusIsGo                                                                   }
{------------------------------------------------------------------------------}
function TCrpeParagraphsItem.StatusIsGo : Boolean;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if Handle = 0 then
  begin
    PropagateHandle(0);
    Exit;
  end;
  if FIndex < 0 then
  begin
    PropagateIndex(-1);
    Exit;
  end;
  if not Cr.JobIsOpen then Exit;
  Result := True;
end;
{------------------------------------------------------------------------------}
{ SetAlignment                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeParagraphsItem.SetAlignment (const Value: TCrHorizontalAlignment);
var
  ParagraphInfo : PEParagraphInfo;
begin
  FAlignment := Value;
  if not StatusIsGo then Exit;

  
  if not Cr.FCrpeEngine.PEGetNthParagraphInfo(Cr.FPrintJob, Handle,
    FIndex, paragraphInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetAlignment <PEGetNthParagraphInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if ParagraphInfo.alignment <> Ord(FAlignment) then
  begin
    ParagraphInfo.alignment := Ord(FAlignment);
    
    if not Cr.FCrpeEngine.PESetNthParagraphInfo(Cr.FPrintJob, Handle,
      FIndex, ParagraphInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
           Cr.BuildErrorString(Self) + 'SetAlignment <PESetNthParagraphInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetIndentFirstLine                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeParagraphsItem.SetIndentFirstLine (const Value: LongInt);
var
  ParagraphInfo : PEParagraphInfo;
begin
  FIndentFirstLine := Value;
  if not StatusIsGo then Exit;

  
  if not Cr.FCrpeEngine.PEGetNthParagraphInfo(Cr.FPrintJob, Handle,
    FIndex, paragraphInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetIndentFirstLine <PEGetNthParagraphInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if ParagraphInfo.firstLineIndent <> FIndentFirstLine then
  begin
    ParagraphInfo.firstLineIndent := FIndentFirstLine;
    
    if not Cr.FCrpeEngine.PESetNthParagraphInfo(Cr.FPrintJob, Handle,
      FIndex, ParagraphInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
           Cr.BuildErrorString(Self) + 'SetIndentFirstLine <PESetNthParagraphInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetIndentLeft                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeParagraphsItem.SetIndentLeft (const Value: LongInt);
var
  ParagraphInfo : PEParagraphInfo;
begin
  FIndentLeft := Value;
  if not StatusIsGo then Exit;

  
  if not Cr.FCrpeEngine.PEGetNthParagraphInfo(Cr.FPrintJob, Handle,
    FIndex, paragraphInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetIndentLeft <PEGetNthParagraphInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if ParagraphInfo.leftIndent <> FIndentLeft then
  begin
    ParagraphInfo.leftIndent := FIndentLeft;
    
    if not Cr.FCrpeEngine.PESetNthParagraphInfo(Cr.FPrintJob, Handle,
      FIndex, ParagraphInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
           Cr.BuildErrorString(Self) + 'SetIndentLeft <PESetNthParagraphInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetIndentRight                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeParagraphsItem.SetIndentRight (const Value: LongInt);
var
  ParagraphInfo : PEParagraphInfo;
begin
  FIndentRight := Value;
  if not StatusIsGo then Exit;

  
  if not Cr.FCrpeEngine.PEGetNthParagraphInfo(Cr.FPrintJob, Handle,
    FIndex, paragraphInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetIndentRight <PEGetNthParagraphInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if ParagraphInfo.rightIndent <> FIndentRight then
  begin
    ParagraphInfo.rightIndent := FIndentRight;
    
    if not Cr.FCrpeEngine.PESetNthParagraphInfo(Cr.FPrintJob, Handle,
      FIndex, ParagraphInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
           Cr.BuildErrorString(Self) + 'SetIndentRight <PESetNthParagraphInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetTextStart                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeParagraphsItem.SetTextStart (const Value: LongInt);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetTextEnd                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeParagraphsItem.SetTextEnd (const Value: LongInt);
begin
  {Read only}
end;


{******************************************************************************}
{ Class TCrpeParagraphs                                                        }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeParagraphs.Create;
begin
  inherited Create;
  FItem  := TCrpeParagraphsItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destroy                                                                      }
{------------------------------------------------------------------------------}
destructor TCrpeParagraphs.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeParagraphs.Clear;
var
  i,j : integer;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    Handle := 0;
    FItem.Clear;
  end
  else
  begin
    j := FIndex;
    for i := 0 to Count-1 do
      Items[i].Clear;
    SetIndex(j);
  end;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeParagraphs.Count : integer;
var
  nParagraphs: Smallint;
begin
  Result := 0;
  if Handle = 0 then Exit;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  
  nParagraphs := Cr.FCrpeEngine.PEGetNParagraphs(Cr.FPrintJob, Handle);
  if nParagraphs = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'Count <PEGetNParagraphs>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := nParagraphs;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeParagraphs.SetIndex (nIndex: integer);
var
  ParagraphInfo : PEParagraphInfo;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    Clear;
    Exit;
  end;
  if Handle = 0 then
  begin
    PropagateHandle(0);
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;

  PropagateHandle(Handle);
  {This part obtains the TabStop information from a Report}
  
  if not Cr.FCrpeEngine.PEGetNthParagraphInfo (Cr.FPrintJob, Handle,
    nIndex, ParagraphInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetIndex(' +
         IntToStr(nIndex) + ') <PEGetNthParagraphInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);
  FItem.FAlignment := TCrHorizontalAlignment(ParagraphInfo.alignment);
  FItem.FIndentFirstLine := ParagraphInfo.firstLineIndent;
  FItem.FIndentLeft := ParagraphInfo.leftIndent;
  FItem.FIndentRight := ParagraphInfo.rightIndent;
  FItem.FTextStart := ParagraphInfo.startText;
  FItem.FTextEnd := ParagraphInfo.endText;
  {TabStops}
  if FItem.FTabStops.FIndex > (FItem.FTabStops.Count-1) then
    FItem.FTabStops.SetIndex(-1);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeParagraphs.GetItem(nIndex: integer) : TCrpeParagraphsItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeEmbeddedFieldsItem                                                }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeEmbeddedFieldsItem.Create;
begin
  inherited Create;
  FFieldType         := fvUnknown;
  FFieldObjectType   := oftNone;
  FFieldName         := ''; {Read only}
  FTextStart         := 0;  {Read only}
  FTextEnd           := 0;  {Read only}
  {Format}
  FFormat            := TCrpeFieldObjectFormat.Create;
  FSubClassList.Add(FFormat);
  {Border}
  FBorder            := TCrpeBorder.Create;
  FSubClassList.Add(FBorder);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeEmbeddedFieldsItem.Destroy;
begin
  FFormat.Free;
  FBorder.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeEmbeddedFieldsItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeEmbeddedFieldsItem then
  begin
    FieldType       := TCrpeEmbeddedFieldsItem(Source).FieldType;
    FieldObjectType := TCrpeEmbeddedFieldsItem(Source).FieldObjectType;
    FieldName       := TCrpeEmbeddedFieldsItem(Source).FieldName;
    TextStart       := TCrpeEmbeddedFieldsItem(Source).TextStart;
    TextEnd         := TCrpeEmbeddedFieldsItem(Source).TextEnd;
    Format.Assign(TCrpeEmbeddedFieldsItem(Source).Format);
    Border.Assign(TCrpeEmbeddedFieldsItem(Source).Border);
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeEmbeddedFieldsItem.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) or (Handle = 0) then
  begin
    FIndex := -1;
    Handle := 0;
    SetFieldType(fvUnknown);
    FFieldObjectType := oftNone;
    FFieldName       := ''; {Read only}
    FTextStart       := 0;  {Read only}
    FTextEnd         := 0;  {Read only}
  end;
  FFormat.Clear;
  FBorder.Clear;
end;
{------------------------------------------------------------------------------}
{ SetFieldType                                                                 }
{  - propagates the FieldType to subclasses                                    }
{------------------------------------------------------------------------------}
procedure TCrpeEmbeddedFieldsItem.SetFieldType(FType: TCrFieldValueType);
begin
  FFieldType := FType;
  FFormat.SetFieldType(FType);
end;
{------------------------------------------------------------------------------}
{ SetFieldN                                                                    }
{  - propagates the FieldN to subclasses                                       }
{------------------------------------------------------------------------------}
procedure TCrpeEmbeddedFieldsItem.SetFieldN(nField: Smallint);
begin
  FFieldN := nField;
  FFormat.SetFNum(nField);
  FBorder.SetFNum(nField);
end;
{------------------------------------------------------------------------------}
{ SetFieldName                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeEmbeddedFieldsItem.SetFName (const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetFieldObjectType                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeEmbeddedFieldsItem.SetFObjectType (const Value: TCrFieldObjectType);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetFieldType                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeEmbeddedFieldsItem.SetFType (const Value: TCrFieldValueType);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetTextStart                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeEmbeddedFieldsItem.SetTextStart (const Value: LongInt);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetTextEnd                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeEmbeddedFieldsItem.SetTextEnd (const Value: LongInt);
begin
  {Read only}
end;


{******************************************************************************}
{ Class TCrpeEmbeddedFields                                                    }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeEmbeddedFields.Create;
begin
  inherited Create;
  FItem := TCrpeEmbeddedFieldsItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeEmbeddedFields.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeEmbeddedFields.Clear;
var
  i : integer;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (Handle = 0) or (Count = 0) then
  begin
    FIndex := -1;
    Handle := 0;
    FItem.Clear;
  end
  else
  begin
    for i := Count-1 downto 0 do
      begin
        FIndex := i;
        Delete(i);
      end;
    FIndex := -1;
  end;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeEmbeddedFields.Count : integer;
var
  nFields : integer;
begin
  Result := 0;
  if Handle = 0 then Exit;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  
  nFields := Cr.FCrpeEngine.PEGetNEmbeddedFields(Cr.FPrintJob, Handle);
  if nFields = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'Count <PEGetNEmbeddedFields>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := nFields;
end;
{------------------------------------------------------------------------------}
{ Delete                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeEmbeddedFields.Delete (nField: integer);
begin
  if Handle = 0 then Exit;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEDeleteNthEmbeddedField(Cr.FPrintJob, Handle, nField) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'Delete(' + IntToStr(nField) +
         ') <PEDeleteNthEmbeddedField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Insert                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeEmbeddedFields.Insert (FieldName: string; Position: LongInt);
begin
  if Handle = 0 then Exit;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  
  if not Cr.FCrpeEngine.PEInsertEmbeddedField(Cr.FPrintJob, Handle, Position,
    PChar(FieldName)) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'Insert <PEInsertEmbeddedField> ' + FieldName) of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  SetIndex(Count-1);
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeEmbeddedFields.SetIndex (nIndex: integer);
var
  EmbeddedFieldInfo : PEEmbeddedFieldInfo;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if (nIndex < 0) then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    Clear;
    Exit;
  end;
  if Handle = 0 then
  begin
    PropagateHandle(0);
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;

  PropagateHandle(Handle);
  {This part obtains the EmbeddedField information from a Report}
  
  if not Cr.FCrpeEngine.PEGetNthEmbeddedFieldInfo (Cr.FPrintJob, Handle,
    nIndex, EmbeddedFieldInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetIndex(' +
         IntToStr(nIndex) + ') <PEGetNthEmbeddedFieldInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
 
  PropagateIndex(nIndex);
  FItem.FFieldObjectType := TCrFieldObjectType(EmbeddedFieldInfo.fieldType);
  FItem.SetFieldType(Cr.GetFieldTypeFromName(EmbeddedFieldInfo.fieldName));
  FItem.SetFieldN(FIndex);
  FItem.FFieldName := String(EmbeddedFieldInfo.fieldName);
  FItem.FTextStart := EmbeddedFieldInfo.startText;
  FItem.FTextEnd := EmbeddedFieldInfo.endText;
  if csDesigning in Cr.ComponentState then
  begin
    FItem.FBorder.GetBorder;
    FItem.FFormat.Field.Paragraph.FForEmbeddedField := True;
    FItem.FFormat.Field.Paragraph.FForTextObject := False;
    FItem.FFormat.GetFormat;
  end;
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeEmbeddedFields.GetItem(nIndex: integer): TCrpeEmbeddedFieldsItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{******************************************************************************}
{ Field Objects                                                                }
{******************************************************************************}
{******************************************************************************}

{******************************************************************************}
{ Class TCrpeDatabaseFieldsItem                                                }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeDatabaseFieldsItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeDatabaseFieldsItem then
  begin
    {nothing at this time...}
  end;
  inherited Assign(Source);
end;


{******************************************************************************}
{ Class TCrpeDatabaseFields                                                    }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeDatabaseFields.Create;
begin
  inherited Create;
  {Set inherited ObjectInfo properties}
  FObjectType := otField;
  FFieldObjectType := oftDatabase;
  FItem := TCrpeDatabaseFieldsItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destroy                                                                      }
{------------------------------------------------------------------------------}
destructor TCrpeDatabaseFields.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeDatabaseFields.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) or (Handle = 0) then
  begin
    FIndex := -1;
    FItem.Clear;
  end;
end;
{------------------------------------------------------------------------------}
{ IndexOf                                                                      }
{------------------------------------------------------------------------------}
function TCrpeDatabaseFields.IndexOf (FieldName: string): integer;
var
  iCurrent : integer;
  cnt      : integer;
begin
  Result := -1;
  {Store current index}
  iCurrent := FIndex;
  {Locate formula name}
  for cnt := 0 to (Count-1) do
  begin
    SetIndex(cnt);
    if CompareText(FItem.FieldName, FieldName) = 0 then
    begin
      Result := cnt;
      Break;
    end;
  end;
  {Re-set index}
  SetIndex(iCurrent);
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeDatabaseFields.SetIndex (nIndex: integer);
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Clear;
    Exit;
  end;
  inherited SetIndex(nIndex);
  PropagateHandle(Handle);
  if Handle = 0 then Exit;

  {Update Border, Format, Font}
  if csDesigning in Cr.ComponentState then
  begin
    FItem.Border.GetBorder;
    FItem.Format.GetFormat;
    FItem.Font.GetFont;
  end;
  {Update HiliteConditions}
  if Item.FHiliteConditions.FIndex > (Item.FHiliteConditions.Count-1) then
    Item.FHiliteConditions.SetIndex(-1);
end;
{------------------------------------------------------------------------------}
{ GetItems                                                                     }
{------------------------------------------------------------------------------}
function TCrpeDatabaseFields.GetItems(nIndex: integer) : TCrpeDatabaseFieldsItem;
begin
  SetIndex(nIndex);
  Result := TCrpeDatabaseFieldsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeDatabaseFields.GetItem : TCrpeDatabaseFieldsItem;
begin
  Result := TCrpeDatabaseFieldsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ SetItem                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeDatabaseFields.SetItem (const nItem: TCrpeDatabaseFieldsItem);
begin
  FItem.Assign(nItem);
end;


{******************************************************************************}
{ Class TCrpeFormulasItem                                                       }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeFormulasItem.Create;
begin
  inherited Create;
  FName    := '';
  FFormula := TStringList.Create;
  xFormula := TStringList.Create;
  TStringList(FFormula).OnChange := OnChangeFormula;
end;
{------------------------------------------------------------------------------}
{ Destroy                                                                      }
{------------------------------------------------------------------------------}
destructor TCrpeFormulasItem.Destroy;
begin
  TStringList(FFormula).OnChange := nil;
  FFormula.Free;
  xFormula.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeFormulasItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeFormulasItem then
  begin
    TStringList(FFormula).OnChange := nil;
    Formula.Assign(TCrpeFormulasItem(Source).Formula);
    TStringList(FFormula).OnChange := OnChangeFormula;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeFormulasItem.Clear;
begin
  inherited Clear;
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex  := -1;
    Handle  := 0;
    FName   := '';
    FFormula.Clear;
    xFormula.Clear;
  end
  else
  begin
    xFormula.Clear;
    SetFormula(xFormula);
  end;
end;
{------------------------------------------------------------------------------}
{ Check                                                                        }
{------------------------------------------------------------------------------}
function TCrpeFormulasItem.Check : Boolean;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if FIndex < 0 then Exit;
  if not Cr.OpenPrintJob then Exit;
  {Check the Formula}
  
  Result := Cr.FCrpeEngine.PECheckFormula(Cr.FPrintJob, PChar(FName));
  if Result = False then
    Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'Check <PECheckFormula>');
end;
{------------------------------------------------------------------------------}
{ OnChangeFormula                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeFormulasItem.OnChangeFormula(Sender: TObject);
begin
  xFormula.Assign(FFormula);
  SetFormula(xFormula);
end;
{------------------------------------------------------------------------------}
{ SetName                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeFormulasItem.SetName(const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetFormula                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeFormulasItem.SetFormula (const ListVar: TStrings);
var
  iText : Smallint;
  hText : hWnd;
  pText : PChar;
  sText : string;
  sTmp  : string;

begin
  TStringList(FFormula).OnChange := nil;
  FFormula.Assign(ListVar);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo (FIndex) then Exit;

  {Retrieve the Formula currently in the Report}
  
  if not Cr.FCrpeEngine.PEGetFormula(Cr.FPrintJob, PChar(FName), hText, iText) then
  begin
    TStringList(FFormula).OnChange := OnChangeFormula;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetFormula <PEGetFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get the Formula Text}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FFormula).OnChange := OnChangeFormula;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetFormula <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sText := String(pText);
  StrDispose(pText);

  {Trim of LF/CR characters}
  sTmp := RTrimList(FFormula);
  {Compare it to the new formula...If they are the same, do not send}
  if CompareStr(sTmp, sText) <> 0 then
  begin
    {Send the Formula to the Report}
    
    if not Cr.FCrpeEngine.PESetFormula(Cr.FPrintJob, PChar(FName), PChar(sTmp)) then
    begin
      TStringList(FFormula).OnChange := OnChangeFormula;
      case Cr.GetErrorMsg(Cr.FPrintJob,{errFormula}errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetFormula <PESetFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
  TStringList(FFormula).OnChange := OnChangeFormula;
end;


{******************************************************************************}
{ Class TCrpeFormulas                                                          }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeFormulas.Create;
begin
  inherited Create;
  {Set inherited ObjectInfo properties}
  FObjectType      := otField;
  FFieldObjectType := oftFormula;
  FName            := '';
  FNames           := TStringList.Create;
  FItem            := TCrpeFormulasItem.Create;
  FSubClassList.Add(FItem);
  FObjectPropertiesActive := True;
end;
{------------------------------------------------------------------------------}
{ Destroy                                                                      }
{------------------------------------------------------------------------------}
destructor TCrpeFormulas.Destroy;
begin
  FNames.Free;
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeFormulas.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    Handle := 0;
    FName  := '';
    FItem.Clear;
  end;
  FNames.Clear;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeFormulas.Count : integer;
var
  nFormulas : Smallint;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get number of Formulas}
  
  nFormulas := Cr.FCrpeEngine.PEGetNFormulas(Cr.FPrintJob);
  if nFormulas = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Formulas.Count <PEGetNFormulas>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := nFormulas;
end;
{------------------------------------------------------------------------------}
{ IndexOf                                                                      }
{------------------------------------------------------------------------------}
function TCrpeFormulas.IndexOf(FormulaName: string): integer;
var
  cnt : integer;
begin
  Result := -1;
  {Locate formula name}
  if FNames.Count > 0 then
  begin
    for cnt := 0 to FNames.Count-1 do
    begin
      if CompareText(FNames[cnt], FormulaName) = 0 then
      begin
        Result := cnt;
        Break;
      end;
    end;
  end;
  {If the Names list hasn't been built yet, or it wasn't found...}
  if Result = -1 then
  begin
    Names;
    {Locate formula name}
    for cnt := 0 to FNames.Count-1 do
    begin
      if CompareText(FNames[cnt], FormulaName) = 0 then
      begin
        Result := cnt;
        Break;
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ByName                                                                       }
{------------------------------------------------------------------------------}
function TCrpeFormulas.ByName (FormulaName: string): TCrpeFormulasItem;
var
  i : integer;
begin
  Result := GetItem;
  i := IndexOf(FormulaName);
  if i = -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_FORMULA_BY_NAME,
        'Formulas.ByName') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := GetItems(i);
end;
{------------------------------------------------------------------------------}
{  Names                                                                       }
{  - returns a list of Formula Names.  Faster than looping through items.      }
{------------------------------------------------------------------------------}
function TCrpeFormulas.Names : TStrings;
var
  iName    : Smallint;
  hName    : HWnd;
  hFormula : HWnd;
  pName    : PChar;
  iFormula : Smallint;
  i        : integer;
begin
  FNames.Clear;
  Result := FNames;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  for i := 0 to Count-1 do
  begin
    {Retrieve formula}
    iName := 0;
    iFormula := 0;
    
    if not Cr.FCrpeEngine.PEGetNthFormula(Cr.FPrintJob, i, hName, iName, hFormula, iFormula) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Formulas.GetNames <PEGetNthFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    {Get Formula Name}
    pName := StrAlloc(iName);
    if not Cr.FCrpeEngine.PEGetHandleString(hName, pName, iName) then
    begin
      StrDispose(pName);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Formulas.Names <PEGetHandleString>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    FNames.Add(String(pName));
    StrDispose(pName);
  end;
  Result := FNames;
end;
{------------------------------------------------------------------------------}
{ SetName                                                                      }
{  - SetName does not overwrite the value,                                     }
{    it acts as a lookup for the name specified                                }
{------------------------------------------------------------------------------}
procedure TCrpeFormulas.SetName(const Value: string);
var
  nIndex : integer;
begin
  if IsStrEmpty(Value) then
  begin
    SetIndex(-1);
    Exit;
  end;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if (Cr = nil) then Exit;
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
        'Formulas.Name := ' + Value) of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetObjectPropertiesActive                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeFormulas.SetObjectPropertiesActive (const Value: Boolean);
begin
  FObjectPropertiesActive := Value;
  SetIndex(FIndex);
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeFormulas.SetIndex (nIndex: integer);
var
  hName      : HWnd;
  iName      : Smallint;
  sName      : string;
  hText      : HWnd;
  pText      : PChar;
  iText      : Smallint;
  objIndex   : integer;
  objectInfo : PEObjectInfo;
  fieldInfo  : PEFieldObjectInfo;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    Clear;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;

  {Retrieve formula}
  
  if not Cr.FCrpeEngine.PEGetNthFormula(Cr.FPrintJob, nIndex, hName, iName, hText, iText) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Formulas.SetIndex(' + IntToStr(nIndex) + ') <PEGetNthFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);

  {Get Formula Name}
  pText := StrAlloc(iName);
  if not Cr.FCrpeEngine.PEGetHandleString(hName, pText, iName) then
  begin
    StrDispose(pText);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Formulas.SetIndex(' + IntToStr(nIndex) + ') <PEGetHandleString - Formula Name>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FName := String(pText);
  Item.FName := String(pText);
  StrDispose(pText);

  {Get Formula Text}
  TStringList(Item.FFormula).OnChange := nil;
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Formulas.SetIndex(' + IntToStr(nIndex) + ') <PEGetHandleString - Formula Text>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FFormula.SetText(pText);
  TStringList(Item.FFormula).OnChange := Item.OnChangeFormula;
  StrDispose(pText);

  {Attempt to Retrieve Handle}
  sName := NameToCrFormulaFormat(FName, 'Formulas');
  if FObjectPropertiesActive then
    Handle := Cr.GetFieldObjectHandle(sName, oftFormula, objIndex)
  else  {if False, ignore Object Properties}
    Handle := 0;
  PropagateHandle(Handle);
  if Handle = 0 then
  begin
    {Item doesn't exist on the Report, still may be in the Formulas list}
    Item.FFieldName   := '';
    Item.SetFieldType(fvUnknown);
    Item.FFieldLength :=  0;
    Item.FTop         := -1;
    Item.FLeft        := -1;
    Item.FWidth       := -1;
    Item.FHeight      := -1;
    Item.FSection     := '';
    Item.FBorder.Clear;
    Item.FFormat.Clear;
    Item.FFont.Clear;
    Item.FHiliteConditions.Clear;
    Exit;
  end;

  {Update Border, Format, Font}
  if csDesigning in Cr.ComponentState then
  begin
    FItem.Border.GetBorder;
    FItem.Format.GetFormat;
    FItem.Font.GetFont;
  end;
  {Update HiliteConditions}
  if Item.FHiliteConditions.FIndex > (Item.FHiliteConditions.Count-1) then
    Item.FHiliteConditions.SetIndex(-1);

  {Object Info}
  
  if not Cr.FCrpeEngine.PEGetObjectInfo(Cr.FPrintJob, Handle, objectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Formulas.SetIndex(' + IntToStr(nIndex) + ') <PEGetObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FLeft := objectInfo.xOffset;
  Item.FTop := objectInfo.yOffset;
  Item.FWidth := objectInfo.width;
  Item.FHeight := objectInfo.height;
  Item.FSection := Cr.SectionCodeToStringEx(objectInfo.sectionCode, False);
  {Field Object Info}
  
  if not Cr.FCrpeEngine.PEGetFieldObjectInfo(Cr.FPrintJob, Handle, fieldInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormula,errEngine,'',
        'Formulas.SetIndex(' + IntToStr(nIndex) + ') <PEGetFieldObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FFieldName := String(fieldInfo.fieldName);
  if fieldInfo.valueType = PE_FVT_UNKNOWNFIELD then
    Item.SetFieldType(fvUnknown)
  else
    Item.SetFieldType(TCrFieldValueType(fieldInfo.valueType));
  Item.FFieldLength    := fieldInfo.nBytes;
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.Formulas[nIndex]                                              }
{------------------------------------------------------------------------------}
function TCrpeFormulas.GetItems(nIndex: integer) : TCrpeFormulasItem;
begin
  SetIndex(nIndex);
  Result := TCrpeFormulasItem(FItem);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeFormulas.GetItem : TCrpeFormulasItem;
begin
  Result := TCrpeFormulasItem(FItem);
  
end;
{------------------------------------------------------------------------------}
{ SetItem                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeFormulas.SetItem (const nItem: TCrpeFormulasItem);
begin
  FItem.Assign(nItem);
end;


{******************************************************************************}
{ Class TCrpeSummaryFieldsItem                                                 }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeSummaryFieldsItem.Create;
begin
  inherited Create;
  {SummaryField specific}
  FName             := '';
  FSummarizedField  := '';
  FSummaryType      := stCount;
  {SummaryTypeN only applies to certain SummaryTypes, ie. stPercentage}
  FSummaryTypeN     := -1;
  {SummaryTypeField only applies to certain SummaryTypes, ie. stCorrelation}
  FSummaryTypeField := '';
  FHeaderAreaCode   := '';
  FFooterAreaCode   := '';
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryFieldsItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeSummaryFieldsItem then
  begin
    Name             := TCrpeSummaryFieldsItem(Source).Name;
    SummarizedField  := TCrpeSummaryFieldsItem(Source).SummarizedField;
    SummaryType      := TCrpeSummaryFieldsItem(Source).SummaryType;
    SummaryTypeN     := TCrpeSummaryFieldsItem(Source).SummaryTypeN;
    SummaryTypeField := TCrpeSummaryFieldsItem(Source).SummaryTypeField;
    HeaderAreaCode   := TCrpeSummaryFieldsItem(Source).HeaderAreaCode;
    FooterAreaCode   := TCrpeSummaryFieldsItem(Source).FooterAreaCode;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryFieldsItem.Clear;
begin
  inherited Clear;
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    Handle := 0;
    {clear other summary specific variables}
    FName             := '';
    FSummarizedField  := '';
    FSummaryType      := stCount;
    {SummaryTypeN only applies to certain SummaryTypes, ie. stPercentage}
    FSummaryTypeN     := -1;
    {SummaryTypeField only applies to certain SummaryTypes, ie. stCorrelation}
    FSummaryTypeField := '';
    FHeaderAreaCode   := '';
    FFooterAreaCode   := '';
  end;
end;
{------------------------------------------------------------------------------}
{ ChangeType                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryFieldsItem.ChangeType (SumType: TCrSummaryType);
var
  SectionCode : Smallint;
  nGroup      : Smallint;
  xHandle     : HWnd;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if FIndex < 0 then Exit;
  if not Cr.OpenPrintJob then Exit;

  if not StrToSectionCode(FFooterAreaCode, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'SummaryFields.ChangeType <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  if SectionCode = PE_GRANDTOTALSECTION then
    nGroup := -1
  else
    nGroup := SectionCode mod 25;
  

  xHandle := Cr.FCrpeEngine.PEChangeSummaryType(Cr.FPrintJob, PChar(FSummarizedField),
     nGroup, Ord(FSummaryType), Ord(SumType));

  {Error check}
  if xHandle = 0 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'Add <PEChangeSummaryType>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetName                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryFieldsItem.SetName (const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetSummarizedField                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryFieldsItem.SetSummarizedField (const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetSummaryType                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryFieldsItem.SetSummaryType (const Value: TCrSummaryType);
begin
  ChangeType(Value);
end;
{------------------------------------------------------------------------------}
{ SetSummaryTypeN                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryFieldsItem.SetSummaryTypeN (const Value: Smallint);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetSummaryTypeField                                                          }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryFieldsItem.SetSummaryTypeField (const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetHeaderAreaCode                                                            }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryFieldsItem.SetHeaderAreaCode (const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetFooterAreaCode                                                            }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryFieldsItem.SetFooterAreaCode (const Value: string);
begin
  {Read only}
end;


{******************************************************************************}
{ Class TCrpeSummaryFields                                                     }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeSummaryFields.Create;
begin
  inherited Create;
  {Set inherited ObjectInfo properties}
  FObjectType := otField;
  FFieldObjectType := oftSummary;
  FItem := TCrpeSummaryFieldsItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSummaryFields.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryFields.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    FItem.Clear;
  end;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryFields.SetIndex (nIndex: integer);
var
  SummaryFieldInfo : PESummaryFieldInfo;
  objectInfo       : PEObjectInfo;
  fieldInfo        : PEFieldObjectInfo;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    Clear;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;

  
  if not Cr.FCrpeEngine.PEGetNthSummaryFieldInfo(Cr.FPrintJob, nIndex, SummaryFieldInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetNthSummaryFieldInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);
  Item.FSummaryType := TCrSummaryType(SummaryFieldInfo.summaryType);
  Item.FName := String(SummaryFieldInfo.fieldName);
  Item.FSummarizedField := String(SummaryFieldInfo.summarizedFieldName);
  Item.FSummaryTypeN := SummaryFieldInfo.summaryParameter;
  Item.FSummaryTypeField := String(SummaryFieldInfo.secondSummarizedFieldName);
  Item.FHeaderAreaCode := Cr.SectionCodeToStringEx(SummaryFieldInfo.headerAreaCode, False);
  Item.FFooterAreaCode := Cr.SectionCodeToStringEx(SummaryFieldInfo.footerAreaCode, False);

  {Get Handle: must count in reverse since Cr.FCrpeEngine.PEGetNthSummaryField and
   Cr.FCrpeEngine.PEGetObject count the fields from different directions}

  Handle := Cr.GetObjectHandle((Count-1)-nIndex, FObjectType, FFieldObjectType);
  PropagateHandle(Handle);
  if Handle = 0 then
  begin
    {Item doesn't exist on the Report, still may be in the SummaryFields list?}
    Item.FFieldName   := '';
    Item.SetFieldType(fvUnknown);
    Item.FFieldLength :=  0;
    Item.FTop         := -1;
    Item.FLeft        := -1;
    Item.FWidth       := -1;
    Item.FHeight      := -1;
    Item.FSection     := '';
    Item.FBorder.Clear;
    Item.FFormat.Clear;
    Item.FFont.Clear;
    Item.FHiliteConditions.Clear;
    Exit;
  end;

  {Update Border, Format, Font}
  if csDesigning in Cr.ComponentState then
  begin
    Item.FBorder.GetBorder;
    Item.FFormat.GetFormat;
    Item.FFont.GetFont;
  end;
  {Update HiliteConditions}
  if Item.FHiliteConditions.FIndex > (Item.FHiliteConditions.Count-1) then
    Item.FHiliteConditions.SetIndex(-1);

  {Get Object Info}
  
  if not Cr.FCrpeEngine.PEGetObjectInfo(Cr.FPrintJob, Handle, objectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' + IntToStr(nIndex) +
        ') <PEGetObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FItem.Left := objectInfo.xOffset;
  FItem.Top := objectInfo.yOffset;
  FItem.Width := objectInfo.width;
  FItem.Height := objectInfo.height;
  FItem.Section := Cr.SectionCodeToStringEx(objectInfo.sectionCode, False);

  {Field Object Info}
  
  if not Cr.FCrpeEngine.PEGetFieldObjectInfo(Cr.FPrintJob, Handle, fieldInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormula,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' + IntToStr(nIndex) +
        ') <PEGetFieldObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FFieldName := String(fieldInfo.fieldName);
  if fieldInfo.valueType = PE_FVT_UNKNOWNFIELD then
    Item.SetFieldType(fvUnknown)
  else
    Item.SetFieldType(TCrFieldValueType(fieldInfo.valueType));
  Item.FFieldLength := fieldInfo.nBytes;
  
end;
{------------------------------------------------------------------------------}
{ GetItems                                                                     }
{------------------------------------------------------------------------------}
function TCrpeSummaryFields.GetItems(nIndex: integer) : TCrpeSummaryFieldsItem;
begin
  SetIndex(nIndex);
  Result := TCrpeSummaryFieldsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeSummaryFields.GetItem : TCrpeSummaryFieldsItem;
begin
  Result := TCrpeSummaryFieldsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ SetItem                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeSummaryFields.SetItem (const nItem: TCrpeSummaryFieldsItem);
begin
  FItem.Assign(nItem);
end;


{******************************************************************************}
{ Class TCrpeSpecialFieldsItem                                                 }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSpecialFieldsItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeSpecialFieldsItem then
  begin
    {nothing at this time...}
  end;
  inherited Assign(Source);
end;


{******************************************************************************}
{ Class TCrpeSpecialFields                                                     }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeSpecialFields.Create;
begin
  inherited Create;
  {Set inherited ObjectInfo properties}
  FObjectType      := otField;
  FFieldObjectType := oftSpecialVar;
  FItem := TCrpeSpecialFieldsItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSpecialFields.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSpecialFields.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) or (Handle = 0) then
  begin
    FIndex := -1;
    Handle := 0;
    FItem.Clear;
  end;
end;
{------------------------------------------------------------------------------}
{ IndexOf                                                                      }
{------------------------------------------------------------------------------}
function TCrpeSpecialFields.IndexOf (FieldName: string): integer;
var
  iCurrent : integer;
  cnt      : integer;
  s        : string;
begin
  Result := -1;
  {Store current index}
  iCurrent := FIndex;
  s := RemoveSpaces(FieldName);
  {Locate formula name}
  for cnt := 0 to (Count-1) do
  begin
    SetIndex(cnt);
    if CompareText(FItem.FieldName, s) = 0 then
    begin
      Result := cnt;
      Break;
    end;
  end;
  {Re-set index}
  SetIndex(iCurrent);
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeSpecialFields.SetIndex (nIndex: integer);
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    Clear;
    Exit;
  end;
  inherited SetIndex(nIndex);
  PropagateHandle(Handle);
  if Handle = 0 then
    Exit;

  if csDesigning in Cr.ComponentState then
  begin
    Item.FBorder.GetBorder;
    Item.FFormat.GetFormat;
    Item.FFont.GetFont;
  end;
  {HiliteConditions}
  if Item.FHiliteConditions.FIndex > (Item.FHiliteConditions.Count-1) then
    Item.FHiliteConditions.SetIndex(-1);
end;
{------------------------------------------------------------------------------}
{ GetItems                                                                     }
{------------------------------------------------------------------------------}
function TCrpeSpecialFields.GetItems(nIndex: integer) : TCrpeSpecialFieldsItem;
begin
  SetIndex(nIndex);
  Result := TCrpeSpecialFieldsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeSpecialFields.GetItem : TCrpeSpecialFieldsItem;
begin
  Result := TCrpeSpecialFieldsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ SetItem                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeSpecialFields.SetItem (const nItem : TCrpeSpecialFieldsItem);
begin
  FItem.Assign(nItem);
end;


{******************************************************************************}
{ Class TCrpeGroupNameFieldsItem                                               }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeGroupNameFieldsItem.Create;
begin
  inherited Create;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGroupNameFieldsItem.Clear;
begin
  inherited Clear;
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) or (Handle = 0) then
  begin
    FIndex := -1;
    Handle := 0;
  end;
end;


{******************************************************************************}
{ Class TCrpeGroupNameFields                                                   }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeGroupNameFields.Create;
begin
  inherited Create;
  {Set inherited ObjectInfo properties}
  FObjectType      := otField;
  FFieldObjectType := oftGroupName;
  FItem := TCrpeGroupNameFieldsItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeGroupNameFields.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeGroupNameFields.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) or (Handle = 0) then
  begin
    FIndex := -1;
    Handle := 0;
    FItem.Clear;
  end;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeGroupNameFields.SetIndex (nIndex: integer);
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Clear;
    Exit;
  end;
  inherited SetIndex(nIndex);
  PropagateHandle(Handle);
  if Handle = 0 then
    Exit;

  {Update Border, Format, Font}
  if csDesigning in Cr.ComponentState then
  begin
    FItem.Border.GetBorder;
    FItem.Format.GetFormat;
    FItem.Font.GetFont;
  end;
  {Update HiliteConditions}
  if Item.FHiliteConditions.FIndex > (Item.FHiliteConditions.Count-1) then
    Item.FHiliteConditions.SetIndex(-1);
end;
{------------------------------------------------------------------------------}
{ GetItems                                                                     }
{------------------------------------------------------------------------------}
function TCrpeGroupNameFields.GetItems(nIndex: integer) : TCrpeGroupNameFieldsItem;
begin
  SetIndex(nIndex);
  Result := TCrpeGroupNameFieldsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeGroupNameFields.GetItem : TCrpeGroupNameFieldsItem;
begin
  Result := TCrpeGroupNameFieldsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ SetItem                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeGroupNameFields.SetItem (const nItem : TCrpeGroupNameFieldsItem);
begin
  FItem.Assign(nItem);
end;

{******************************************************************************}
{ Class TCrpeParamFieldInfo                                                    }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeParamFieldInfo.Create;
begin
  inherited Create;
  FAllowNull              := True;
  FAllowEditing           := True;
  FAllowMultipleValues    := False;
  FPartOfGroup            := False;
  FMutuallyExclusiveGroup := True;
  FValueType              := vtDiscrete;
  FGroupNum               := -1;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldInfo.Assign(Source: TPersistent);
begin
  if Source is TCrpeParamFieldInfo then
  begin
    AllowNull              := TCrpeParamFieldInfo(Source).AllowNull;
    AllowEditing           := TCrpeParamFieldInfo(Source).AllowEditing;
    AllowMultipleValues    := TCrpeParamFieldInfo(Source).AllowMultipleValues;
    PartOfGroup            := TCrpeParamFieldInfo(Source).PartOfGroup;
    MutuallyExclusiveGroup := TCrpeParamFieldInfo(Source).MutuallyExclusiveGroup;
    ValueType              := TCrpeParamFieldInfo(Source).ValueType;
    GroupNum               := TCrpeParamFieldInfo(Source).GroupNum;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldInfo.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex                  := -1;
    FAllowNull              := True;
    FAllowEditing           := True;
    FAllowMultipleValues    := False;
    FPartOfGroup            := False;
    FMutuallyExclusiveGroup := True;
    FValueType              := vtDiscrete;
    FGroupNum               := -1;
  end
  else
  begin
    SetAllowNull(True);
    SetAllowEditing(True);
    SetAllowMultipleValues(False);
    SetPartOfGroup(False);
    SetMutuallyExclusiveGroup(True);
    SetValueType(vtDiscrete);
    SetGroupNum(-1);
  end;
end;
{------------------------------------------------------------------------------}
{ SetAllowNull                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldInfo.SetAllowNull (const Value: Boolean);
var
  ParameterValueInfo : PEParameterValueInfo;
  FName              : string;
  FReportName        : string;
begin
  FAllowNull := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;

  {Get the current Report settings}
  
  if not Cr.FCrpeEngine.PEGetParameterValueInfo(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), ParameterValueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetAllowNull <PEGetParameterValueInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  if Ord(FAllowNull) <> ParameterValueInfo.isNullable then
  begin
    ParameterValueInfo.isNullable := Ord(FAllowNull);
    {Send the Parameter Info to the Report}
    
    if not Cr.FCrpeEngine.PESetParameterValueInfo(Cr.FPrintJob, PChar(FName),
      PChar(FReportName), ParameterValueInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetAllowNull <PESetParameterValueInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetAllowEditing                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldInfo.SetAllowEditing (const Value: Boolean);
var
  ParameterValueInfo : PEParameterValueInfo;
  FName              : string;
  FReportName        : string;
begin
  FAllowEditing := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;

  {Get the current Report settings}
  
  if not Cr.FCrpeEngine.PEGetParameterValueInfo(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), ParameterValueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetAllowEditing <PEGetParameterValueInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  if Ord(FAllowEditing) = ParameterValueInfo.disallowEditing then
  begin
    ParameterValueInfo.disallowEditing := Ord(FAllowEditing);
    {Send the Parameter Info to the Report}
    
    if not Cr.FCrpeEngine.PESetParameterValueInfo(Cr.FPrintJob, PChar(FName),
      PChar(FReportName), ParameterValueInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetAllowEditing <PESetParameterValueInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetAllowMultipleValues                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldInfo.SetAllowMultipleValues (const Value: Boolean);
var
  ParameterValueInfo : PEParameterValueInfo;
  FName              : string;
  FReportName        : string;
begin
  FAllowMultipleValues := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;

  {Get the current Report settings}
  
  if not Cr.FCrpeEngine.PEGetParameterValueInfo(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), ParameterValueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetAllowMultipleValues <PEGetParameterValueInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  if Ord(FAllowMultipleValues) <> ParameterValueInfo.allowMultipleValues then
  begin
    ParameterValueInfo.allowMultipleValues := Ord(FAllowMultipleValues);
    {Send the Parameter Info to the Report}
    
    if not Cr.FCrpeEngine.PESetParameterValueInfo(Cr.FPrintJob, PChar(FName),
      PChar(FReportName), ParameterValueInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetAllowMultipleValues <PESetParameterValueInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetValueType                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldInfo.SetValueType (const Value: TCrParamInfoValueType);
var
  ParameterValueInfo : PEParameterValueInfo;
  FName              : string;
  FReportName        : string;
begin
  FValueType := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;

  {Get the current Report settings}
  
  if not Cr.FCrpeEngine.PEGetParameterValueInfo(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), ParameterValueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetValueType <PEGetParameterValueInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  if Ord(FValueType) <> ParameterValueInfo.hasDiscreteValues then
  begin
    ParameterValueInfo.hasDiscreteValues := Ord(FValueType);
    {Send the Parameter Info to the Report}
    
    if not Cr.FCrpeEngine.PESetParameterValueInfo(Cr.FPrintJob, PChar(FName),
      PChar(FReportName), ParameterValueInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetValueType <PESetParameterValueInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetPartOfGroup                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldInfo.SetPartOfGroup (const Value: Boolean);
var
  ParameterValueInfo : PEParameterValueInfo;
  FName              : string;
  FReportName        : string;
begin
  FPartOfGroup := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;

  {Get the current Report settings}
  
  if not Cr.FCrpeEngine.PEGetParameterValueInfo(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), ParameterValueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetPartOfGroup <PEGetParameterValueInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  if Ord(FPartOfGroup) <> ParameterValueInfo.partOfGroup then
  begin
    ParameterValueInfo.partOfGroup := Ord(FPartOfGroup);
    {Send the Parameter Info to the Report}
    
    if not Cr.FCrpeEngine.PESetParameterValueInfo(Cr.FPrintJob, PChar(FName),
      PChar(FReportName), ParameterValueInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetPartOfGroup <PESetParameterValueInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetMutuallyExclusiveGroup                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldInfo.SetMutuallyExclusiveGroup (const Value: Boolean);
var
  ParameterValueInfo : PEParameterValueInfo;
  FName              : string;
  FReportName        : string;
begin
  FMutuallyExclusiveGroup := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;

  {Get the current Report settings}
  
  if not Cr.FCrpeEngine.PEGetParameterValueInfo(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), ParameterValueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetMutuallyExclusiveGroup <PEGetParameterValueInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  if Ord(FMutuallyExclusiveGroup) <> ParameterValueInfo.mutuallyExclusiveGroup then
  begin
    ParameterValueInfo.mutuallyExclusiveGroup := Ord(FMutuallyExclusiveGroup);
    {Send the Parameter Info to the Report}
    
    if not Cr.FCrpeEngine.PESetParameterValueInfo(Cr.FPrintJob, PChar(FName),
      PChar(FReportName), ParameterValueInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetMutuallyExclusiveGroup <PESetParameterValueInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetGroupNum                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldInfo.SetGroupNum (const Value: Smallint);
var
  ParameterValueInfo : PEParameterValueInfo;
  FName              : string;
  FReportName        : string;
begin
  FGroupNum := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;

  {Get the current Report settings}
  
  if not Cr.FCrpeEngine.PEGetParameterValueInfo(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), ParameterValueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
       Cr.BuildErrorString(Self) + 'SetGroupNum <PEGetParameterValueInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  if FGroupNum <> ParameterValueInfo.groupNum then
  begin
    ParameterValueInfo.groupNum := FGroupNum;
    {Send the Parameter Info to the Report}
    
    if not Cr.FCrpeEngine.PESetParameterValueInfo(Cr.FPrintJob, PChar(FName),
      PChar(FReportName), ParameterValueInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetGroupNum <PESetParameterValueInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ Class TCrpeParamFieldRangesItem                                              }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeParamFieldRangesItem.Create;
begin
  inherited Create;
  FRangeStart := '';
  FRangeEnd   := '';
  FBounds     := IncludeStartAndEnd;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldRangesItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeParamFieldRangesItem then
  begin
    RangeStart := TCrpeParamFieldRangesItem(Source).RangeStart;
    RangeEnd   := TCrpeParamFieldRangesItem(Source).RangeEnd;
    Bounds     := TCrpeParamFieldRangesItem(Source).Bounds;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldRangesItem.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex      := -1;
    FRangeStart := '';
    FRangeEnd   := '';
    FBounds     := IncludeStartAndEnd;
  end;
end;
{------------------------------------------------------------------------------}
{ Send                                                                         }
{------------------------------------------------------------------------------}
function TCrpeParamFieldRangesItem.Send : Boolean;
var
  startValueInfo : PEValueInfo;
  endValueInfo   : PEValueInfo;
  iRangeInfo     : Smallint;
  rptStart       : string;
  rptEnd         : string;
  rptBounds      : TCrRangeBounds;
  nValue         : Smallint;
  StartList      : TStringList;
  EndList        : TStringList;
  BoundsList     : TStringList;
  Changed        : Boolean;
  FName          : string;
  FReportName    : string;
  FParamType     : TCrParamFieldType;

  function ConvertRangeBounds (RangeInfo: Smallint): TCrRangeBounds;
  begin
    Result := IncludeStartAndEnd;
    if (iRangeInfo - PE_RI_NOLOWERBOUND > -1) then
    begin
      iRangeInfo := iRangeInfo - PE_RI_NOLOWERBOUND;
      if iRangeInfo - PE_RI_NOUPPERBOUND > -1 then
        Result := ExcludeStartAndEnd
      else
        Result := IncludeEndOnly;
    end
    else
    begin
      if iRangeInfo - PE_RI_INCLUDELOWERBOUND > -1 then
      begin
        iRangeInfo := iRangeInfo - PE_RI_INCLUDELOWERBOUND;
        if iRangeInfo - PE_RI_INCLUDEUPPERBOUND > -1 then
          Result := IncludeStartAndEnd
        else
          Result := IncludeStartOnly;
      end;
    end;
  end;

  procedure AddRanges(rStart, rEnd: string; rBounds: Smallint);
  begin
    StartList.Add(rStart);
    EndList.Add(rEnd);
    BoundsList.Add(IntToStr(rBounds));
  end;
  function StartRange(nIndex: integer): string;
  begin
    Result := StartList[nIndex];
  end;
  function EndRange(nIndex: integer): string;
  begin
    Result := EndList[nIndex];
  end;
  function RangeBounds(nIndex: integer): Smallint;
  begin
    Result := StrToInt(BoundsList[nIndex]);
  end;

begin
  Result := False;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  {Only Send if ValueType is vtRange}
  if Cr.FParamFields.Item.FInfo.FValueType <> vtRange then Exit;
  Changed := False;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;
  FParamType := Cr.FParamFields.Item.FParamType;

  iRangeInfo := 0;
  
  if not Cr.FCrpeEngine.PEGetNthParameterCurrentRange(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), FIndex, startValueInfo, endValueInfo, iRangeInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'Send <PEGetNthParameterCurrentRange>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  rptStart := ValueInfoToStr(startValueInfo);
  rptEnd := ValueInfoToStr(endValueInfo);
  rptBounds := ConvertRangeBounds(iRangeInfo);

  {Compare Ranges for changes}
  if (CompareStr(FRangeStart, rptStart) <> 0) or
     (CompareStr(FRangeEnd, rptEnd) <> 0) then
    Changed := True;
  {Compare RangeBounds}
  if FBounds <> rptBounds then
    Changed := True;

  if Changed then
  begin
    StartList := TStringList.Create;
    EndList := TStringList.Create;
    BoundsList := TStringList.Create;

    {Store the Ranges}
    for nValue := 0 to (TCrpeParamFieldRanges(Parent).Count-1) do
    begin
      {If it is the item that has been changed, do not store}
      if nValue = FIndex then
      begin
        {Bounds}
        case FBounds of
          IncludeStartAndEnd : iRangeInfo := PE_RI_INCLUDEUPPERBOUND or PE_RI_INCLUDELOWERBOUND;
          IncludeStartOnly   : iRangeInfo := PE_RI_INCLUDELOWERBOUND;
          IncludeEndOnly     : iRangeInfo := PE_RI_INCLUDEUPPERBOUND;
          ExcludeStartAndEnd : iRangeInfo := PE_RI_NOUPPERBOUND or PE_RI_NOLOWERBOUND;
        end;
        AddRanges(FRangeStart, FRangeEnd, iRangeInfo);
        Continue;
      end;
      iRangeInfo := 0;
      
      if not Cr.FCrpeEngine.PEGetNthParameterCurrentRange(Cr.FPrintJob, PChar(FName),
        PChar(FReportName), nValue, startValueInfo, endValueInfo, iRangeInfo) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'Send <PEGetNthParameterCurrentRange>') of
          errIgnore : begin
                        AddRanges('','', PE_RI_INCLUDEUPPERBOUND or PE_RI_INCLUDELOWERBOUND);
                        Continue;
                      end;
          errAbort  : begin
                       StartList.Free;
                       EndList.Free;
                       BoundsList.Free;
                       Abort;
                     end;
          errRaise  : begin
                       StartList.Free;
                       EndList.Free;
                       BoundsList.Free;
                       raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                     end;
        end;
      end;
      AddRanges(ValueInfoToStr(startValueInfo),
        ValueInfoToStr(endValueInfo), iRangeInfo);
    end;

    {Clear Report Ranges}
    
    if not Cr.FCrpeEngine.PEClearParameterCurrentValuesAndRanges(Cr.FPrintJob, PChar(FName),
      PChar(FReportName)) then
    begin
      StartList.Free;
      EndList.Free;
      BoundsList.Free;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ParamFields [' + IntToStr(FIndex) +
        '].Ranges.Send <PEClearParameterCurrentValuesAndRanges>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Loop through the lists}
    for nValue := 0 to StartList.Count - 1 do
    begin
      startValueInfo.valueType := Ord(FParamType);
      rptStart := StartRange(nValue);
      rptEnd := EndRange(nValue);
      iRangeInfo := RangeBounds(nValue);

      {StartRange}
      if not StrToValueInfo(rptStart, startValueInfo) then
      begin
        case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_STR2VALUEINFO,
            Cr.BuildErrorString(Self) + 'Send <StrToValueInfo - StartRange>') of
          errIgnore : Continue;
          errAbort  : begin
                       StartList.Free;
                       EndList.Free;
                       BoundsList.Free;
                       Abort;
                     end;
          errRaise  : begin
                       StartList.Free;
                       EndList.Free;
                       BoundsList.Free;
                       raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                     end;
        end;
      end;

      {EndRange}
      endValueInfo.valueType := Ord(FParamType);
      if not StrToValueInfo (rptEnd, endValueInfo) then
      begin
        case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_STR2VALUEINFO,
            Cr.BuildErrorString(Self) + 'Send <StrToValueInfo - EndRange>') of
          errIgnore : Continue;
          errAbort  : begin
                       StartList.Free;
                       EndList.Free;
                       BoundsList.Free;
                       Abort;
                     end;
          errRaise  : begin
                       StartList.Free;
                       EndList.Free;
                       BoundsList.Free;
                       raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                     end;
        end;
      end;

      {Send New Range settings}
      startValueInfo.valueType := Ord(FParamType);
      endValueInfo.valueType := Ord(FParamType);
      
      if not Cr.FCrpeEngine.PEAddParameterCurrentRange(Cr.FPrintJob, PChar(FName),
        PChar(FReportName), startValueInfo, endValueInfo, iRangeInfo) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'Send <PEAddParameterCurrentRange>') of
          errIgnore : Continue;
          errAbort  : begin
                       StartList.Free;
                       EndList.Free;
                       BoundsList.Free;
                       Abort;
                     end;
          errRaise  : begin
                       StartList.Free;
                       EndList.Free;
                       BoundsList.Free;
                       raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                     end;
        end;
      end;
    end; {Loop through VCL Ranges}
    StartList.Free;
    EndList.Free;
    BoundsList.Free;
    Result := True;
  end;
end;
{------------------------------------------------------------------------------}
{ SetRangeStart                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldRangesItem.SetRangeStart (const Value: string);
begin
  FRangeStart := Value;
  Send;
end;
{------------------------------------------------------------------------------}
{ SetRangeEnd                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldRangesItem.SetRangeEnd (const Value: string);
begin
  FRangeEnd := Value;
  Send;
end;
{------------------------------------------------------------------------------}
{ SetBounds                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldRangesItem.SetBounds (const Value: TCrRangeBounds);
begin
  FBounds := Value;
  Send;
end;


{******************************************************************************}
{ Class TCrpeParamFieldRanges                                                  }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeParamFieldRanges.Create;
begin
  inherited Create;
  FItem := TCrpeParamFieldRangesItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeParamFieldRanges.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldRanges.Clear;
var
  FName       : string;
  FReportName : string;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    FItem.Clear;
  end
  else
  begin
    FName := Cr.FParamFields.Item.FName;
    FReportName := Cr.FParamFields.Item.FReportName;
    
    if not Cr.FCrpeEngine.PEClearParameterCurrentValuesAndRanges(Cr.FPrintJob, PChar(FName),
      PChar(FReportName)) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errLinkedParameter,errEngine,'',
        Cr.BuildErrorString(Self) + 'Clear <PEClearParameterCurrentValuesAndRanges>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeParamFieldRanges.Count : integer;
var
  nRanges     : Smallint;
  FName       : string;
  FReportName : string;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  {Only Retrieve if ValueType is vtRange}
  if TCrpeParamFieldsItem(Parent).FInfo.FValueType <> vtRange then Exit;
  if not Cr.StatusIsGo(Cr.FParamFields.FIndex) then Exit;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;

  {Get number of Ranges}
  
  nRanges := Cr.FCrpeEngine.PEGetNParameterCurrentRanges(Cr.FPrintJob, PChar(FName),
    PChar(FReportName));
  if nRanges = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'Count <PEGetNParameterCurrentRanges>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := nRanges;
end;
{------------------------------------------------------------------------------}
{ Add                                                                          }
{------------------------------------------------------------------------------}
function TCrpeParamFieldRanges.Add : integer;
var
  startValueInfo : PEValueInfo;
  endValueInfo   : PEValueInfo;
  iRangeInfo     : Smallint;
  FParamType     : TCrParamFieldType;
  FName          : string;
  FReportName    : string;
begin
  Result := -1;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  FParamType := Cr.FParamFields.Item.FParamType;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;

  {Initialize new values}
  iRangeInfo := PE_RI_INCLUDEUPPERBOUND or PE_RI_INCLUDELOWERBOUND;
  startValueInfo.valueType := Ord(FParamType);
  ValueInfoToDefault(startValueInfo);
  endValueInfo.valueType := Ord(FParamType);
  ValueInfoToDefault(endValueInfo);
  {Add Range}
  
  if not Cr.FCrpeEngine.PEAddParameterCurrentRange(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), startValueInfo, endValueInfo, iRangeInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'Add <PEAddParameterCurrentRange>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  SetIndex(Count-1);
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Delete                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldRanges.Delete (nIndex : integer);
var
  startValueInfo : PEValueInfo;
  endValueInfo   : PEValueInfo;
  iRangeInfo     : Smallint;
  StartList      : TStringList;
  EndList        : TStringList;
  BoundsList     : TStringList;
  i              : integer;
  FName          : string;
  FReportName    : string;
  FParamType     : TCrParamFieldType;

  procedure AddRanges(rStart, rEnd: string; rBounds: Smallint);
  begin
    StartList.Add(rStart);
    EndList.Add(rEnd);
    BoundsList.Add(IntToStr(rBounds));
  end;
  function StartRange(nIndex: integer): string;
  begin
    Result := StartList[nIndex];
  end;
  function EndRange(nIndex: integer): string;
  begin
    Result := EndList[nIndex];
  end;
  function RangeBounds(nIndex: integer): Smallint;
  begin
    Result := StrToInt(BoundsList[nIndex]);
  end;
  procedure ClearRangeLists;
  begin
    StartList.Free;
    EndList.Free;
    BoundsList.Free;
  end;

begin
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;
  FParamType := Cr.FParamFields.Item.FParamType;

  StartList := TStringList.Create;
  EndList := TStringList.Create;
  BoundsList := TStringList.Create;

  for i := 0 to Count-1 do
  begin
    {Skip the item that is to be deleted}
    if i = nIndex then
      Continue;
    iRangeInfo := 0;
    
    if not Cr.FCrpeEngine.PEGetNthParameterCurrentRange(Cr.FPrintJob, PChar(FName),
      PChar(FReportName), i, startValueInfo, endValueInfo, iRangeInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'Delete <PEGetNthParameterCurrentRange>') of
        errIgnore : Continue;
        errAbort  : begin
                     ClearRangeLists;
                     Abort;
                   end;
        errRaise  : begin
                     ClearRangeLists;
                     raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                   end;
      end;
    end;
    AddRanges(ValueInfoToStr(startValueInfo), ValueInfoToStr(endValueInfo),
      iRangeInfo);
  end;

  {Clear Report Ranges}
  
  if not Cr.FCrpeEngine.PEClearParameterCurrentValuesAndRanges(Cr.FPrintJob, PChar(FName),
    PChar(FReportName)) then
  begin
    ClearRangeLists;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'Delete <PEClearParameterCurrentValuesAndRanges>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through the lists}
  for i := 0 to StartList.Count - 1 do
  begin
    {RangeStart}
    startValueInfo.valueType := Ord(FParamType);
    if not StrToValueInfo(StartRange(i), startValueInfo) then
    begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_STR2VALUEINFO,
        Cr.BuildErrorString(Self) + 'Delete <StrToValueInfo - RangeStart>') of
        errIgnore : Continue;
        errAbort  : begin
                     ClearRangeLists;
                     Abort;
                   end;
        errRaise  : begin
                     ClearRangeLists;
                     raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                   end;
      end;
    end;

    {RangeEnd}
    endValueInfo.valueType := Ord(FParamType);
    if not StrToValueInfo (EndRange(i), endValueInfo) then
    begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_STR2VALUEINFO,
        Cr.BuildErrorString(Self) + 'Delete <StrToValueInfo - RangeEnd>') of
        errIgnore : Continue;
        errAbort  : begin
                     ClearRangeLists;
                     Abort;
                   end;
        errRaise  : begin
                     ClearRangeLists;
                     raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                   end;
      end;
    end;

    {Send New Range settings}
    
    if not Cr.FCrpeEngine.PEAddParameterCurrentRange(Cr.FPrintJob, PChar(FName),
      PChar(FReportName), startValueInfo, endValueInfo, RangeBounds(i)) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'Delete <PEAddParameterCurrentRange>') of
        errIgnore : Continue;
        errAbort  : begin
                     ClearRangeLists;
                     Abort;
                   end;
        errRaise  : begin
                     ClearRangeLists;
                     raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                   end;
      end;
    end;
  end;
  ClearRangeLists;
  {Decrement index if necessary}
  if FIndex = Count then
    SetIndex(FIndex-1);
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldRanges.SetIndex (nIndex: integer);
var
  startValueInfo : PEValueInfo;
  endValueInfo   : PEValueInfo;
  iRangeInfo     : Smallint;
  FName          : string;
  FReportName    : string;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Clear;
    Exit;
  end;
  if Cr.FParamFields.Item.FInfo.FValueType <> vtRange then Exit;
  if not Cr.OpenPrintJob then Exit;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;

  iRangeInfo := 0;
  
  if not Cr.FCrpeEngine.PEGetNthParameterCurrentRange(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), nIndex, startValueInfo, endValueInfo, iRangeInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetIndex(' + IntToStr(nIndex) +
        ') <PEGetNthParameterCurrentRange>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Store the Range Values}
  PropagateIndex(nIndex);
  FItem.FRangeStart := ValueInfoToStr(startValueInfo);
  FItem.FRangeEnd := ValueInfoToStr(endValueInfo);
  {Store Range Bounds info}
  if (iRangeInfo - PE_RI_NOLOWERBOUND > -1) then
  begin
    iRangeInfo := iRangeInfo - PE_RI_NOLOWERBOUND;
    if iRangeInfo - PE_RI_NOUPPERBOUND > -1 then
      FItem.FBounds := ExcludeStartAndEnd
    else
      FItem.FBounds := IncludeEndOnly;
  end
  else
  begin
    if iRangeInfo - PE_RI_INCLUDELOWERBOUND > -1 then
    begin
      iRangeInfo := iRangeInfo - PE_RI_INCLUDELOWERBOUND;
      if iRangeInfo - PE_RI_INCLUDEUPPERBOUND > -1 then
        FItem.FBounds := IncludeStartAndEnd
      else
        FItem.FBounds := IncludeStartOnly;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{   - This is the default property and can be also set                         }
{      via Crpe1.ParamFields.Ranges[nIndex]                                    }
{------------------------------------------------------------------------------}
function TCrpeParamFieldRanges.GetItem(nIndex: integer) : TCrpeParamFieldRangesItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeParamFieldPromptValuesItem                                        }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeParamFieldPromptValuesItem.Create;
begin
  inherited Create;
  FText        := '';
  FDescription := '';
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldPromptValuesItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeParamFieldPromptValuesItem then
  begin
    Text        := TCrpeParamFieldPromptValuesItem(Source).Text;
    Description := TCrpeParamFieldPromptValuesItem(Source).Description;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldPromptValuesItem.Clear;
var
  ValueInfo : PEValueInfo;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex       := -1;
    FText        := '';
    FDescription := '';
  end
  else
  begin
    ValueInfoToDefault(ValueInfo);
    SetText(ValueInfoToStr(ValueInfo));
    SetDescription('');
  end;
end;
{------------------------------------------------------------------------------}
{ SetText                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldPromptValuesItem.SetText (const Value: string);
var
  ValueInfo   : PEValueInfo;
  rptText     : string;
  FName       : string;
  FReportName : string;
  FParamType  : TCrParamFieldType;
begin
  FText := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;
  FParamType := Cr.FParamFields.Item.FParamType;

  
  if not Cr.FCrpeEngine.PEGetNthParameterDefaultValue(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), FIndex, ValueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) +  'SetText <PEGetNthParameterDefaultValue>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  rptText := ValueInfoToStr(ValueInfo);

  {Compare for changes}
  if CompareStr(FText, rptText) <> 0 then
  begin
    {Text changed}
    ValueInfo.ValueType := Ord(FParamType);
    if not StrToValueInfo (FText, ValueInfo) then
    begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_STR2VALUEINFO,
         Cr.BuildErrorString(Self) +  'SetText <StrToValueInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Change DefaultValue}
    
    if not Cr.FCrpeEngine.PESetNthParameterDefaultValue(Cr.FPrintJob, PChar(FName),
      PChar(FReportName), FIndex, ValueInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) +  'SetText <PESetNthParameterDefaultValue>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDescription                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldPromptValuesItem.SetDescription (const Value: string);
var
  hValue      : HWnd;
  iValue      : Smallint;
  pValue      : PChar;
  rptDesc     : string;
  FName       : string;
  FReportName : string;
begin
  FDescription := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;

  {Picklist ValueDescriptions}
  
  if not Cr.FCrpeEngine.PEGetNthParameterValueDescription(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), FIndex, hValue, iValue) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetDescription <PEGetNthParameterValueDescription>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get PickList string}
  pValue := StrAlloc(iValue);
  if not Cr.FCrpeEngine.PEGetHandleString(hValue, pValue, iValue) then
  begin
    StrDispose(pValue);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetDescription <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  rptDesc := String(pValue);
  StrDispose(pValue);

  {Compare for changes}
  if CompareStr(FDescription, rptDesc) <> 0 then
  begin
    {Description changed}
    
    if not Cr.FCrpeEngine.PESetNthParameterValueDescription(Cr.FPrintJob, PChar(FName),
      PChar(FReportName), FIndex, PChar(FDescription)) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetDescription <PESetNthParameterValueDescription>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ Class TCrpeParamFieldPromptValues                                            }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeParamFieldPromptValues.Create;
begin
  inherited Create;
  FDescriptionOnly   := False;
  FSortMethod        := psmNoSort;
  FSortByDescription := False;
  FItem              := TCrpeParamFieldPromptValuesItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeParamFieldPromptValues.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldPromptValues.Assign(Source: TPersistent);
begin
  if Source is TCrpeParamFieldPromptValues then
  begin
    DescriptionOnly   := TCrpeParamFieldPromptValues(Source).DescriptionOnly;
    SortMethod        := TCrpeParamFieldPromptValues(Source).SortMethod;
    SortByDescription := TCrpeParamFieldPromptValues(Source).SortByDescription;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldPromptValues.Clear;
var
  i : integer;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    FItem.Clear;
  end
  else
  begin
    for i := Count-1 downto 0 do
      Delete(i);
  end;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeParamFieldPromptValues.Count : integer;
var
  nValues     : Smallint;
  FName       : string;
  FReportName : string;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(Cr.FParamFields.FIndex) then Exit;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;

  {Retrieve Parameter Field DefaultValues}
  
  nValues := Cr.FCrpeEngine.PEGetNParameterDefaultValues(Cr.FPrintJob, PChar(FName),
    PChar(FReportName));
  if nValues = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'Count <PEGetNParameterDefaultValues>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := nValues;
end;
{------------------------------------------------------------------------------}
{ Add                                                                          }
{------------------------------------------------------------------------------}
function TCrpeParamFieldPromptValues.Add (const Value: string): integer;
var
  ValueInfo   : PEValueInfo;
  FName       : string;
  FReportName : string;
  FParamType  : TCrParamFieldType;
begin
  Result := -1;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;
  FParamType := Cr.FParamFields.Item.FParamType;

  {Convert PromptValue to ValueInfo}
  ValueInfo.ValueType := Ord(FParamType);
  if not StrToValueInfo(Value, ValueInfo) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_STR2VALUEINFO,
       Cr.BuildErrorString(Self) +  'Add <StrToValueInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Add Default Value to Report}
  
  if not Cr.FCrpeEngine.PEAddParameterDefaultValue(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), ValueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errLinkedParameter,errEngine,'',
      Cr.BuildErrorString(Self) + 'Add <PEAddParameterDefaultValue>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  SetIndex(Count-1);
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Delete                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldPromptValues.Delete (nIndex : integer);
var
  FName       : string;
  FReportName : string;
begin
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;

  
  if not Cr.FCrpeEngine.PEDeleteNthParameterDefaultValue(Cr.FPrintJob,
    PChar(FName), PChar(FReportName), nIndex) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'Delete(' +
      IntToStr(nIndex) + ') <PEDeleteNthParameterDefaultValue>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Decrement index if necessary}
  if FIndex = Count then
    SetIndex(FIndex-1);
end;
{------------------------------------------------------------------------------}
{ SetDescriptionOnly                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldPromptValues.SetDescriptionOnly (const Value: Boolean);
var
  rptPLOption : PEParameterPickListOption;
  FName       : string;
  FReportName : string;
begin
  FDescriptionOnly := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;

  {Retrieve Parameter PickList Options}
  
  if not Cr.FCrpeEngine.PEGetParameterPickListOption(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), rptPLOption) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetDescriptionOnly <PEGetParameterPickListOption>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Check PickList options for changes}
  if Ord(FDescriptionOnly) <> rptPLOption.showDescOnly then
  begin
    rptPLOption.showDescOnly := Ord(FDescriptionOnly);
    
    if not Cr.FCrpeEngine.PESetParameterPickListOption(Cr.FPrintJob, PChar(FName),
      PChar(FReportName), rptPLOption) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
       Cr.BuildErrorString(Self) + 'SetDescriptionOnly <PESetParameterPickListOption>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetSortMethod                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldPromptValues.SetSortMethod (const Value: TCrPickListSortMethod);
var
  rptPLOption : PEParameterPickListOption;
  FName       : string;
  FReportName : string;
begin
  FSortMethod := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;

  {Retrieve Parameter PickList Options}
  
  if not Cr.FCrpeEngine.PEGetParameterPickListOption(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), rptPLOption) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetSortMethod <PEGetParameterPickListOption>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Check PickList options for changes}
  if Ord(FSortMethod) <> rptPLOption.sortMethod then
  begin
    rptPLOption.sortMethod := Ord(FSortMethod);
    
    if not Cr.FCrpeEngine.PESetParameterPickListOption(Cr.FPrintJob, PChar(FName),
      PChar(FReportName), rptPLOption) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetSortMethod <PESetParameterPickListOption>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetSortByDescription                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldPromptValues.SetSortByDescription (const Value: Boolean);
var
  rptPLOption : PEParameterPickListOption;
  FName       : string;
  FReportName : string;
begin
  FSortByDescription := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;

  {Retrieve Parameter PickList Options}
  
  if not Cr.FCrpeEngine.PEGetParameterPickListOption(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), rptPLOption) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetSortByDescription <PEGetParameterPickListOption>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Check PickList options for changes}
  if Ord(FSortByDescription) <> rptPLOption.sortBasedOnDesc then
  begin
    rptPLOption.sortBasedOnDesc := Ord(FSortByDescription);
    
    if not Cr.FCrpeEngine.PESetParameterPickListOption(Cr.FPrintJob, PChar(FName),
      PChar(FReportName), rptPLOption) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetSortByDescription <PESetParameterPickListOption>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldPromptValues.SetIndex (nIndex: integer);
var
  ValueInfo   : PEValueInfo;
  hValue      : HWnd;
  iValue      : Smallint;
  pValue      : PChar;
  PLOption    : PEParameterPickListOption;
  FName       : string;
  FReportName : string;

begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Clear;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;

  {Text}
  
  if not Cr.FCrpeEngine.PEGetNthParameterDefaultValue(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), nIndex, ValueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetIndex(' +
      IntToStr(nIndex) + ') <PEGetNthParameterDefaultValue>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);
  FItem.FText := ValueInfoToStr(ValueInfo);

  {Description}
  
  if not Cr.FCrpeEngine.PEGetNthParameterValueDescription(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), nIndex, hValue, iValue) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetIndex(' +
      IntToStr(nIndex) + ') <PEGetNthParameterValueDescription>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  pValue := StrAlloc(iValue);
  if not Cr.FCrpeEngine.PEGetHandleString(hValue, pValue, iValue) then
  begin
    StrDispose(pValue);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetIndex(' +
      IntToStr(nIndex) + ') <PEGetHandleString - Description>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FItem.FDescription := String(pValue);
  StrDispose(pValue);

  {Retrieve Parameter PickList Options}
  
  if not Cr.FCrpeEngine.PEGetParameterPickListOption(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), PLOption) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetIndex(' +
      IntToStr(nIndex) + ') <PEGetParameterPickListOption>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {DescriptionOnly}
  case PLOption.showDescOnly of
    0: FDescriptionOnly := False;
    1: FDescriptionOnly := True;
    else
      FDescriptionOnly := True;
  end;
  {SortMethod}
  case PLOption.sortMethod of
    PE_OR_NO_SORT                 : FSortMethod := psmNoSort;
    PE_OR_ALPHANUMERIC_ASCENDING  : FSortMethod := psmAlphaNumericAscending;
    PE_OR_ALPHANUMERIC_DESCENDING : FSortMethod := psmAlphaNumericDescending;
    PE_OR_NUMERIC_ASCENDING       : FSortMethod := psmNumericAscending;
    PE_OR_NUMERIC_DESCENDING      : FSortMethod := psmNumericDescending;
    else
      FSortMethod := psmNoSort;
  end;
  {SortByDescription}
  case PLOption.sortBasedOnDesc of
    0: FSortByDescription := False;
    1: FSortByDescription := True;
    else
      FSortByDescription := True;
  end;
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeParamFieldPromptValues.GetItem(nIndex: integer) : TCrpeParamFieldPromptValuesItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeParamFieldCurrentValuesItem                                       }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeParamFieldCurrentValuesItem.Create;
begin
  inherited Create;
  FText := '';
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldCurrentValuesItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeParamFieldCurrentValuesItem then
  begin
    Text := TCrpeParamFieldCurrentValuesItem(Source).Text;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldCurrentValuesItem.Clear;
var
  ValueInfo : PEValueInfo;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    FText  := '';
  end
  else
  begin
    ValueInfoToDefault(ValueInfo);
    SetText(ValueInfoToStr(ValueInfo));
  end;
end;
{------------------------------------------------------------------------------}
{ SetText                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldCurrentValuesItem.SetText (const Value: string);
var
  ValueInfo   : PEValueInfo;
  rptText     : string;
  sTmp        : string;
  rptValues   : TStringList;
  i,j         : integer;
  FName       : string;
  FReportName : string;
  FParamType  : TCrParamFieldType;
  Changed     : Boolean;
begin
  FText := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;
  FParamType := Cr.FParamFields.Item.FParamType;
  if Ord(FParamType) = PE_PF_BOOLEAN then Exit;
  Changed := False;

  
  if not Cr.FCrpeEngine.PEGetNthParameterCurrentValue(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), FIndex, ValueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errLinkedParameter,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetText <PEGetNthParameterCurrentValue>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
    rptText := ValueInfoToStr(ValueInfo);
  end;

  {Compare for changes}
  if IsStrEmpty(rptText) then Changed := True;
  if CompareStr(FText, rptText) <> 0 then Changed := True;

  if Changed then
  begin
    rptValues := TStringList.Create;
    {Store all other Values}
    for i := 0 to TCrpeParamFieldCurrentValues(Parent).Count - 1 do
    begin
      if i = FIndex then
        Continue;
      
      if not Cr.FCrpeEngine.PEGetNthParameterCurrentValue(Cr.FPrintJob, PChar(FName),
        PChar(FReportName), i, ValueInfo) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errLinkedParameter,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetText <PEGetNthParameterCurrentValue>') of
          errIgnore : Continue;
          errAbort  : begin
                       rptValues.Free;
                       Abort;
                     end;
          errRaise  : begin
                       rptValues.Free;
                       raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                     end;
        end;
      end;
      rptValues.Add(ValueInfoToStr(ValueInfo));
    end;

    {Clear Report CurrentValues}
    
    if not Cr.FCrpeEngine.PEClearParameterCurrentValuesAndRanges(Cr.FPrintJob,
      PChar(FName), PChar(FReportName)) then
    begin
      rptValues.Free;
      case Cr.GetErrorMsg(Cr.FPrintJob,errLinkedParameter,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetText <PEClearParameterCurrentValuesAndRanges>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Loop through the values}
    j := 0;
    for i := 0 to rptValues.Count do
    begin
      if i = FIndex then
        sTmp := FText
      else
        sTmp := rptValues[j];

      {Convert to ValueInfo}
      ValueInfo.ValueType := Ord(FParamType);
      if not StrToValueInfo (sTmp, ValueInfo) then
      begin
        case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_STR2VALUEINFO,
          Cr.BuildErrorString(Self) + 'SetText <StrToValueInfo>') of
          errIgnore : Continue;
          errAbort  : begin
                       rptValues.Free;
                       Abort;
                     end;
          errRaise  : begin
                       rptValues.Free;
                       raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                     end;
        end;
      end;
      {Add CurrentValue}
      
      if not Cr.FCrpeEngine.PEAddParameterCurrentValue(Cr.FPrintJob, PChar(FName),
        PChar(FReportName), ValueInfo) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errLinkedParameter,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetText <PEAddParameterCurrentValue>') of
          errIgnore : Continue;
          errAbort  : begin
                       rptValues.Free;
                       Abort;
                     end;
          errRaise  : begin
                       rptValues.Free;
                       raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                     end;
        end;
      end;
      if i <> FIndex then
        Inc(j);
    end;
  end;
end;


{******************************************************************************}
{ Class TCrpeParamFieldCurrentValues                                           }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeParamFieldCurrentValues.Create;
begin
  inherited Create;
  FItem := TCrpeParamFieldCurrentValuesItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeParamFieldCurrentValues.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldCurrentValues.Clear;
var
  FName       : string;
  FReportName : string;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    FItem.Clear;
  end
  else
  begin
    FName := Cr.FParamFields.Item.FName;
    FReportName := Cr.FParamFields.Item.FReportName;
    
    if not Cr.FCrpeEngine.PEClearParameterCurrentValuesAndRanges(Cr.FPrintJob, PChar(FName),
      PChar(FReportName)) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errLinkedParameter,errEngine,'',
        Cr.BuildErrorString(Self) + 'Clear <PEClearParameterCurrentValuesAndRanges>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeParamFieldCurrentValues.Count : integer;
var
  nValues     : Smallint;
  FName       : string;
  FReportName : string;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(Cr.FParamFields.FIndex) then Exit;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;

  {Retrieve Values}
  
  nValues := Cr.FCrpeEngine.PEGetNParameterCurrentValues(Cr.FPrintJob,
    PChar(FName), PChar(FReportName));
  if nValues = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errLinkedParameter,errEngine,'',
      Cr.BuildErrorString(Self) + 'Count <PEGetNParameterCurrentValues>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := nValues;
end;
{------------------------------------------------------------------------------}
{ Add                                                                          }
{------------------------------------------------------------------------------}
function TCrpeParamFieldCurrentValues.Add (const Value: string) : integer;
var
  ValueInfo   : PEValueInfo;
  FName       : string;
  FReportName : string;
  FParamType  : TCrParamFieldType;
begin
  Result := -1;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;
  FParamType := Cr.FParamFields.Item.FParamType;
  {Cannot add Current Value to a Boolean Parameter}
  if Ord(FParamType) = PE_PF_BOOLEAN then Exit;

  {Convert CurrentValue to ValueInfo}
  ValueInfo.ValueType := Ord(FParamType);
  if not StrToValueInfo(Value, ValueInfo) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_STR2VALUEINFO,
       Cr.BuildErrorString(Self) +  'Add <StrToValueInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Add CurrentValue}
  
  if not Cr.FCrpeEngine.PEAddParameterCurrentValue(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), ValueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errLinkedParameter,errEngine,'',
      Cr.BuildErrorString(Self) + 'Add <PEAddParameterCurrentValue>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  SetIndex(Count-1);
  Result := FIndex;
end;
{------------------------------------------------------------------------------}
{ Delete                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldCurrentValues.Delete (nIndex : integer);
var
  ValueInfo   : PEValueInfo;
  ValueList   : TStringList;
  i           : integer;
  FName       : string;
  FReportName : string;
  FParamType  : TCrParamFieldType;
begin
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;
  FParamType := Cr.FParamFields.Item.FParamType;

  ValueList := TStringList.Create;
  for i := 0 to Count-1 do
  begin
    {Skip the item that is to be deleted}
    if i = nIndex then
      Continue;
    
    if not Cr.FCrpeEngine.PEGetNthParameterCurrentValue(Cr.FPrintJob, PChar(FName),
      PChar(FReportName), i, ValueInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errLinkedParameter,errEngine,'',
        Cr.BuildErrorString(Self) + 'Delete(' +
        IntToStr(nIndex) + ') <PEGetNthParameterCurrentValue>') of
        errIgnore : Continue;
        errAbort  : begin
                     ValueList.Free;
                     Abort;
                   end;
        errRaise  : begin
                     ValueList.Free;
                     raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                   end;
      end;
    end;
    ValueList.Add(ValueInfoToStr(ValueInfo));
  end;

  {Clear CurrentValues}
  
  if not Cr.FCrpeEngine.PEClearParameterCurrentValuesAndRanges(Cr.FPrintJob, PChar(FName),
    PChar(FReportName)) then
  begin
    ValueList.Free;
    case Cr.GetErrorMsg(Cr.FPrintJob,errLinkedParameter,errEngine,'',
      Cr.BuildErrorString(Self) + 'Delete(' +
      IntToStr(nIndex) + ') <PEClearParameterCurrentValuesAndRanges>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Loop through the lists}
  for i := 0 to ValueList.Count - 1 do
  begin
    ValueInfo.valueType := Ord(FParamType);
    if not StrToValueInfo(ValueList[i], ValueInfo) then
    begin
      case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_STR2VALUEINFO,
        Cr.BuildErrorString(Self) + 'Delete(' + IntToStr(nIndex) + ') <StrToValueInfo>') of
        errIgnore : Continue;
        errAbort  : begin
                     ValueList.Free;
                     Abort;
                   end;
        errRaise  : begin
                     ValueList.Free;
                     raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                   end;
      end;
    end;
    {Set CurrentValue}
    
    if not Cr.FCrpeEngine.PEAddParameterCurrentValue(Cr.FPrintJob, PChar(FName),
      PChar(FReportName), ValueInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errLinkedParameter,errEngine,'',
        Cr.BuildErrorString(Self) + 'Delete(' + IntToStr(nIndex) + ') <PEAddParameterCurrentValue>') of
        errIgnore : Exit;
        errAbort  : begin
                     ValueList.Free;
                     Abort;
                   end;
        errRaise  : begin
                     ValueList.Free;
                     raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
                   end;
      end;
    end;
  end;
  ValueList.Free;
  {Decrement index if necessary}
  if FIndex = Count then
    SetIndex(FIndex-1);
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldCurrentValues.SetIndex (nIndex: integer);
var
  ValueInfo   : PEValueInfo;
  FName       : string;
  FReportName : string;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Clear;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;
  FName := Cr.FParamFields.Item.FName;
  FReportName := Cr.FParamFields.Item.FReportName;

  {Retrieve Parameter Current Value}
  
  if not Cr.FCrpeEngine.PEGetNthParameterCurrentValue(Cr.FPrintJob,
    PChar(FName), PChar(FReportName), nIndex, ValueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errLinkedParameter,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetIndex(' +
      IntToStr(nIndex) + ') <PEGetNthParameterCurrentValue>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);
  FItem.FText := ValueInfoToStr(ValueInfo);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeParamFieldCurrentValues.GetItem(nIndex: integer) : TCrpeParamFieldCurrentValuesItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeParamFieldsItem                                                   }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeParamFieldsItem.Create;
begin
  inherited Create;
  {ParamField properties}
  FName                := '';
  FPrompt              := '';
  FPromptValue         := '';
  FCurrentValue        := '';
  FShowDialog          := False;
  FParamType           := pfNoValue;
  FReportName          := '';
  FNeedsCurrentValue   := False;
 {CR7+}
  FParamSource   := psReport;
  FValueLimit    := False;
  FValueMin      := '';
  FValueMax      := '';
  FEditMask      := '';
  FBrowseField   := '';
  {Ranges}
  FRanges        := TCrpeParamFieldRanges.Create;
  FSubClassList.Add(FRanges);
  {PromptValues}
  FPromptValues  := TCrpeParamFieldPromptValues.Create;
  FSubClassList.Add(FPromptValues);
  {CurrentValues}
  FCurrentValues := TCrpeParamFieldCurrentValues.Create;
  FSubClassList.Add(FCurrentValues);
  {ParamField Info}
  FInfo          := TCrpeParamFieldInfo.Create;
  FSubClassList.Add(FInfo);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeParamFieldsItem.Destroy;
begin
  FRanges.Free;
  FPromptValues.Free;
  FCurrentValues.Free;
  FInfo.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldsItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeParamFieldsItem then
  begin
    {ParamField properties}
    Name                := TCrpeParamFieldsItem(Source).Name;
    Prompt              := TCrpeParamFieldsItem(Source).Prompt;
    PromptValue         := TCrpeParamFieldsItem(Source).PromptValue;
    CurrentValue        := TCrpeParamFieldsItem(Source).CurrentValue;
    ShowDialog          := TCrpeParamFieldsItem(Source).ShowDialog;
    ParamType           := TCrpeParamFieldsItem(Source).ParamType;
    ReportName          := TCrpeParamFieldsItem(Source).ReportName;
    NeedsCurrentValue   := TCrpeParamFieldsItem(Source).NeedsCurrentValue;
  {CR7+}
    ParamSource   := TCrpeParamFieldsItem(Source).ParamSource;
    ValueLimit    := TCrpeParamFieldsItem(Source).ValueLimit;
    ValueMin      := TCrpeParamFieldsItem(Source).ValueMin;
    ValueMax      := TCrpeParamFieldsItem(Source).ValueMax;
    EditMask      := TCrpeParamFieldsItem(Source).EditMask;
    BrowseField   := TCrpeParamFieldsItem(Source).BrowseField;
    {Ranges}
    Ranges.Assign(TCrpeParamFieldsItem(Source).Ranges);
    {PromptValues}
    PromptValues.Assign(TCrpeParamFieldsItem(Source).PromptValues);
    {CurrentValues}
    CurrentValues.Assign(TCrpeParamFieldsItem(Source).CurrentValues);
    {ParamField Info}
    Info.Assign(TCrpeParamFieldsItem(Source).Info);
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldsItem.Clear;
begin
  inherited Clear;
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (Parent.FIndex < 0) then
  begin
    Handle             :=  0;
    FIndex             := -1;
    FName              := '';
    FPrompt            := '';
    FPromptValue       := '';
    FCurrentValue      := '';
    FShowDialog        := False;
    FParamType         := pfNoValue;
    FReportName        := '';
    FNeedsCurrentValue := False;
   {CR7+}
    {Ranges}
    FRanges.Clear;
    {PromptValues}
    FPromptValues.Clear;
    {CurrentValues}
    FCurrentValues.Clear;
    {ParamField Info}
    FInfo.Clear;
    FParamSource       := psReport;
    FValueLimit        := False;
    FValueMin          := '';
    FValueMax          := '';
    FEditMask          := '';
    FBrowseField       := ''
  end;
end;
{------------------------------------------------------------------------------}
{ ParamTypeAsString                                                            }
{------------------------------------------------------------------------------}
function TCrpeParamFieldsItem.ParamTypeAsString: string;
begin
  Result := '';
  case FParamType of
    pfNumber       : Result := 'pfNumber';
    pfCurrency     : Result := 'pfCurrency';
    pfBoolean      : Result := 'pfBoolean';
    pfDate         : Result := 'pfDate';
    pfString       : Result := 'pfString';
    pfDateTime     : Result := 'pfDateTime';
    pfTime         : Result := 'pfTime';
    pfInteger      : Result := 'pfInteger';
    pfColor        : Result := 'pfColor';
    pfChar         : Result := 'pfChar';
    pfLong         : Result := 'pfLong';
    pfStringHandle : Result := 'pfStringHandle';
    pfNoValue      : Result := 'pfNoValue';
  end;
end;
{------------------------------------------------------------------------------}
{ SetParameterName                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldsItem.SetName(const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetPrompt                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldsItem.SetPrompt (const Value: string);
var
  ParameterInfo : PEParameterFieldInfo;
  strPrompt     : string;
begin
  FPrompt := Value;
  {Check Length}
  if Length(FPrompt) > PE_PF_PROMPT_LEN then
    FPrompt := Copy(FPrompt, 1, PE_PF_PROMPT_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(Parent.FIndex) then Exit;

  {Get the Parameter Field from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthParameterField(Cr.FPrintJob, Parent.FIndex, ParameterInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetPrompt <PEGetNthParameterField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Parameter Prompt Value}
  strPrompt := String(ParameterInfo.Prompt);
  if CompareStr(strPrompt, FPrompt) <> 0 then
  begin
    StrCopy(ParameterInfo.Prompt, PChar(FPrompt));
    {Set the Parameter field}
    
    if not Cr.FCrpeEngine.PESetNthParameterField(Cr.FPrintJob, Parent.FIndex, ParameterInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetPrompt <PESetNthParameterField>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetPromptValue                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldsItem.SetPromptValue (const Value: string);
var
  ParameterInfo : PEParameterFieldInfo;
  ValueInfo     : PEValueInfo;
  strValue      : string;
  sTmp          : string;
  dt1, dt2      : TDateTime;
  Changed       : Boolean;
begin
  FPromptValue := Value;
  {Check Length}
  if Length(FPromptValue) > PE_PF_VALUE_LEN then
    FPromptValue := Copy(FPromptValue, 1, PE_PF_VALUE_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(Parent.FIndex) then Exit;
  Changed := False;

  {Get the Parameter Field from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthParameterField(Cr.FPrintJob, Parent.FIndex, ParameterInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetPromptValue <PEGetNthParameterField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Set the ValueType}
  ValueInfo.ValueType := ParameterInfo.valueType;

  {Set PromptValue}
  {Check for nulls}
  if IsStrEmpty(String(ParameterInfo.DefaultValue)) then
    sTmp := ''
  else
  begin
    {Get the Report Parameter Default Value}
    
    if not Cr.FCrpeEngine.PEConvertPFInfoToVInfo(ParameterInfo.DefaultValue,
      ValueInfo.ValueType, ValueInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetPromptValue <PEConvertPFInfoToVInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    sTmp := ValueInfoToStr(ValueInfo);
  end;

  {VCL Value: the actual Value being passed}
  strValue := FPromptValue;

  {If the Report string is empty, we must pass in PromptValue anyway because
   a null value in the Report will be seen as an empty string after
   converting to the ValueInfo structure}
  if IsStrEmpty(sTmp) then
    Changed := True;

  {Compare Values: Date}
  case ValueInfo.valueType of
    PE_PF_DATE :
      begin
        dt1 := Now;
        dt2 := Now;
        CrStrToDate(strValue, dt1);
        CrStrToDate(sTmp, dt2);
        if dt1 <> dt2 then
          Changed := True;
      end;
    PE_PF_DATETIME :
      begin
        dt1 := Now;
        dt2 := Now;
        CrStrToDateTime(strValue, dt1);
        CrStrToDateTime(sTmp, dt2);
        if dt1 <> dt2 then
          Changed := True;
      end;
    PE_PF_TIME :
      begin
        dt1 := Now;
        dt2 := Now;
        CrStrToTime(strValue, dt1);
        CrStrToTime(sTmp, dt2);
        if dt1 <> dt2 then
          Changed := True;
      end;
    PE_PF_NUMBER   :
      begin
        if CompareStr(strValue, sTmp) <> 0 then
            Changed := True;
      end;
    PE_PF_CURRENCY :
      begin
        if CompareStr(strValue, sTmp) <> 0 then
          Changed := True;
      end;
    PE_PF_BOOLEAN  :
      begin
        if CrStrToBoolean(strValue) <> CrStrToBoolean(sTmp) then
          Changed := True;
      end;
    PE_PF_STRING   :
      begin
        if CompareStr(strValue, sTmp) <> 0 then
          Changed := True;
      end;
  end;

  {Compare Values}
  if Changed then
  begin
    {Try to convert VCL Value to PEValueInfo}
    if not StrToValueInfo(strValue, ValueInfo) then
    begin
      sTmp := ECRPE_PARAMETER_STRING;
      case ValueInfo.valueType of
        PE_PF_NUMBER   : sTmp := ECRPE_PARAMETER_NUMBER;
        PE_PF_CURRENCY : sTmp := ECRPE_PARAMETER_CURRENCY;
        PE_PF_BOOLEAN  : sTmp := ECRPE_PARAMETER_BOOLEAN;
        PE_PF_DATE     : sTmp := ECRPE_PARAMETER_DATE;
        PE_PF_STRING   : sTmp := ECRPE_PARAMETER_STRING;
        PE_PF_DATETIME : sTmp := ECRPE_PARAMETER_DATETIME;
        PE_PF_TIME     : sTmp := ECRPE_PARAMETER_TIME;
      end;
      case Cr.GetErrorMsg(0,errNoOption,errVCL,sTmp,
        Cr.BuildErrorString(Self) + 'SetPromptValue <StrToValueInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Convert ValueInfo to ParamFieldInfo Default Value}
    
    if not Cr.FCrpeEngine.PEConvertVInfoToPFInfo(ValueInfo, ValueInfo.ValueType,
      ParameterInfo.DefaultValue) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetPromptValue <PEConvertVInfoToPFInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Set the Parameter field}
    {use PromptValues}
    if FPromptValues.Count = 0 then
      FPromptValues.Add(FPromptValue)
    else
    begin
      if CompareStr(FPromptValues[0].FText, FPromptValue) <> 0 then
        FPromptValues[0].SetText(FPromptValue);
    end;
  end; {Changed = True}
end;
{------------------------------------------------------------------------------}
{ SetCurrentValue                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldsItem.SetCurrentValue (const Value: string);
var
  ParameterInfo : PEParameterFieldInfo;
  ValueInfo     : PEValueInfo;
  strValue      : string;
  sTmp          : string;
  dt1, dt2      : TDateTime;
  Changed       : Boolean;
begin
  FCurrentValue := Value;
  {Check Length}
  if Length(FCurrentValue) > PE_PF_VALUE_LEN then
    FCurrentValue := Copy(FCurrentValue, 1, PE_PF_VALUE_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(Parent.FIndex) then Exit;
  {Cannot set Current Value for a Range Parameter!}
  if FInfo.FValueType = vtRange then Exit;
  Changed := False;

  {Get the Parameter Field from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthParameterField(Cr.FPrintJob, Parent.FIndex, ParameterInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetCurrentValue <PEGetNthParameterField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Set the ValueType}
  ValueInfo.ValueType := ParameterInfo.valueType;

  {Set Current Value}
  {Check for nulls}
  if IsStrEmpty(String(ParameterInfo.CurrentValue)) then
    sTmp := ''
  else
  begin
    {Put CurrentValue in ValueInfo structure}
    
    if not Cr.FCrpeEngine.PEConvertPFInfoToVInfo(ParameterInfo.CurrentValue,
      ValueInfo.ValueType, ValueInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetCurrentValue <PEConvertPFInfoToVInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    sTmp := ValueInfoToStr(ValueInfo);
  end;

  {VCL Value: the actual Value being passed}
  strValue := FCurrentValue;
  {If the Report string is empty, we must pass in CurrentValue anyway because
   a null value in the Report will be seen as an empty string after
   converting to the ValueInfo structure}
  if IsStrEmpty(sTmp) then
    Changed := True;

  {Compare Values: Date}
  case ValueInfo.valueType of
    PE_PF_DATE :
      begin
        dt1 := Now;
        dt2 := Now;
        CrStrToDate(strValue, dt1);
        CrStrToDate(sTmp, dt2);
        if dt1 <> dt2 then
          Changed := True;
      end;
    PE_PF_DATETIME :
      begin
        dt1 := Now;
        dt2 := Now;
        CrStrToDateTime(strValue, dt1);
        CrStrToDateTime(sTmp, dt2);
        if dt1 <> dt2 then
          Changed := True;
      end;
    PE_PF_TIME :
      begin
        dt1 := Now;
        dt2 := Now;
        CrStrToTime(strValue, dt1);
        CrStrToTime(sTmp, dt2);
        if dt1 <> dt2 then
          Changed := True;
      end;
    PE_PF_NUMBER   :
      begin
        if CompareStr(strValue, sTmp) <> 0 then
            Changed := True;
      end;
    PE_PF_CURRENCY :
      begin
        if CompareStr(strValue, sTmp) <> 0 then
          Changed := True;
      end;
    PE_PF_BOOLEAN  :
      begin
        if CrStrToBoolean(strValue) <> CrStrToBoolean(sTmp) then
          Changed := True;
      end;
    PE_PF_STRING   :
      begin
        if CompareStr(strValue, sTmp) <> 0 then
          Changed := True;
      end;
  end;

  {Compare Values}
  if Changed then
  begin
    {Try to convert VCL Value to PEValueInfo}
    if not StrToValueInfo(strValue, ValueInfo) then
    begin
      sTmp := ECRPE_PARAMETER_STRING;
      case ValueInfo.valueType of
        PE_PF_NUMBER   : sTmp := ECRPE_PARAMETER_NUMBER;
        PE_PF_CURRENCY : sTmp := ECRPE_PARAMETER_CURRENCY;
        PE_PF_BOOLEAN  : sTmp := ECRPE_PARAMETER_BOOLEAN;
        PE_PF_DATE     : sTmp := ECRPE_PARAMETER_DATE;
        PE_PF_STRING   : sTmp := ECRPE_PARAMETER_STRING;
        PE_PF_DATETIME : sTmp := ECRPE_PARAMETER_DATETIME;
        PE_PF_TIME     : sTmp := ECRPE_PARAMETER_TIME;
      end;
      case Cr.GetErrorMsg(0,errNoOption,errVCL,sTmp,
        Cr.BuildErrorString(Self) + 'SetCurrentValue <StrToValueInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Current Value: pass in a new value, no parameter prompt}
    {Convert ValueInfo to ParamFieldInfo CurrentValue}
    
    if not Cr.FCrpeEngine.PEConvertVInfoToPFInfo(ValueInfo, ValueInfo.ValueType,
      ParameterInfo.CurrentValue) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetCurrentValue <PEConvertVInfoToPFInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;

    {Set the Parameter field}
    {use CurrentValues}
    {Boolean parameters cannot use CurrentValues structure
     since it is not possible to send arrays of boolean values}
    if ValueInfo.valueType = PE_PF_BOOLEAN then
    begin
      ParameterInfo.CurrentValueSet := 1;
      ParameterInfo.DefaultValueSet := 0;

      if not Cr.FCrpeEngine.PESetNthParameterField(Cr.FPrintJob, Parent.FIndex, ParameterInfo) then
      begin
        case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetCurrentValue <PESetNthParameterField>') of
          errIgnore : Exit;
          errAbort  : Abort;
          errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
        end;
      end;
    end
    else
    begin
      if FCurrentValues.Count = 0 then
        FCurrentValues.Add(FCurrentValue)
      else
      begin
        if CompareStr(FCurrentValues[0].FText, FCurrentValue) <> 0 then
          FCurrentValues[0].SetText(FCurrentValue);
      end;
    end;
  end; {Changed = True}
end;
{------------------------------------------------------------------------------}
{ SetShowDialog                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldsItem.SetShowDialog (const Value: Boolean);
var
  ParameterInfo : PEParameterFieldInfo;
  Changed       : Boolean;
begin
  FShowDialog := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(Parent.FIndex) then Exit;
  Changed := False;

  {Get the Parameter Field from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthParameterField(Cr.FPrintJob, Parent.FIndex, ParameterInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetShowDialog <PEGetNthParameterField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if FShowDialog = True then
  begin
    if ParameterInfo.DefaultValueSet < 1 then
    begin
      ParameterInfo.DefaultValueSet := 1;
      Changed := True;
    end;
    if (FInfo.FValueType = vtRange) then
    begin
      if FRanges.Count > 0 then
        FRanges.Clear;
    end;

    if ParameterInfo.CurrentValueSet > 0 then
    begin
      {ClearParameterValues or Discard Saved Data: these are required
       to make CurrentValueSet = 0.  But we only want to clear the
       selected ParamField, so with Discard Saved Data we have to
       restore the other ones}
      Cr.FCrpeEngine.PEClearParameterCurrentValuesAndRanges(Cr.FPrintJob, PChar(FName),
        PChar(FReportName));
      {Set CurrentValueSet to zero - no Current Value}
      ParameterInfo.CurrentValueSet := 0;
      Changed := True;
    end;
  end;

  if FShowDialog = False then
  begin
    if ParameterInfo.DefaultValueSet > 0 then
    begin
      ParameterInfo.DefaultValueSet := 0;
      Changed := True;
    end;
    if ParameterInfo.CurrentValueSet < 1 then
    begin
      ParameterInfo.CurrentValueSet := 1;
      Changed := True;
    end;
  end;

  if Changed then
  begin
    if (FInfo.FValueType = vtRange) and (FShowDialog = False) then
      if FRanges.Count = 0 then FRanges.Add;
    {Set the Parameter field}

    if not Cr.FCrpeEngine.PESetNthParameterField(Cr.FPrintJob, Parent.FIndex, ParameterInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetShowDialog <PESetNthParameterField>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end; {Changed = True}
end;
{------------------------------------------------------------------------------}
{ SetParamType                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldsItem.SetParamType (const Value: TCrParamFieldType);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetReportName                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldsItem.SetReportName (const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetNeedsCurrentValue                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldsItem.SetNeedsCurrentValue (const Value: Boolean);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetIsLinked                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldsItem.SetIsLinked (const Value: Boolean);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetParamSource                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldsItem.SetParamSource (const Value: TCrParamFieldSource);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetValueLimit                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldsItem.SetValueLimit (const Value: Boolean);
var
  ParameterInfo : PEParameterFieldInfo;
begin
  FValueLimit := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(Parent.FIndex) then Exit;

  {Get the Parameter Field from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthParameterField(Cr.FPrintJob, Parent.FIndex, ParameterInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetValueLimit <PEGetNthParameterField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {isLimited}
  if Integer(Ord(FValueLimit)) <> ParameterInfo.isLimited then
  begin
    ParameterInfo.isLimited := Ord(FValueLimit);
    {Set the Parameter field}
    
    if not Cr.FCrpeEngine.PESetNthParameterField(Cr.FPrintJob, Parent.FIndex, ParameterInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetValueLimit <PESetNthParameterField>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end; {Changed = True}
end;
{------------------------------------------------------------------------------}
{ SetValueMin                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldsItem.SetValueMin (const Value: string);
var
  ParameterInfo : PEParameterFieldInfo;
  sTmp, sTmp2   : string;
  Changed       : Boolean;
  {CR 7}
  minValueInfo  : PEValueInfo;
  maxValueInfo  : PEValueInfo;
  fTmp, fTmp2   : Double;
  nTmp, nTmp2   : Smallint;
begin
  FValueMin := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(Parent.FIndex) then Exit;
  Changed := False;

  {Get the Parameter Field from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthParameterField(Cr.FPrintJob, Parent.FIndex, ParameterInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetValueMin <PEGetNthParameterField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Should only set ValueMin/ValueMax if ValueLimit on}
  if ParameterInfo.isLimited = 1 then
  begin
    
    if not Cr.FCrpeEngine.PEGetParameterMinMaxValue(Cr.FPrintJob, ParameterInfo.Name,
      ParameterInfo.ReportName, minValueInfo, maxValueInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetValueMin <PEGetParameterMinMaxValue>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    case ParameterInfo.valueType of
      PE_PF_NUMBER,
      PE_PF_CURRENCY :
        begin
          sTmp := ValueInfoToStr(minValueInfo);
          sTmp2 := ValueInfoToStr(maxValueInfo);
          {MinSize}
          fTmp := CrStrToFloating(FValueMin);
          fTmp2 := CrStrToFloating(sTmp);
          if fTmp <> fTmp2 then
          begin
            ParameterInfo.MinSize := fTmp;
            Changed := True;
          end;
        end;
      PE_PF_STRING   :
        begin
          sTmp := IntToStr(minValueInfo.viInteger);
          sTmp2 := IntToStr(maxValueInfo.viInteger);
          {MinSize}
          nTmp := CrStrToInteger(FValueMin);
          nTmp2 := CrStrToInteger(sTmp);
          if nTmp <> nTmp2 then
          begin
            ParameterInfo.MinSize := nTmp;
            Changed := True;
          end;
        end;
      PE_PF_DATE,
      PE_PF_DATETIME,
      PE_PF_TIME     :
        begin
          sTmp := ValueInfoToStr(minValueInfo);
          sTmp2 := ValueInfoToStr(maxValueInfo);
          if (CompareStr(FValueMin, sTmp) <> 0) or
             (CompareStr(FValueMax, sTmp2) <> 0) then
          begin
            Changed := True;
            {Convert MinValue to ValueInfo}
            minValueInfo.ValueType := ParameterInfo.valueType;
            if not StrToValueInfo(FValueMin, minValueInfo) then
            begin
              case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_STR2VALUEINFO,
                Cr.BuildErrorString(Self) + 'SetValueMin <StrToValueInfo - ValueMin>') of
                errIgnore : Exit;
                errAbort  : Abort;
                errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
              end;
            end;
            
            if not Cr.FCrpeEngine.PESetParameterMinMaxValue(Cr.FPrintJob, ParameterInfo.Name,
              ParameterInfo.reportName, minValueInfo, maxValueInfo) then
            begin
              case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
                Cr.BuildErrorString(Self) + 'SetValueMin <PESetParameterMinMaxValue>') of
                errIgnore : Exit;
                errAbort  : Abort;
                errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
              end;
            end;
          end; {if Time changed}
        end; {Value Type: Time}
    end;
  end;

  if Changed then
  begin
    {Set the Parameter field}
    
    if not Cr.FCrpeEngine.PESetNthParameterField(Cr.FPrintJob, Parent.FIndex, ParameterInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetValueMin <PESetNthParameterField>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end; {Changed = True}
end;
{------------------------------------------------------------------------------}
{ SetValueMax                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldsItem.SetValueMax (const Value: string);
var
  ParameterInfo : PEParameterFieldInfo;
  sTmp, sTmp2   : string;
  Changed       : Boolean;
  {CR 7}
  minValueInfo  : PEValueInfo;
  maxValueInfo  : PEValueInfo;
  fTmp, fTmp2   : Double;
  nTmp, nTmp2   : Smallint;
begin
  FValueMax := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(Parent.FIndex) then Exit;
  Changed := False;

  {Get the Parameter Field from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthParameterField(Cr.FPrintJob, Parent.FIndex, ParameterInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetValueMax <PEGetNthParameterField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Should only set ValueMin/ValueMax if ValueLimit on}
  if ParameterInfo.isLimited = 1 then
  begin
    
    if not Cr.FCrpeEngine.PEGetParameterMinMaxValue(Cr.FPrintJob, ParameterInfo.Name,
      ParameterInfo.ReportName, minValueInfo, maxValueInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetValueMax <PEGetParameterMinMaxValue>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    case ParameterInfo.valueType of
      PE_PF_NUMBER,
      PE_PF_CURRENCY :
        begin
          sTmp := ValueInfoToStr(minValueInfo);
          sTmp2 := ValueInfoToStr(maxValueInfo);
          {MaxSize}
          fTmp := CrStrToFloating(FValueMax);
          fTmp2 := CrStrToFloating(sTmp2);
          if fTmp <> fTmp2 then
          begin
            ParameterInfo.MaxSize := fTmp;
            Changed := True;
          end;
        end;
      PE_PF_STRING   :
        begin
          sTmp := IntToStr(minValueInfo.viInteger);
          sTmp2 := IntToStr(maxValueInfo.viInteger);
          {MaxSize}
          nTmp := CrStrToInteger(FValueMax);
          nTmp2 := CrStrToInteger(sTmp2);
          if nTmp <> nTmp2 then
          begin
            ParameterInfo.MaxSize := nTmp;
            Changed := True;
          end;
        end;
      PE_PF_DATE,
      PE_PF_DATETIME,
      PE_PF_TIME     :
        begin
          sTmp := ValueInfoToStr(minValueInfo);
          sTmp2 := ValueInfoToStr(maxValueInfo);
          if (CompareStr(FValueMin, sTmp) <> 0) or
             (CompareStr(FValueMax, sTmp2) <> 0) then
          begin
            {Convert MaxValue to ValueInfo}
            maxValueInfo.ValueType := ParameterInfo.valueType;
            if not StrToValueInfo(FValueMax, maxValueInfo) then
            begin
              case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_STR2VALUEINFO,
                Cr.BuildErrorString(Self) + 'SetValueMax <StrToValueInfo - ValueMax>') of
                errIgnore : Exit;
                errAbort  : Abort;
                errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
              end;
            end;
            
            if not Cr.FCrpeEngine.PESetParameterMinMaxValue(Cr.FPrintJob, ParameterInfo.Name,
              ParameterInfo.reportName, minValueInfo, maxValueInfo) then
            begin
              case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
                Cr.BuildErrorString(Self) + 'SetValueMax <PESetParameterMinMaxValue>') of
                errIgnore : Exit;
                errAbort  : Abort;
                errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
              end;
            end;
          end; {if Time changed}
        end; {Value Type: Time}
    end;
  end; {Set ValueMin/ValueMax}

  if Changed then
  begin
    {Set the Parameter field}
    
    if not Cr.FCrpeEngine.PESetNthParameterField(Cr.FPrintJob, Parent.FIndex, ParameterInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetValueMax <PESetNthParameterField>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end; {Changed = True}
end;
{------------------------------------------------------------------------------}
{ SetEditMask                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldsItem.SetEditMask (const Value: string);
var
  ParameterInfo : PEParameterFieldInfo;
  sTmp          : string;
  Changed       : Boolean;
begin
  FEditMask := Value;
  {Check Length}
  if Length(FEditMask) > PE_PF_EDITMASK_LEN then
    FEditMask := Copy(FEditMask, 1, PE_PF_EDITMASK_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(Parent.FIndex) then Exit;
  Changed := False;

  {Get the Parameter Field from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthParameterField(Cr.FPrintJob, Parent.FIndex, ParameterInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetEditMask <PEGetNthParameterField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {EditMask}
  sTmp := String(ParameterInfo.EditMask);
  if CompareStr(FEditMask, sTmp) <> 0 then
  begin
    StrCopy(ParameterInfo.EditMask, PChar(FEditMask));
    Changed := True;
  end;

  if Changed then
  begin
    {Set the Parameter field}
    if not Cr.FCrpeEngine.PESetNthParameterField(Cr.FPrintJob, Parent.FIndex, ParameterInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetEditMask <PESetNthParameterField>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end; {Changed = True}
end;
{------------------------------------------------------------------------------}
{ SetBrowseField                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeParamFieldsItem.SetBrowseField (const Value: string);
var
  sRPT  : string;
  iText : Smallint;
  hText : HWnd;
  pText : PChar;
begin
  FBrowseField := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(Parent.FIndex) then Exit;
  sRPT := '';

  
  if Cr.FCrpeEngine.PEGetParameterBrowseField(Cr.FPrintJob, PChar(FName),
    PChar(FReportName), hText, iText) then
  begin
    pText := StrAlloc(iText);
    if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
    begin
      StrDispose(pText);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetBrowseField <PEGetHandleString>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    sRPT := String(pText);
    StrDispose(pText);
  end;

  if CompareText(sRPT, FBrowseField) <> 0 then
  begin
    if not Cr.FCrpeEngine.PESetParameterBrowseField(Cr.FPrintJob, PChar(FName),
      PChar(FReportName), PChar(FBrowseField)) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetBrowseField <PESetParameterBrowseField>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ Class TCrpeParamFields                                                       }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeParamFields.Create;
begin
  inherited Create;
  {Set inherited ObjectInfo properties}
  FObjectType      := otField;
  FFieldObjectType := oftParameter;
  {ParamField properties}
  FIndex           := -1;
  FNames           := TStringList.Create;
  FReportNames     := TStringList.Create;
  FAllowDialog     := True;
  FItem            := TCrpeParamFieldsItem.Create;
  FSubClassList.Add(FItem);
  FObjectPropertiesActive := True;
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeParamFields.Destroy;
begin
  FNames.Free;
  FReportNames.Free;
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    Handle := 0;
    FItem.Clear;
  end;
  FReportNames.Clear;
  FNames.Clear;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeParamFields.Count : integer;
var
  nParams : Smallint;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get the Parameter Names from the Report}
  
  nParams := Cr.FCrpeEngine.PEGetNParameterFields(Cr.FPrintJob);
  if nParams = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ParamFields.Count <PEGetNParameterFields>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := nParams;
end;
{------------------------------------------------------------------------------}
{ IndexOf                                                                      }
{------------------------------------------------------------------------------}
function TCrpeParamFields.IndexOf (ParamFieldName, ReportName: string): integer;
var
  cnt : integer;
begin
  Result := -1;

  {Locate Parameter Field name}
  if Names.Count > 0 then
  begin
    for cnt := 0 to FNames.Count-1 do
    begin
      if CompareText(FNames[cnt], ParamFieldName) = 0 then
      begin
        {Check ReportName: Main/Sub rpt can have Parameters with same names}
        if CompareText(FReportNames[cnt], ReportName) = 0 then
        begin
          Result := cnt;
          Break;
        end;
      end;
    end;
  end;
  {If the Names list hasn't been built yet, or it wasn't found...}
  if Result = -1 then
  begin
    Names;
    for cnt := 0 to FNames.Count-1 do
    begin
      if CompareText(FNames[cnt], ParamFieldName) = 0 then
      begin
        {Check ReportName: Main/Sub rpt can have Parameters with same names}
        if CompareText(FReportNames[cnt], ReportName) = 0 then
        begin
          Result := cnt;
          Break;
        end;
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ByName                                                                       }
{------------------------------------------------------------------------------}
function TCrpeParamFields.ByName (ParamFieldName: string;
  ReportName: string): TCrpeParamFieldsItem;
var
  i : integer;
begin
  Result := GetItem;
  i := IndexOf(ParamFieldName, ReportName);
  if i = -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_PARAM_BY_NAME,
        'ParamFields.ByName') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := GetItems(i);
end;
{------------------------------------------------------------------------------}
{  Names                                                                       }
{  - returns a list of ParamField Names.  Faster than looping through items.   }
{------------------------------------------------------------------------------}
function TCrpeParamFields.Names : TStrings;
var
  ParamFieldInfo : PEParameterFieldInfo;
  i              : integer;
begin
  FNames.Clear;
  FReportNames.Clear;
  Result := FNames;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  for i := 0 to Count - 1 do
  begin
    {Retrieve ParamField}
    
    if not Cr.FCrpeEngine.PEGetNthParameterField(Cr.FPrintJob, i, ParamFieldInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'GetNames[' + IntToStr(i) + '] <PEGetNthParameterField>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    FNames.Add(String(ParamFieldInfo.Name));
    FReportNames.Add(String(ParamFieldInfo.ReportName));
  end;
  Result := FNames;
end;
{------------------------------------------------------------------------------}
{ SetAllowDialog                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetAllowDialog (const Value: Boolean);
var
  bAllowDialog : Bool;
  bVCL         : Bool;
begin
  FAllowDialog := Value;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get the current PromptDialog setting}
  bVCL := Bool(FAllowDialog);
  bAllowDialog := Cr.FCrpeEngine.PEGetAllowPromptDialog(Cr.FPrintJob);
  if bAllowDialog <> bVCL then
  begin
    
    if not Cr.FCrpeEngine.PESetAllowPromptDialog(Cr.FPrintJob, bVCL) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetAllowDialog <PESetAllowPromptDialog>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetObjectPropertiesActive                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetObjectPropertiesActive (const Value: Boolean);
begin
  FObjectPropertiesActive := Value;
  SetIndex(FIndex);
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetIndex (nIndex: integer);
var
  ParameterInfo  : PEParameterFieldInfo;
  ValueInfo      : PEValueInfo;
  sTmp           : string;
  {CR 7}
  nType          : Smallint;
  minValueInfo   : PEValueInfo;
  maxValueInfo   : PEValueInfo;
  {ParamField Info}
  ParameterValueInfo : PEParameterValueInfo;
  Changed        : Boolean;
  objIndex       : integer;
  sName          : string;
  objectInfo     : PEObjectInfo;
  fieldInfo      : PEFieldObjectInfo;
  iText          : Smallint;
  hText          : HWnd;
  pText          : PChar;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    Clear;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;

  {Retrieve Parameter Field}
  
  if not Cr.FCrpeEngine.PEGetNthParameterField(Cr.FPrintJob, nIndex, ParameterInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ParamFields.SetIndex(' + IntToStr(nIndex) + ') <PEGetNthParameterField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sTmp := '';

  PropagateIndex(nIndex);
  Item.FName := String(ParameterInfo.Name);
  Item.FReportName := String(ParameterInfo.ReportName);
  {Parameter Prompt}
  Item.FPrompt := String(ParameterInfo.Prompt);

  {Parameter needsCurrentValue}
  Item.FNeedsCurrentValue := False;
  if ParameterInfo.needsCurrentValue > 0 then
    Item.FNeedsCurrentValue := True;

  {Parameter needsCurrentValue}
  Item.FIsLinked := False;
  if ParameterInfo.isLinked > 0 then
    Item.FIsLinked := True;

  {Parameter Type}
  Item.FParamType := pfNoValue;
  case ParameterInfo.valueType of
    PE_PF_NUMBER    : Item.FParamType := pfNumber;
    PE_PF_CURRENCY  : Item.FParamType := pfCurrency;
    PE_PF_BOOLEAN   : Item.FParamType := pfBoolean;
    PE_PF_DATE      : Item.FParamType := pfDate;
    PE_PF_STRING    : Item.FParamType := pfString;
    PE_PF_DATETIME  : Item.FParamType := pfDateTime;
    PE_PF_TIME      : Item.FParamType := pfTime;
    PE_PF_INTEGER   : Item.FParamType := pfInteger;
    PE_PF_COLOR     : Item.FParamType := pfColor;
    PE_PF_CHAR      : Item.FParamType := pfChar;
    PE_PF_LONG      : Item.FParamType := pfLong;
    PE_PF_STRINGHANDLE : Item.FParamType := pfStringHandle;
    PE_PF_NOVALUE   : Item.FParamType := pfNoValue;
  end;

  {Default Value}
  ValueInfo.ValueType := ParameterInfo.valueType;
  
  if not Cr.FCrpeEngine.PEConvertPFInfoToVInfo(ParameterInfo.DefaultValue,
    ValueInfo.ValueType, ValueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      'ParamFields.SetIndex(' + IntToStr(nIndex) + ') <PEConvertPFInfoToVInfo - DefaultValue>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FPromptValue := ValueInfoToStr(ValueInfo);

  {Current Value}
  ValueInfo.ValueType := ParameterInfo.valueType;
  
  if not Cr.FCrpeEngine.PEConvertPFInfoToVInfo(ParameterInfo.CurrentValue,
    ValueInfo.ValueType, ValueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      'ParamFields.SetIndex(' + IntToStr(nIndex) + ') <PEConvertPFInfoToVInfo - CurrentValue>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FCurrentValue := ValueInfoToStr(ValueInfo);

  {ShowDialog}
  Item.FShowDialog := False;
  if (ParameterInfo.CurrentValueSet = 0) then
    Item.FShowDialog := True;

  {This code is required to make sure CurrentValueSet is turned off
   when the PromptDialog is going to show, and vice-versa}
  Changed := False;
  if Item.FShowDialog = True then
  begin
    if ParameterInfo.CurrentValueSet > 0 then
    begin
      ParameterInfo.CurrentValueSet := 0;
      Changed := True;
    end;
  end;
  if Item.FShowDialog = False then
  begin
    if ParameterInfo.CurrentValueSet < 1 then
    begin
      ParameterInfo.CurrentValueSet := 1;
      Changed := True;
    end;
  end;

  if Changed then
  begin
    {Set the Parameter field}
    if not Cr.FCrpeEngine.PESetNthParameterField(Cr.FPrintJob, nIndex, ParameterInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ParamFields.SetIndex(' + IntToStr(nIndex) + ') <PESetNthParameterField>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end; {Changed = True}

  {AllowDialog}
  FAllowDialog := True;
  if Cr.FCrpeEngine.PEGetAllowPromptDialog(Cr.FPrintJob) <> True then
    FAllowDialog := False;

  {MandatoryPrompt: ValueLimit}
  Item.FValueLimit := False;
  case ParameterInfo.isLimited of
    0: Item.FValueLimit := False;
    1: Item.FValueLimit := True;
  end;
  {Min and Max Size}
  if ParameterInfo.isLimited = 1 then
  begin

    if not Cr.FCrpeEngine.PEGetParameterMinMaxValue(Cr.FPrintJob, ParameterInfo.Name,
      ParameterInfo.ReportName, minValueInfo, maxValueInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'ParamFields.SetIndex(' + IntToStr(nIndex) + ') <PEGetParameterMinMaxValue>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    case ParameterInfo.valueType of
      PE_PF_NUMBER,
      PE_PF_CURRENCY :
        begin
          Item.FValueMin := ValueInfoToStr(minValueInfo);
          Item.FValueMax := ValueInfoToStr(maxValueInfo);
        end;
      PE_PF_STRING   :
        begin
          Item.FValueMin := IntToStr(minValueInfo.viInteger);
          Item.FValueMax := IntToStr(maxValueInfo.viInteger);
        end;
      PE_PF_DATE,
      PE_PF_DATETIME,
      PE_PF_TIME     :
        begin
          Item.FValueMin := ValueInfoToStr(minValueInfo);
          Item.FValueMax := ValueInfoToStr(maxValueInfo);
        end;
    end;
  end
  else
  begin
    case ParameterInfo.valueType of
      {Copy DefaultValue}
      PE_PF_NUMBER,
      PE_PF_CURRENCY,
      PE_PF_DATE,
      PE_PF_DATETIME,
      PE_PF_TIME     :
        begin
          Item.FValueMin := Item.FPromptValue;
          Item.FValueMax := Item.FPromptValue;
        end;
      {Use zero}
      PE_PF_STRING :
        begin
          Item.FValueMin := '0';
          Item.FValueMax := '0';
        end;
    end;
  end;
  {EditMask}
  Item.FEditMask := String(ParameterInfo.EditMask);
  {Parameter Type (ParamSource)}

  nType := Cr.FCrpeEngine.PEGetNthParameterType(Cr.FPrintJob, FIndex);
  if nType = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      'ParamFields.SetIndex(' + IntToStr(nIndex) + ') <PEGetNthParameterType>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  case nType of
    PE_PO_REPORT     : Item.FParamSource := psReport;
    PE_PO_STOREDPROC : Item.FParamSource := psStoredProc;
    PE_PO_QUERY      : Item.FParamSource := psQuery;
    else
      Item.FParamSource := psReport;
  end;

  {*** ParamField Info ***}
  {Retrieve Info}
  if not Cr.FCrpeEngine.PEGetParameterValueInfo(Cr.FPrintJob, PChar(Item.FName),
    PChar(Item.FReportName), ParameterValueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
       'ParamFields.SetIndex(' + IntToStr(nIndex) + ') <PEGetParameterValueInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {AllowNull}
  case ParameterValueInfo.isNullable of
    0: Item.FInfo.FAllowNull := False;
    1: Item.FInfo.FAllowNull := True;
    else
      Item.FInfo.FAllowNull := True;
  end;
  {AllowEditing}
  case ParameterValueInfo.disallowEditing of
    0: Item.FInfo.FAllowEditing := True;
    1: Item.FInfo.FAllowEditing := False;
    else
      Item.FInfo.FAllowEditing := True;
  end;
  {AllowMultipleValues}
  case ParameterValueInfo.allowMultipleValues of
    0: Item.FInfo.FAllowMultipleValues := False;
    1: Item.FInfo.FAllowMultipleValues := True;
    else
      Item.FInfo.FAllowMultipleValues := False;
  end;

  {ValueType: We don't allow default because a definite
   value type is required for ParamField Ranges Retrieve/Send}
  case ParameterValueInfo.hasDiscreteValues of
    PE_DR_HASRANGE            : Item.FInfo.FValueType := vtRange;
    PE_DR_HASDISCRETE         : Item.FInfo.FValueType := vtDiscrete;
    PE_DR_HASDISCRETEANDRANGE : Item.FInfo.FValueType := vtDiscreteAndRange;
    else
      Item.FInfo.FValueType := vtDiscrete;
  end;
  {Ranges require a different method of determing ShowDialog}
  if (Item.FInfo.FValueType = vtRange) then
    Item.FShowDialog := (Item.FRanges.Count = 0);

  {PartOfGroup}
  case ParameterValueInfo.partOfGroup of
    0: Item.FInfo.FPartOfGroup := False;
    1: Item.FInfo.FPartOfGroup := True;
    else
      Item.FInfo.FPartOfGroup := False;
  end;
  {MutuallyExclusiveGroup}
  case ParameterValueInfo.mutuallyExclusiveGroup of
    0: Item.FInfo.FMutuallyExclusiveGroup := False;
    1: Item.FInfo.FMutuallyExclusiveGroup := True;
    else
      Item.FInfo.FMutuallyExclusiveGroup := True;
  end;
  {GroupNum}
  Item.FInfo.FGroupNum := ParameterValueInfo.groupNum;

  {BrowseField}
  Item.FBrowseField := '';
    
  if Cr.FCrpeEngine.PEGetParameterBrowseField(Cr.FPrintJob, PChar(Item.FName),
    PChar(Item.FReportName), hText, iText) then
  begin
    pText := StrAlloc(iText);
    if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
    begin
      StrDispose(pText);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'ParamFields.SetIndex(' + IntToStr(nIndex) + ') <PEGetHandleString - BrowseField>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    Item.FBrowseField := String(pText);
    StrDispose(pText);
  end;

  {Attempt to Retrieve Handle}
  sName := '{?' + Item.FName + '}';
  if FObjectPropertiesActive then
    Handle := Cr.GetFieldObjectHandle(sName, oftParameter, objIndex)
  else  {if False, ignore Object Properties}
    Handle := 0;
  PropagateHandle(Handle);
  if Handle = 0 then
  begin
    {Item doesn't exist on the Report, still may be in the ParamFields list}
    Item.FFieldName := '';
    Item.SetFieldType(fvUnknown);
    Item.FFieldLength := 0;
    Item.FTop       := -1;
    Item.FLeft      := -1;
    Item.FWidth     := -1;
    Item.FHeight    := -1;
    Item.FSection   := '';
    Item.FBorder.Clear;
    Item.FFormat.Clear;
    Item.FFont.Clear;
    Item.FHiliteConditions.Clear;
    Exit;
  end;

  {Update Border, Format, Font}
  if csDesigning in Cr.ComponentState then
  begin
    FItem.Border.GetBorder;
    FItem.Format.GetFormat;
    FItem.Font.GetFont;
  end;
  {Update HiliteConditions}
  if Item.FHiliteConditions.FIndex > (Item.FHiliteConditions.Count-1) then
    Item.FHiliteConditions.SetIndex(-1);

  {Object Info}
  if not Cr.FCrpeEngine.PEGetObjectInfo(Cr.FPrintJob, Handle, objectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FLeft := objectInfo.xOffset;
  Item.FTop := objectInfo.yOffset;
  Item.FWidth := objectInfo.width;
  Item.FHeight := objectInfo.height;
  Item.FSection := Cr.SectionCodeToStringEx(objectInfo.sectionCode, False);
  {Field Object Info}
  
  if not Cr.FCrpeEngine.PEGetFieldObjectInfo(Cr.FPrintJob, Handle, fieldInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormula,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetFieldObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FFieldName := String(fieldInfo.fieldName);
  if fieldInfo.valueType = PE_FVT_UNKNOWNFIELD then
    Item.SetFieldType(fvUnknown)
  else
    Item.SetFieldType(TCrFieldValueType(fieldInfo.valueType));
  Item.FFieldLength    := fieldInfo.nBytes;
end;
{------------------------------------------------------------------------------}
{ GetItems                                                                     }
{   - This is the default property and can be also set                         }
{      via Crpe1.ParamFields[nIndex]                                           }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetItems(nIndex: integer): TCrpeParamFieldsItem;
begin
  SetIndex(nIndex);
  Result := TCrpeParamFieldsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeParamFields.GetItem : TCrpeParamFieldsItem;
begin
  Result := TCrpeParamFieldsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ SetItem                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeParamFields.SetItem (const nItem: TCrpeParamFieldsItem);
begin
  FItem.Assign(nItem);
end;


{******************************************************************************}
{ Class TCrpeSQLExpressionsItem                                                }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSQLExpressionsItem.Create;
begin
  inherited Create;
  FName       := '';
  FExpression := TStringList.Create;
  xExpression := TStringList.Create;
  TStringList(FExpression).OnChange := OnChangeStrings;
end;
{------------------------------------------------------------------------------}
{ destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSQLExpressionsItem.Destroy;
begin
  TStringList(FExpression).OnChange := nil;
  FExpression.Free;
  xExpression.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeSQLExpressionsItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeSQLExpressionsItem then
  begin
    Name := TCrpeSQLExpressionsItem(Source).Name;
    Expression.Assign(TCrpeSQLExpressionsItem(Source).Expression);
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSQLExpressionsItem.Clear;
begin
  inherited Clear;
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    Handle :=  0;
    FName  := '';
    FExpression.Clear;
    xExpression.Clear;
  end
  else
  begin
    xExpression.Clear;
    SetExpression(xExpression);
  end;
end;
{------------------------------------------------------------------------------}
{ Check                                                                        }
{------------------------------------------------------------------------------}
function TCrpeSQLExpressionsItem.Check : Boolean;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then Exit;
  if not Cr.OpenPrintJob then Exit;
  {Check the Expression}
  
  Result := Cr.FCrpeEngine.PECheckSQLExpression(Cr.FPrintJob, PChar(FName));
  if Result = False then
    Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'Check <PECheckSQLExpression>');
end;
{------------------------------------------------------------------------------}
{ OnChangeStrings                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeSQLExpressionsItem.OnChangeStrings(Sender: TObject);
begin
  TStringList(FExpression).OnChange := nil;
  xExpression.Assign(FExpression);
  SetExpression(xExpression);
  TStringList(FExpression).OnChange := OnChangeStrings;
end;
{------------------------------------------------------------------------------}
{ SetName                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeSQLExpressionsItem.SetName(const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetExpression                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeSQLExpressionsItem.SetExpression(ListVar: TStrings);
var
  iText : Smallint;
  hText : hWnd;
  pText : PChar;
  sText : string;
  sTmp  : string;
begin
  FExpression.Assign(ListVar);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Retrieve the Expression currently in the Report}
  iText := 0;
  
  if not Cr.FCrpeEngine.PEGetSQLExpression(Cr.FPrintJob, PChar(FName), hText, iText) then
  begin
    TStringList(FExpression).OnChange := OnChangeStrings;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetExpression <PEGetSQLExpression>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get the Expression Text}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetExpression <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sText := String(pText);
  StrDispose(pText);

  {Trim off LF/CR characters}
  sTmp := RTrimList(FExpression);
  {Compare it to the new formula...If they are the same, do not send}
  if CompareStr(sTmp, sText) <> 0 then
  begin
    {Send the Expression to the Report}
    
    if not Cr.FCrpeEngine.PESetSQLExpression(Cr.FPrintJob, PChar(FName), PChar(sTmp)) then
    begin
      TStringList(FExpression).OnChange := OnChangeStrings;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
           'SQLExpressions.SetExpression <PESetSQLExpression>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ Class TCrpeSQLExpressions                                                    }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeSQLExpressions.Create;
begin
  inherited Create;
  {Set inherited ObjectInfo properties}
  FObjectType      := otField;
  FFieldObjectType := oftExpression;
  {Expression properties}
  FIndex  := -1;
  FName   := '';
  FNames  := TStringList.Create;
  FItem := TCrpeSQLExpressionsItem.Create;
  FSubClassList.Add(FItem);
  FObjectPropertiesActive := True;
end;
{------------------------------------------------------------------------------}
{ destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeSQLExpressions.Destroy;
begin
  FNames.Free;
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeSQLExpressions.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex  := -1;
    Handle  :=  0;
    FName   := '';
    Item.Clear;
  end;
  FNames.Clear;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeSQLExpressions.Count : integer;
var
  nExpressions : Smallint;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get number of Expressions}
  
  nExpressions := Cr.FCrpeEngine.PEGetNSQLExpressions(Cr.FPrintJob);
  if (nExpressions = -1) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SQL.Expressions.Count <PEGetNSQLExpressions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := nExpressions;
end;
{------------------------------------------------------------------------------}
{ IndexOf                                                                      }
{------------------------------------------------------------------------------}
function TCrpeSQLExpressions.IndexOf(ExpressionName: string): integer;
var
  cnt : integer;
begin
  Result := -1;
  {Locate formula name}
  if Names.Count > 0 then
  begin
    for cnt := 0 to FNames.Count-1 do
    begin
      if CompareText(FNames[cnt], ExpressionName) = 0 then
      begin
        Result := cnt;
        Break;
      end;
    end;
  end;
  {If the Names list hasn't been built yet, or it wasn't found...}
  if Result = -1 then
  begin
    Names;
    for cnt := 0 to FNames.Count-1 do
    begin
      if CompareText(FNames[cnt], ExpressionName) = 0 then
      begin
        Result := cnt;
        Break;
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SQLExpressionByName                                                          }
{------------------------------------------------------------------------------}
function TCrpeSQLExpressions.ByName (ExpressionName: string): TCrpeSQLExpressionsItem;
var
  i : integer;
begin
  Result := GetItem;
  i := IndexOf(ExpressionName);
  if i = -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SQLEXPRESSION_BY_NAME,
        'SQLExpressions.ByName') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := GetItems(i);
end;
{------------------------------------------------------------------------------}
{ Names                                                                        }
{  - returns a list of Expression Names.  Faster than looping through items.   }
{------------------------------------------------------------------------------}
function TCrpeSQLExpressions.Names : TStrings;
var
  iName       : Smallint;
  hName       : HWnd;
  pName       : PChar;
  iExpression : Smallint;
  hExpression : HWnd;
  i           : integer;
begin
  FNames.Clear;
  Result := FNames;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  for i := 0 to Count - 1 do
  begin
    {Retrieve formula}
    
    if not Cr.FCrpeEngine.PEGetNthSQLExpression(Cr.FPrintJob, i, hName, iName,
      hExpression, iExpression) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Expressions.Names <PEGetNthFormula>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    {Get Formula Name}
    pName := StrAlloc(iName);
    if not Cr.FCrpeEngine.PEGetHandleString(hName, pName, iName) then
    begin
      StrDispose(pName);
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Expressions.Names <PEGetHandleString>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    FNames.Add(pName);
    StrDispose(pName);
  end;
  Result := FNames;
end;
{------------------------------------------------------------------------------}
{ SetName                                                                      }
{  - SetName does not overwrite the value,                                     }
{    it acts as a lookup for the name specified                                }
{------------------------------------------------------------------------------}
procedure TCrpeSQLExpressions.SetName(const Value: string);
var
  nIndex : integer;
begin
  if IsStrEmpty(Value) then
  begin
    SetIndex(-1);
    Exit;
  end;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if (Cr = nil) then Exit;
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
      'SQL.Expressions.Name := ' + Value) of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetObjectPropertiesActive                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeSQLExpressions.SetObjectPropertiesActive (const Value: Boolean);
begin
  FObjectPropertiesActive := Value;
  SetIndex(FIndex);
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeSQLExpressions.SetIndex (nIndex: integer);
var
  hName      : hWnd;
  iName      : Smallint;
  hText      : hWnd;
  iText      : Smallint;
  pText      : PChar;
  objIndex   : integer;
  sName      : string;
  objectInfo : PEObjectInfo;
  fieldInfo  : PEFieldObjectInfo;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    Clear;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;

  {Get the Expression}
  
  if not Cr.FCrpeEngine.PEGetNthSQLExpression(Cr.FPrintJob, nIndex, hName, iName,
    hText, iText) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SQL.Expressions.SetIndex <PEGetNthSQLExpression>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);

  {Get Expression Name}
  pText := StrAlloc(iName);
  if not Cr.FCrpeEngine.PEGetHandleString(hName, pText, iName) then
  begin
    StrDispose(pText);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SQL.Expressions.SetIndex <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FName := String(pText);
  Item.FName := FName;
  StrDispose(pText);

  {Get Expression Text}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'SQL.Expressions.SetIndex <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FExpression.SetText(pText);
  StrDispose(pText);

  {Attempt to Retrieve Handle}
  sName := NameToCrFormulaFormat(FName, 'SQLExpressions');
  if FObjectPropertiesActive then
    Handle := Cr.GetFieldObjectHandle(sName, oftExpression, objIndex)
  else  {if False, ignore Object Properties}
    Handle := 0;
  PropagateHandle(Handle);
  if Handle = 0 then
  begin
    Item.FFieldName := '';
    Item.SetFieldType(fvUnknown);
    Item.FFieldLength := 0;
    Item.FTop       := -1;
    Item.FLeft      := -1;
    Item.FWidth     := -1;
    Item.FHeight    := -1;
    Item.FSection   := '';
    Item.FBorder.Clear;
    Item.FFormat.Clear;
    Item.FFont.Clear;
    Item.FHiliteConditions.Clear;
    Exit;
  end;

  {Update Border, Format, Font}
  if csDesigning in Cr.ComponentState then
  begin
    Item.FBorder.GetBorder;
    Item.FFormat.GetFormat;
    Item.FFont.GetFont;
  end;
  {Update HiliteConditions}
  if Item.FHiliteConditions.FIndex > (Item.FHiliteConditions.Count-1) then
    Item.FHiliteConditions.SetIndex(-1);

  {Object Info}
  
  if not Cr.FCrpeEngine.PEGetObjectInfo(Cr.FPrintJob, Handle, objectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FLeft := objectInfo.xOffset;
  Item.FTop := objectInfo.yOffset;
  Item.FWidth := objectInfo.width;
  Item.FHeight := objectInfo.height;
  Item.FSection := Cr.SectionCodeToStringEx(objectInfo.sectionCode, False);
  {Field Object Info}
  
  if not Cr.FCrpeEngine.PEGetFieldObjectInfo(Cr.FPrintJob, Handle, fieldInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormula,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetFieldObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FFieldName := String(fieldInfo.fieldName);
  if fieldInfo.valueType = PE_FVT_UNKNOWNFIELD then
    Item.SetFieldType(fvUnknown)
  else
    Item.SetFieldType(TCrFieldValueType(fieldInfo.valueType));
  Item.FFieldLength    := fieldInfo.nBytes;
end;
{------------------------------------------------------------------------------}
{ GetItems                                                                     }
{   - This is the default property and can be also set                         }
{      via Crpe1.SQL.Expressions[nIndex]                                       }
{------------------------------------------------------------------------------}
function TCrpeSQLExpressions.GetItems(nIndex: integer) : TCrpeSQLExpressionsItem;
begin
  SetIndex(nIndex);
  Result := TCrpeSQLExpressionsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeSQLExpressions.GetItem : TCrpeSQLExpressionsItem;
begin
  Result := TCrpeSQLExpressionsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ SetItem                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeSQLExpressions.SetItem (const nItem: TCrpeSQLExpressionsItem);
begin
  FItem.Assign(nItem);
end;


{******************************************************************************}
{ Class TCrpeRunningTotalsItem                                                 }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeRunningTotalsItem.Create;
begin
  inherited Create;
  {RT Properties}
  FName             := '';
  FSummaryField     := '';
  FSummaryType      := stCount;
  FSummaryTypeN     := -1;
  FSummaryTypeField := '';
  FEvalField        := '';
  FEvalFormula      := TStringList.Create;
  TStringList(FEvalFormula).OnChange := OnChangeEvalFormula;
  FEvalCondition    := rtcNoCondition;
  FEvalGroupN       := -1;
  FResetField       := '';
  FResetFormula     := TStringList.Create;
  TStringList(FResetFormula).OnChange := OnChangeResetFormula;
  FResetCondition   := rtcNoCondition;
  FResetGroupN      := -1;
  {temp}
  xEvalFormula      := TStringList.Create;
  xResetFormula     := TStringList.Create;
end;
{------------------------------------------------------------------------------}
{ Destroy                                                                      }
{------------------------------------------------------------------------------}
destructor TCrpeRunningTotalsItem.Destroy;
begin
  TStringList(FEvalFormula).OnChange := nil;
  FEvalFormula.Free;
  TStringList(FResetFormula).OnChange := nil;
  FResetFormula.Free;
  xEvalFormula.Free;
  xResetFormula.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeRunningTotalsItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeRunningTotalsItem then
  begin
    Name             := TCrpeRunningTotalsItem(Source).Name;
    SummaryField     := TCrpeRunningTotalsItem(Source).SummaryField;
    SummaryType      := TCrpeRunningTotalsItem(Source).SummaryType;
    SummaryTypeN     := TCrpeRunningTotalsItem(Source).SummaryTypeN;
    SummaryTypeField := TCrpeRunningTotalsItem(Source).SummaryTypeField;
    EvalField        := TCrpeRunningTotalsItem(Source).EvalField;
    EvalFormula.Assign(TCrpeRunningTotalsItem(Source).EvalFormula);
    EvalCondition    := TCrpeRunningTotalsItem(Source).EvalCondition;
    EvalGroupN       := TCrpeRunningTotalsItem(Source).EvalGroupN;
    ResetField       := TCrpeRunningTotalsItem(Source).ResetField;
    ResetFormula.Assign(TCrpeRunningTotalsItem(Source).ResetFormula);
    ResetCondition   := TCrpeRunningTotalsItem(Source).ResetCondition;
    ResetGroupN      := TCrpeRunningTotalsItem(Source).ResetGroupN;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeRunningTotalsItem.Clear;
begin
  inherited Clear;
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex            := -1;
    Handle            :=  0;
    FName             := '';
    FSummaryField     := '';
    FSummaryType      := stCount;
    FSummaryTypeN     := -1;
    FSummaryTypeField := '';
    FEvalField        := '';
    FEvalFormula.Clear;
    FEvalCondition    := rtcNoCondition; {evaluate for each record}
    FEvalGroupN       := -1;
    FResetField       := '';
    FResetFormula.Clear;
    FResetCondition   := rtcNoCondition; {reset never}
    FResetGroupN      := -1;
  end;
end;
{------------------------------------------------------------------------------}
{ OnChangeEvalFormula                                                          }
{------------------------------------------------------------------------------}
procedure TCrpeRunningTotalsItem.OnChangeEvalFormula;
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ OnChangeResetFormula                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeRunningTotalsItem.OnChangeResetFormula;
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetName                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeRunningTotalsItem.SetName (const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetSummaryField                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeRunningTotalsItem.SetSummaryField (const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetSummaryType                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeRunningTotalsItem.SetSummaryType (const Value: TCrSummaryType);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetSummaryTypeN                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeRunningTotalsItem.SetSummaryTypeN (const Value: Smallint);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetSummaryTypeField                                                          }
{------------------------------------------------------------------------------}
procedure TCrpeRunningTotalsItem.SetSummaryTypeField (const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetEvalCondition                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeRunningTotalsItem.SetEvalCondition (const Value: TCrRunningTotalCondition);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetEvalField                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeRunningTotalsItem.SetEvalField (const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetEvalGroupN                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeRunningTotalsItem.SetEvalGroupN (const Value: Smallint);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetEvalFormula                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeRunningTotalsItem.SetEvalFormula (const Value: TStrings);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetResetCondition                                                            }
{------------------------------------------------------------------------------}
procedure TCrpeRunningTotalsItem.SetResetCondition (const Value: TCrRunningTotalCondition);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetResetField                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeRunningTotalsItem.SetResetField (const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetResetGroupN                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeRunningTotalsItem.SetResetGroupN (const Value: Smallint);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetResetFormula                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeRunningTotalsItem.SetResetFormula (const Value: TStrings);
begin
  {Read only}
end;


{******************************************************************************}
{ Class TCrpeRunningTotals                                                     }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeRunningTotals.Create;
begin
  inherited Create;
  {Set inherited ObjectInfo properties}
  FObjectType      := otField;
  FFieldObjectType := oftRunningTotal;
  {RT Properties}
  FIndex           := -1;
  FName            := '';
  FNames           := TStringList.Create;
  FItem            := TCrpeRunningTotalsItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destroy                                                                      }
{------------------------------------------------------------------------------}
destructor TCrpeRunningTotals.Destroy;
begin
  FNames.Free;
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeRunningTotals.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    Handle :=  0;
    FName  := '';
    FItem.Clear;
  end;
  FNames.Clear;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeRunningTotals.Count : integer;
var
  nRunningTotals : Smallint;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get number of Formulas}
  
  nRunningTotals := Cr.FCrpeEngine.PEGetNRunningTotals(Cr.FPrintJob);
  if nRunningTotals = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'RunningTotals.Count <PEGetNRunningTotals>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := nRunningTotals;
end;
{------------------------------------------------------------------------------}
{ IndexOf                                                                      }
{------------------------------------------------------------------------------}
function TCrpeRunningTotals.IndexOf (RunningTotalName: string): integer;
var
  i : integer;
begin
  Result := -1;
  {Locate formula name}
  if Names.Count > 0 then
  begin
    for i := 0 to FNames.Count-1 do
    begin
      if CompareText(FNames[i], RunningTotalName) = 0 then
      begin
        Result := i;
        Break;
      end;
    end;
  end;
  {If the Names list hasn't been built yet, or it wasn't found...}
  if Result = -1 then
  begin
    Names;
    for i := 0 to FNames.Count-1 do
    begin
      if CompareText(FNames[i], RunningTotalName) = 0 then
      begin
        Result := i;
        Break;
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ ByName                                                                       }
{------------------------------------------------------------------------------}
function TCrpeRunningTotals.ByName (RunningTotalName: string): TCrpeRunningTotalsItem;
var
  i : integer;
begin
  Result := GetItem;
  i := IndexOf(RunningTotalName);
  if i = -1 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_RUNNINGTOTAL_BY_NAME,
        'RunningTotals.ByName') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := GetItems(i);
end;
{------------------------------------------------------------------------------}
{ Names                                                                        }
{  - returns a list of RunningTotal Names.  Faster than looping through items. }
{------------------------------------------------------------------------------}
function TCrpeRunningTotals.Names : TStrings;
var
  iName : Smallint;
  hName : HWnd;
  pName : PChar;
  i     : integer;

begin
  FNames.Clear;
  Result := FNames;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  for i := 0 to Count - 1 do
  begin
    {Retrieve formula}
    
    if not Cr.FCrpeEngine.PEGetNthRunningTotalName(Cr.FPrintJob, i, hName, iName) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'GetNames <PEGetNthRunningTotalName>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    {Get Name Text}
    pName := StrAlloc(iName);
    if not Cr.FCrpeEngine.PEGetHandleString(hName, pName, iName) then
    begin
      StrDispose(pName);
       case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
           Cr.BuildErrorString(Self) + 'GetNames <PEGetHandleString>') of
         errIgnore : Exit;
         errAbort  : Abort;
         errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
       end;
    end;
    FNames.Add(pName);
    StrDispose(pName);
  end;
  Result := FNames;
end;
{------------------------------------------------------------------------------}
{ SetName                                                                      }
{  - Name cannot be modified, just acts as a lookup value                      }
{------------------------------------------------------------------------------}
procedure TCrpeRunningTotals.SetName (const Value: string);
var
  nIndex : integer;
begin
  if IsStrEmpty(Value) then
  begin
    SetIndex(-1);
    Exit;
  end;
  nIndex := IndexOf(Value);
  if nIndex > -1 then
    SetIndex(nIndex)
  else
  begin
    if (Cr = nil) then Exit;
    if csLoading in Cr.ComponentState then
    begin
      FIndex := -1;
      Exit;
    end;
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_NOT_FOUND,
        Cr.BuildErrorString(Self) + 'Name := ' + Value) of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeRunningTotals.SetIndex (nIndex: integer);
var
  hName         : HWnd;
  iName         : Smallint;
  pName         : PChar;
  hSumField     : HWnd;
  iSumField     : Smallint;
  hSumField2    : HWnd;
  iSumField2    : Smallint;
  pField        : PChar;
  hEvalField    : HWnd;
  iEvalField    : Smallint;
  hResetField   : HWnd;
  iResetField   : Smallint;
  hEvalFormula  : HWnd;
  iEvalFormula  : Smallint;
  hResetFormula : HWnd;
  iResetFormula : Smallint;
  pFormula      : PChar;
  rtInfo        : PERunningTotalInfo;
  objIndex      : integer;
  sName         : string;
  objectInfo    : PEObjectInfo;
  fieldInfo     : PEFieldObjectInfo;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    Clear;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;

  {Running Total Name}
  
  if not Cr.FCrpeEngine.PEGetNthRunningTotalName(Cr.FPrintJob, nIndex,
    hName, iName) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetNthRunningTotalName>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);

  {Get Text of Nth Running Total Name}
  pName := StrAlloc(iName);
  if not Cr.FCrpeEngine.PEGetHandleString(hName, pName, iName) then
  begin
    StrDispose(pName);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetHandleString - Name>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FName := String(pName);
  Item.FName := FName;
  StrDispose(pName);

  {Summary Field}
  
  if not Cr.FCrpeEngine.PEGetRunningTotalSummaryField(Cr.FPrintJob, PChar(FName),
    hSumField, iSumField, hSumField2, iSumField2) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetRunningTotalSummaryField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  pField := StrAlloc(iSumField);
  if not Cr.FCrpeEngine.PEGetHandleString(hSumField, pField, iSumField) then
  begin
    StrDispose(pField);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetHandleString - SummaryField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FSummaryField := String(pField);
  StrDispose(pField);

  {SummaryType Field}
  pField := StrAlloc(iSumField2);
  if not Cr.FCrpeEngine.PEGetHandleString(hSumField2, pField, iSumField2) then
  begin
    StrDispose(pField);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetHandleString - SummaryTypeField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FSummaryTypeField := String(pField);
  StrDispose(pField);

  {Running Total Info}
  
  if not Cr.FCrpeEngine.PEGetRunningTotalInfo(Cr.FPrintJob, PChar(FName), rtInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetRunningTotalInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FSummaryType := TCrSummaryType(rtInfo.summaryOperation);
  Item.FSummaryTypeN := rtInfo.summaryOperationParameter;
  Item.FEvalCondition := TCrRunningTotalCondition(rtInfo.evalCondition);
  Item.FEvalGroupN := rtInfo.evalGroupN;
  Item.FResetCondition := TCrRunningTotalCondition(rtInfo.resetCondition);
  Item.FResetGroupN := rtInfo.resetGroupN;

  {EvalField / ResetField}
  
  if not Cr.FCrpeEngine.PEGetRunningTotalConditionField(Cr.FPrintJob, PChar(FName),
    hEvalField, iEvalField, hResetField, iResetField) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetRunningTotalConditionField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Get EvalField}
  pField := StrAlloc(iEvalField);
  if not Cr.FCrpeEngine.PEGetHandleString(hEvalField, pField, iEvalField) then
  begin
    StrDispose(pField);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetHandleString - EvalField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FEvalField := String(pField);
  StrDispose(pField);

  {Get ResetField}
  pField := StrAlloc(iResetField);
  if not Cr.FCrpeEngine.PEGetHandleString(hResetField, pField, iResetField) then
  begin
    StrDispose(pField);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetHandleString - ResetField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FResetField := String(pField);
  StrDispose(pField);

  {EvalFormula / ResetFormula}
  
  if not Cr.FCrpeEngine.PEGetRunningTotalConditionFormula(Cr.FPrintJob, PChar(FName),
    hEvalFormula, iEvalFormula, hResetFormula, iResetFormula) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetRunningTotalConditionFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Get EvalFormula}
  pFormula := StrAlloc(iEvalFormula);
  if not Cr.FCrpeEngine.PEGetHandleString(hEvalFormula, pFormula, iEvalFormula) then
  begin
    StrDispose(pFormula);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetHandleString - EvalFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FEvalFormula.SetText(pFormula);
  StrDispose(pFormula);

  {Get Reset Formula}
  
  pFormula := StrAlloc(iResetFormula);
  if not Cr.FCrpeEngine.PEGetHandleString(hResetFormula, pFormula, iResetFormula) then
  begin
    StrDispose(pFormula);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetHandleString - ResetFormula>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FResetFormula.SetText(pFormula);
  StrDispose(pFormula);

  {Attempt to Retrieve Handle}
  sName := '{#' + FName + '}';
  Handle := Cr.GetFieldObjectHandle(sName, oftRunningTotal, objIndex);
  PropagateHandle(Handle);
  if Handle = 0 then
  begin
    Item.FFieldName   := '';
    Item.SetFieldType(fvUnknown);
    Item.FFieldLength := 0;
    Item.FTop         := -1;
    Item.FLeft        := -1;
    Item.FWidth       := -1;
    Item.FHeight      := -1;
    Item.FSection     := '';
    Item.FBorder.Clear;
    Item.FFormat.Clear;
    Item.FFont.Clear;
    Item.FHiliteConditions.Clear;
    Exit;
  end;

  {Update Border, Format, Font}
  if csDesigning in Cr.ComponentState then
  begin
    FItem.Border.GetBorder;
    FItem.Format.GetFormat;
    FItem.Font.GetFont;
  end;
  {Update HiliteConditions}
  if Item.FHiliteConditions.FIndex > (Item.FHiliteConditions.Count-1) then
    Item.FHiliteConditions.SetIndex(-1);

  {Object Info}
  
  if not Cr.FCrpeEngine.PEGetObjectInfo(Cr.FPrintJob, Handle, objectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FLeft := objectInfo.xOffset;
  Item.FTop := objectInfo.yOffset;
  Item.FWidth := objectInfo.width;
  Item.FHeight := objectInfo.height;
  Item.FSection := Cr.SectionCodeToStringEx(objectInfo.sectionCode, False);
  {Field Object Info}
  
  if not Cr.FCrpeEngine.PEGetFieldObjectInfo(Cr.FPrintJob, Handle, fieldInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errFormula,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetFieldObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FFieldName := String(fieldInfo.fieldName);
  if fieldInfo.valueType = PE_FVT_UNKNOWNFIELD then
    Item.SetFieldType(fvUnknown)
  else
    Item.SetFieldType(TCrFieldValueType(fieldInfo.valueType));
  Item.FFieldLength := fieldInfo.nBytes;
end;
{------------------------------------------------------------------------------}
{ GetItems                                                                     }
{------------------------------------------------------------------------------}
function TCrpeRunningTotals.GetItems(nIndex: integer) : TCrpeRunningTotalsItem;
begin
  SetIndex(nIndex);
  Result := TCrpeRunningTotalsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeRunningTotals.GetItem : TCrpeRunningTotalsItem;
begin
  Result := TCrpeRunningTotalsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ SetItem                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeRunningTotals.SetItem (const nItem: TCrpeRunningTotalsItem);
begin
  FItem.Assign(nItem);
end;


{******************************************************************************}
{******************************************************************************}
{ Other Objects                                                                }
{******************************************************************************}
{******************************************************************************}

{******************************************************************************}
{ Class TCrpeTextObjectsItem                                                   }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeTextObjectsItem.Create;
begin
  inherited Create;
  {Paragraphs}
  FParagraphs        := TCrpeParagraphs.Create;
  FSubClassList.Add(FParagraphs);
  {EmbeddedFields}
  FEmbeddedFields    := TCrpeEmbeddedFields.Create;
  FSubClassList.Add(FEmbeddedFields);
  {TextObject specific}
  FLines             := TStringList.Create;
  xLines             := TStringList.Create;
  TStringList(FLines).OnChange := OnChangeLines;
  FTextHeight        := -1;
  FTextSize          := -1;
end;
{------------------------------------------------------------------------------}
{ Destroy                                                                      }
{------------------------------------------------------------------------------}
destructor TCrpeTextObjectsItem.Destroy;
begin
  TStringList(FLines).OnChange := nil;
  FLines.Free;
  xLines.Free;
  FParagraphs.Free;
  FEmbeddedFields.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeTextObjectsItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeTextObjectsItem then
  begin
    Paragraphs.Assign(TCrpeTextObjectsItem(Source).Paragraphs);
    EmbeddedFields.Assign(TCrpeTextObjectsItem(Source).EmbeddedFields);
    Lines.Assign(TCrpeTextObjectsItem(Source).Lines);
    TextHeight := TCrpeTextObjectsItem(Source).TextHeight;
    TextSize   := TCrpeTextObjectsItem(Source).TextSize;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeTextObjectsItem.Clear;
begin
  inherited Clear;
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex      := -1;
    Handle      :=  0;
    FTextHeight := -1;
    FTextSize   := -1;
  end;
  xLines.Clear;
  SetLines(xLines);
  FParagraphs.Clear;
  FEmbeddedFields.Clear;
end;
{------------------------------------------------------------------------------}
{ InsertText                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeTextObjectsItem.InsertText (Text: TStrings; Position: LongInt);
var
  sTmp : string;
begin
  if not StatusIsGo(FIndex) then Exit;

  sTmp := RTrimList(Text);
  {Crystal will add a linefeed Chr(10) wherever there is a
   carriage return Chr(13) so we want to eliminate the internal
   linefeeds or the text will be double-spaced}
//  RemoveChar(sTmp, Chr(10));
  if not Cr.FCrpeEngine.PEInsertText(Cr.FPrintJob, Handle, Position, PChar(sTmp)) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'InsertText <PEInsertText>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ DeleteText                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeTextObjectsItem.DeleteText (TextStart, TextEnd: LongInt);
begin
  if not StatusIsGo(FIndex) then Exit;
  if not Cr.FCrpeEngine.PEDeleteText(Cr.FPrintJob, Handle, TextStart, TextEnd) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'DeleteText <PEDeleteText>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ InsertFile                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeTextObjectsItem.InsertFile (FilePath: string; Position: LongInt);
var
  sList : TStringList;
begin
  if not StatusIsGo(FIndex) then Exit;
  sList := TStringList.Create;
  try
    sList.LoadFromFile(FilePath);
    InsertText(sList, Position);
  finally
    sList.Free;
  end;
end;
{------------------------------------------------------------------------------}
{ SetLines                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeTextObjectsItem.SetLines (ListVar: TStrings);
var
  hText : HWnd;
  iText : Smallint;
  pText : PChar;
  sText : string;
  sTmp  : string;
begin
  FLines.Assign(ListVar);
  if not StatusIsGo(FIndex) then Exit;

  {Retrieve Text from Report}
  if not Cr.FCrpeEngine.PEGetText(Cr.FPrintJob, Handle, hText, iText) then
  begin
    TStringList(FLines).OnChange := OnChangeLines;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetLines <PEGetText>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Get the Text string from the Handle}
  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    TStringList(FLines).OnChange := OnChangeLines;
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetLines <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sText := String(pText);
  StrDispose(pText);

  {Trim off trailing LF/CR characters}
  sTmp := RTrimList(FLines);
  {Compare with Report: if changed, send in text}
  if CompareStr(sTmp, sText) <> 0 then
  begin
    {Delete Current Text}
    if not Cr.FCrpeEngine.PEDeleteText(Cr.FPrintJob, Handle, 0, Length(sText)-1) then
    begin
      TStringList(FLines).OnChange := OnChangeLines;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetLines <PEDeleteText>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    {Send the Text into the Report}
    {Crystal will add a linefeed Chr(10) wherever there is a
     carriage return Chr(13) so we want to eliminate the internal
     linefeeds or the text will be double-spaced}
//    RemoveChar(sTmp, Chr(10));
    if not Cr.FCrpeEngine.PEInsertText(Cr.FPrintJob, Handle, 0, PChar(sTmp)) then
    begin
      TStringList(FLines).OnChange := OnChangeLines;
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetLines <PEInsertText>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ OnChangeLines                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeTextObjectsItem.OnChangeLines (Sender: TObject);
begin
  TStringList(FLines).OnChange := nil;
  xLines.Assign(FLines);
  SetLines(xLines);
  TStringList(FLines).OnChange := OnChangeLines;
end;
{------------------------------------------------------------------------------}
{ SetTextSize                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeTextObjectsItem.SetTextSize (const Value: LongInt);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetTextHeight                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeTextObjectsItem.SetTextHeight (const Value: LongInt);
begin
  {Read only}
end;


{******************************************************************************}
{ Class TCrpeTextObjects                                                       }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeTextObjects.Create;
begin
  inherited Create;
  {Set inherited ObjectInfo properties}
  FObjectType      := otText;
  FFieldObjectType := oftNone;
  FItem := TCrpeTextObjectsItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destroy                                                                      }
{------------------------------------------------------------------------------}
destructor TCrpeTextObjects.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeTextObjects.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    Handle :=  0;
    FItem.Clear;
  end;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeTextObjects.SetIndex (nIndex: integer);
var
  hText : HWnd;
  pText : PChar;
  iText : Smallint;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    Clear;
    Exit;
  end;
  inherited SetIndex(nIndex);
  if Handle = 0 then
  begin
    PropagateHandle(0);
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;
  PropagateHandle(Handle);

  {Retrieve Lines & properties}
  if not Cr.FCrpeEngine.PEGetText(Cr.FPrintJob, Handle, hText, iText) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetIndex <PEGetText>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);

  pText := StrAlloc(iText);
  if not Cr.FCrpeEngine.PEGetHandleString(hText, pText, iText) then
  begin
    StrDispose(pText);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetIndex <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FLines.SetText(pText);
  StrDispose(pText);

  {Text Size}
  Item.FTextSize := Cr.FCrpeEngine.PEGetTextSize(Cr.FPrintJob, Handle);
  {Text Height}
  Item.FTextHeight := Cr.FCrpeEngine.PEGetTextHeight(Cr.FPrintJob, Handle);
  {Paragraphs}
  if Item.FParagraphs.FIndex > (Item.FParagraphs.Count-1) then
    Item.FParagraphs.SetIndex(-1);
  {EmbeddedFields}
  if Item.FEmbeddedFields.FIndex > (Item.FEmbeddedFields.Count-1) then
    Item.FEmbeddedFields.SetIndex(-1);
  {Set Field Type for Format property}
  Item.FFormat.SetFieldType(fvString);
  Item.FFormat.Paragraph.SetFieldType(fvString);
  Item.FFormat.Paragraph.FForEmbeddedField := False;
  Item.FFormat.Paragraph.FForTextObject := True;
  {if in Design mode, update properties}
  if csDesigning in Cr.ComponentState then
  begin
    {Update Border values}
    Item.FBorder.GetLeft;
    Item.FBorder.GetRight;
    Item.FBorder.GetTop;
    Item.FBorder.GetBottom;
    Item.FBorder.GetTightHorizontal;
    Item.FBorder.GetDropShadow;
    Item.FBorder.GetForeColor;
    Item.FBorder.GetBackgroundColor;
    {Update Format values}
    Item.FFormat.GetSuppress;
    Item.FFormat.GetKeepTogether;
    Item.FFormat.GetCloseBorder;
    Item.FFormat.GetToolTip;
    Item.FFormat.GetAlignment;
    Item.FFormat.GetCanGrow;
    Item.FFormat.GetMaxNLines;
    Item.FFormat.GetTextRotation;
    Item.FFormat.GetSuppressIfDuplicated;
    Item.FFormat.Paragraph.GetFormat;
    {Update Font values}
    Item.FFont.GetFont;
  end;
end;
{------------------------------------------------------------------------------}
{ GetItems                                                                     }
{------------------------------------------------------------------------------}
function TCrpeTextObjects.GetItems(nIndex: integer) : TCrpeTextObjectsItem;
begin
  SetIndex(nIndex);
  Result := TCrpeTextObjectsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeTextObjects.GetItem : TCrpeTextObjectsItem;
begin
  Result := TCrpeTextObjectsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ SetItem                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeTextObjects.SetItem (const nItem: TCrpeTextObjectsItem);
begin
  FItem.Assign(nItem);
end;


{******************************************************************************}
{ Class TCrpeLinesItem                                                         }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeLinesItem.Create;
begin
  inherited Create;
  FSectionStart := '';
  FSectionEnd   := '';
  FLineStyle    := lsNone;
  FTop          := -1;
  FBottom       := -1;
  FWidth        := -1;
  FLeft         := -1;
  FRight        := -1;
  FColor        := clNone;
  FExtend       := False;
  FSuppress     := False;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeLinesItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeLinesItem then
  begin
    SectionStart := TCrpeLinesItem(Source).SectionStart;
    SectionEnd   := TCrpeLinesItem(Source).SectionEnd;
    LineStyle    := TCrpeLinesItem(Source).LineStyle;
    Top          := TCrpeLinesItem(Source).Top;
    Bottom       := TCrpeLinesItem(Source).Bottom;
    Width        := TCrpeLinesItem(Source).Width;
    Left         := TCrpeLinesItem(Source).Left;
    Right        := TCrpeLinesItem(Source).Right;
    Color        := TCrpeLinesItem(Source).Color;
    Extend       := TCrpeLinesItem(Source).Extend;
    Suppress     := TCrpeLinesItem(Source).Suppress;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeLinesItem.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex        := -1;
    Handle        :=  0;
    FSectionStart := '';
    FSectionEnd   := '';
    FLineStyle    := lsNone;
    FTop          := -1;
    FBottom       := -1;
    FWidth        := -1;
    FLeft         := -1;
    FRight        := -1;
    FColor        := clNone;
    FExtend       := False;
    FSuppress     := False;
  end;
end;
{------------------------------------------------------------------------------}
{ StatusIsGo                                                                   }
{------------------------------------------------------------------------------}
function TCrpeLinesItem.StatusIsGo: Boolean;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if (csLoading in Cr.ComponentState) then Exit;
  if FIndex < 0 then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;
  {Check Handle}
  if Handle = 0 then
    Handle := Cr.GetObjectHandle(FIndex, otLine, oftNone);
  if Handle = 0 then
  begin
    PropagateHandle(0);
    Exit;
  end;
  Result := True;
end;
{------------------------------------------------------------------------------}
{ SetSectionStart                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeLinesItem.SetSectionStart (const Value: string);
var
  lineObjectInfo : PELineObjectInfo;
  SectionCode    : Smallint;
begin
  FSectionStart := Value;
  if not StatusIsGo then Exit;

  
  if not Cr.FCrpeEngine.PEGetLineObjectInfo(Cr.FPrintJob, Handle, lineObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Lines.SetSectionStart <PEGetLineObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Convert Section String to Code}
  if not StrToSectionCode(FSectionStart, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'Lines.SetSectionStart(' + Value + ') <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare}
  if SectionCode <> lineObjectInfo.startSectionCode then
  begin
    lineObjectInfo.startSectionCode := SectionCode;
    {Send to Print Engine}
    
    if not Cr.FCrpeEngine.PESetLineObjectInfo(Cr.FPrintJob, Handle, lineObjectInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Lines.SetSectionStart <PESetLineObjectInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetSectionEnd                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeLinesItem.SetSectionEnd (const Value: string);
var
  lineObjectInfo : PELineObjectInfo;
  SectionCode    : Smallint;
begin
  FSectionEnd := Value;
  if not StatusIsGo then Exit;

  
  if not Cr.FCrpeEngine.PEGetLineObjectInfo(Cr.FPrintJob, Handle, lineObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Lines.SetSectionEnd <PEGetLineObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Convert Section String to Code}
  if not StrToSectionCode(FSectionEnd, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        'Lines.SetSectionEnd(' + Value + ') <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare}
  if SectionCode <> lineObjectInfo.endSectionCode then
  begin
    lineObjectInfo.endSectionCode := SectionCode;
    {Send to Print Engine}
    
    if not Cr.FCrpeEngine.PESetLineObjectInfo(Cr.FPrintJob, Handle, lineObjectInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Lines.SetSectionEnd <PESetLineObjectInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetLineStyle                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeLinesItem.SetLineStyle (const Value: TCrLineStyle);
var
  lineObjectInfo : PELineObjectInfo;
begin
  FLineStyle := Value;
  if not StatusIsGo then Exit;

  
  if not Cr.FCrpeEngine.PEGetLineObjectInfo(Cr.FPrintJob, Handle, lineObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Lines.SetLineStyle <PEGetLineObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {LineStyle}
  if lineObjectInfo.lineStyle <> Ord(FLineStyle) then
  begin
    lineObjectInfo.lineStyle := Ord(FLineStyle);
    {Send to Print Engine}
    
    if not Cr.FCrpeEngine.PESetLineObjectInfo(Cr.FPrintJob, Handle, lineObjectInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Lines.SetLineStyle <PESetLineObjectInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetTop                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeLinesItem.SetTop (const Value: LongInt);
var
  lineObjectInfo : PELineObjectInfo;
begin
  FTop := Value;
  if not StatusIsGo then Exit;

  
  if not Cr.FCrpeEngine.PEGetLineObjectInfo(Cr.FPrintJob, Handle, lineObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Lines.SetTop <PEGetLineObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if FTop <> lineObjectInfo.topYOffset then
  begin
    lineObjectInfo.topYOffset := FTop;
    {Send to Print Engine}
    
    if not Cr.FCrpeEngine.PESetLineObjectInfo(Cr.FPrintJob, Handle, lineObjectInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Lines.SetTop <PESetLineObjectInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetLeft                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeLinesItem.SetLeft (const Value: LongInt);
var
  lineObjectInfo : PELineObjectInfo;
begin
  FLeft := Value;
  if not StatusIsGo then Exit;

  
  if not Cr.FCrpeEngine.PEGetLineObjectInfo(Cr.FPrintJob, Handle, lineObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Lines.SetLeft <PEGetLineObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if FLeft <> lineObjectInfo.leftXOffset then
  begin
    lineObjectInfo.leftXOffset := FLeft;
    {Send to Print Engine}
    
    if not Cr.FCrpeEngine.PESetLineObjectInfo(Cr.FPrintJob, Handle, lineObjectInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Lines.SetLeft <PESetLineObjectInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetWidth                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeLinesItem.SetWidth (const Value: LongInt);
var
  lineObjectInfo : PELineObjectInfo;
begin
  FWidth := Value;
  if not StatusIsGo then Exit;

  
  if not Cr.FCrpeEngine.PEGetLineObjectInfo(Cr.FPrintJob, Handle, lineObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Lines.SetTop <PEGetLineObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if FWidth <> lineObjectInfo.lineWidth then
  begin
    lineObjectInfo.lineWidth := FWidth;
    {Send to Print Engine}
    
    if not Cr.FCrpeEngine.PESetLineObjectInfo(Cr.FPrintJob, Handle, lineObjectInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Lines.SetTop <PESetLineObjectInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetRight                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeLinesItem.SetRight (const Value: LongInt);
var
  lineObjectInfo : PELineObjectInfo;
begin
  FRight := Value;
  if not StatusIsGo then Exit;

  
  if not Cr.FCrpeEngine.PEGetLineObjectInfo(Cr.FPrintJob, Handle, lineObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Lines.SetRight <PEGetLineObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if FRight <> lineObjectInfo.rightXOffset then
  begin
    lineObjectInfo.rightXOffset := FRight;
    {Send to Print Engine}
    
    if not Cr.FCrpeEngine.PESetLineObjectInfo(Cr.FPrintJob, Handle, lineObjectInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Lines.SetRight <PESetLineObjectInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetBottom                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeLinesItem.SetBottom (const Value: LongInt);
var
  lineObjectInfo : PELineObjectInfo;
begin
  FBottom := Value;
  if not StatusIsGo then Exit;

  
  if not Cr.FCrpeEngine.PEGetLineObjectInfo(Cr.FPrintJob, Handle, lineObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Lines.SetBottom <PEGetLineObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if FBottom <> lineObjectInfo.bottomYOffset then
  begin
    lineObjectInfo.bottomYOffset := FBottom;
    {Send to Print Engine}
    
    if not Cr.FCrpeEngine.PESetLineObjectInfo(Cr.FPrintJob, Handle, lineObjectInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Lines.SetBottom <PESetLineObjectInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetColor                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeLinesItem.SetColor (const Value: TColor);
var
  lineObjectInfo : PELineObjectInfo;
  nColor1        : TColor;
  nColor2        : TColor;
begin
  FColor := Value;
  if not StatusIsGo then Exit;

  
  if not Cr.FCrpeEngine.PEGetLineObjectInfo(Cr.FPrintJob, Handle, lineObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Lines.SetBottom <PEGetLineObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if lineObjectInfo.lineColor = PE_NO_COLOR then
    nColor1 := clNone
  else
    nColor1 := TColor(lineObjectInfo.lineColor);
  nColor2 := FColor;
  if nColor1 <> nColor2 then
  begin
    if nColor2 = clNone then
      lineObjectInfo.lineColor := PE_NO_COLOR
    else
      lineObjectInfo.lineColor := ColorToRGB(nColor2);
    {Send to Print Engine}
    
    if not Cr.FCrpeEngine.PESetLineObjectInfo(Cr.FPrintJob, Handle, lineObjectInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Lines.SetColor <PESetLineObjectInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetExtend                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeLinesItem.SetExtend (const Value: Boolean);
var
  lineObjectInfo : PELineObjectInfo;
begin
  FExtend := Value;
  if not StatusIsGo then Exit;

  
  if not Cr.FCrpeEngine.PEGetLineObjectInfo(Cr.FPrintJob, Handle, lineObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Lines.SetExtend <PEGetLineObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if lineObjectInfo.expandToNextSection <> Smallint(FExtend) then
  begin
    if FExtend = False then
      lineObjectInfo.expandToNextSection := 0
    else
      lineObjectInfo.expandToNextSection := 1;
    {Send to Print Engine}
    
    if not Cr.FCrpeEngine.PESetLineObjectInfo(Cr.FPrintJob, Handle, lineObjectInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Lines.SetExtend <PESetLineObjectInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetSuppress                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeLinesItem.SetSuppress (const Value: Boolean);
var
  valueInfo : PEValueInfo;
begin
  FSuppress := Value;
  if not StatusIsGo then Exit;

  {Get Suppress setting}
  
  if not Cr.FCrpeEngine.PEGetObjectFormat(Cr.FPrintJob, Handle, PE_OFN_VISIBLE, valueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Lines.SetSuppress <PEGetObjectFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if FSuppress = valueInfo.viBoolean then
  begin
    valueInfo.ValueType := PE_VI_BOOLEAN;
    if FSuppress = True then
      valueInfo.viBoolean := Bool(False)
    else
      valueInfo.viBoolean := Bool(True);
    {Send to Engine}
    
    if not Cr.FCrpeEngine.PESetObjectFormat(Cr.FPrintJob, Handle, PE_OFN_VISIBLE, valueInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Lines.SetSuppress <PESetObjectFormat>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ Class TCrpeLines                                                             }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeLines.Create;
begin
  inherited Create;
  FItem        := TCrpeLinesItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeLines.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeLines.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    Handle :=  0;
    FItem.Clear;
  end;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeLines.Count : integer;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  Result := Cr.GetNObjects(otLine, oftNone);
end;
{------------------------------------------------------------------------------}
{ StatusIsGo                                                                   }
{------------------------------------------------------------------------------}
function TCrpeLines.StatusIsGo: Boolean;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if (csLoading in Cr.ComponentState) then Exit;
  if FIndex < 0 then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;
  {Check Handle}
  if Handle = 0 then
    Handle := Cr.GetObjectHandle(FIndex, otLine, oftNone);
  if Handle = 0 then
  begin
    PropagateHandle(0);
    Exit;
  end;
  Result := True;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeLines.SetIndex (nIndex: integer);
var
  lineObjectInfo : PELineObjectInfo;
  valueInfo      : PEValueInfo;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    Clear;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;

  Handle := Cr.GetObjectHandle(nIndex, otLine, oftNone);
  if Handle = 0 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
      Cr.BuildErrorString(Self) + 'SetIndex(' + IntToStr(nIndex) +  ')') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  PropagateHandle(Handle);
  
  if not Cr.FCrpeEngine.PEGetLineObjectInfo(Cr.FPrintJob, Handle, lineObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetIndex(' + IntToStr(nIndex) +
        ') <PEGetLineObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Store values to VCL}
  PropagateIndex(nIndex);
  FItem.FSectionStart := Cr.SectionCodeToStringEx(lineObjectInfo.startSectionCode, False);
  FItem.FSectionEnd   := Cr.SectionCodeToStringEx(lineObjectInfo.endSectionCode, False);
  {LineStyle}
  FItem.FLineStyle := lsNone;
  if (lineObjectInfo.lineStyle >= Ord(Low(FItem.FLineStyle))) and
     (lineObjectInfo.lineStyle <= Ord(High(FItem.FLineStyle))) then
    FItem.FLineStyle := TCrLineStyle(lineObjectInfo.lineStyle);

  FItem.FLeft := lineObjectInfo.leftXOffset;
  FItem.FTop := lineObjectInfo.topYOffset;
  FItem.FWidth := lineObjectInfo.lineWidth;
  FItem.FRight := lineObjectInfo.rightXOffset;
  FItem.FBottom := lineObjectInfo.bottomYOffset;
  if lineObjectInfo.lineColor = PE_NO_COLOR then
    FItem.FColor := clNone
  else
    FItem.FColor := TColor(lineObjectInfo.lineColor);

  FItem.FExtend := False;
  if lineObjectInfo.expandToNextSection > 0 then
    FItem.FExtend := True;

  {Get Suppress setting}
  
  if not Cr.FCrpeEngine.PEGetObjectFormat(Cr.FPrintJob, Handle, PE_OFN_VISIBLE, valueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetIndex(' + IntToStr(nIndex) +
        ') <PEGetObjectFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FItem.FSuppress := False;
  if valueInfo.viBoolean = False then
    FItem.FSuppress := True;
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeLines.GetItem(nIndex: integer) : TCrpeLinesItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeBoxesItem                                                         }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeBoxesItem.Create;
begin
  inherited Create;
  FTop          := -1;
  FBottom       := -1;
  FLeft         := -1;
  FRight        := -1;
  FSectionStart := '';
  FSectionEnd   := '';
  FBorderStyle  := lsNone;
  FBorderWidth  := -1;
  FBorderColor  := clBlack;
  FDropShadow   := False;
  FFillColor    := clNone;
  FCloseBorder  := True;
  FExtend       := False;
  FSuppress     := False;
  FCornerRoundingHeight := -1;
  FCornerRoundingWidth  := -1;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeBoxesItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeBoxesItem then
  begin
    Top          := TCrpeBoxesItem(Source).Top;
    Bottom       := TCrpeBoxesItem(Source).Bottom;
    Left         := TCrpeBoxesItem(Source).Left;
    Right        := TCrpeBoxesItem(Source).Right;
    SectionStart := TCrpeBoxesItem(Source).SectionStart;
    SectionEnd   := TCrpeBoxesItem(Source).SectionEnd;
    BorderStyle  := TCrpeBoxesItem(Source).BorderStyle;
    BorderWidth  := TCrpeBoxesItem(Source).BorderWidth;
    BorderColor  := TCrpeBoxesItem(Source).BorderColor;
    DropShadow   := TCrpeBoxesItem(Source).DropShadow;
    FillColor    := TCrpeBoxesItem(Source).FillColor;
    CloseBorder  := TCrpeBoxesItem(Source).CloseBorder;
    Extend       := TCrpeBoxesItem(Source).Extend;
    Suppress     := TCrpeBoxesItem(Source).Suppress;
    CornerRoundingHeight := TCrpeBoxesItem(Source).CornerRoundingHeight;
    CornerRoundingWidth  := TCrpeBoxesItem(Source).CornerRoundingWidth;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeBoxesItem.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex        := -1;
    Handle        :=  0;
    FTop          := -1;
    FBottom       := -1;
    FLeft         := -1;
    FRight        := -1;
    FSectionStart := '';
    FSectionEnd   := '';
    FBorderStyle  := lsNone;
    FBorderWidth  := -1;
    FBorderColor  := clBlack;
    FDropShadow   := False;
    FFillColor    := clNone;
    FCloseBorder  := True;
    FExtend       := False;
    FSuppress     := False;
    FCornerRoundingHeight := -1;
    FCornerRoundingWidth  := -1;
  end;
end;
{------------------------------------------------------------------------------}
{ StatusIsGo                                                                   }
{------------------------------------------------------------------------------}
function TCrpeBoxesItem.StatusIsGo: Boolean;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if (csLoading in Cr.ComponentState) then Exit;
  if FIndex < 0 then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    Exit;
  end;
  if not Cr.OpenPrintJob then
    Exit;
  {Check Handle}
  if Handle = 0 then
    Handle := Cr.GetObjectHandle(FIndex, otLine, oftNone);
  if Handle = 0 then
  begin
    PropagateHandle(0);
    Exit;
  end;
  Result := True;
end;
{------------------------------------------------------------------------------}
{ SetSectionStart                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeBoxesItem.SetSectionStart (const Value: string);
var
  boxObjectInfo : PEBoxObjectInfo;
  SectionCode   : Smallint;
begin
  FSectionStart := Value;
  if not StatusIsGo then Exit;

  if not Cr.FCrpeEngine.PEGetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetSectionStart <PEGetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Convert Section String to Code}
  if not StrToSectionCode(FSectionStart, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetSectionStart(' + Value + ') <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  boxObjectInfo.topLeftSectionCode := SectionCode;
  {Send settings to Print Engine}
  if not Cr.FCrpeEngine.PESetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetSectionStart(' + Value + ') <PESetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetSectionEnd                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeBoxesItem.SetSectionEnd (const Value: string);
var
  boxObjectInfo : PEBoxObjectInfo;
  SectionCode   : Smallint;
begin
  FSectionEnd := Value;
  if not StatusIsGo then Exit;

  if not Cr.FCrpeEngine.PEGetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetSectionEnd(' + Value + ') <PEGetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {Convert Section String to Code}
  if not StrToSectionCode(FSectionEnd, SectionCode) then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SECTION_CODE,
        Cr.BuildErrorString(Self) + 'SetSectionEnd(' + Value + ') <StrToSectionCode>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  boxObjectInfo.bottomRightSectionCode := SectionCode;
  {Send settings to Print Engine}
  if not Cr.FCrpeEngine.PESetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetSectionEnd(' + Value + ') <PESetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetBorderStyle                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeBoxesItem.SetBorderStyle (const Value: TCrLineStyle);
var
  boxObjectInfo : PEBoxObjectInfo;
begin
  FBorderStyle := Value;
  if not StatusIsGo then Exit;

  if not Cr.FCrpeEngine.PEGetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetBorderStyle <PEGetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  boxObjectInfo.lineStyle := Ord(FBorderStyle);
  {Send settings to Print Engine}
  if not Cr.FCrpeEngine.PESetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetBorderStyle <PESetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetLeft                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeBoxesItem.SetLeft (const Value: LongInt);
var
  boxObjectInfo : PEBoxObjectInfo;
begin
  FLeft := Value;
  if not StatusIsGo then Exit;

  if not Cr.FCrpeEngine.PEGetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetLeft(' + IntToStr(Value) + ') <PEGetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  boxObjectInfo.leftXOffset := FLeft;
  {Send settings to Print Engine}
  if not Cr.FCrpeEngine.PESetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetLeft(' + IntToStr(Value) +
        ') <PESetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetTop                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeBoxesItem.SetTop (const Value: LongInt);
var
  boxObjectInfo : PEBoxObjectInfo;
begin
  FTop := Value;
  if not StatusIsGo then Exit;

  
  if not Cr.FCrpeEngine.PEGetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetTop(' + IntToStr(Value) + ') <PEGetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  boxObjectInfo.topYOffset := FTop;
  {Send settings to Print Engine}
  if not Cr.FCrpeEngine.PESetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetTop(' + IntToStr(Value) + ') <PESetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetBorderWidth                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeBoxesItem.SetBorderWidth (const Value: LongInt);
var
  boxObjectInfo : PEBoxObjectInfo;
begin
  FBorderWidth := Value;
  if not StatusIsGo then Exit;

  if not Cr.FCrpeEngine.PEGetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetBorderWidth(' + IntToStr(Value) + ') <PEGetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  boxObjectInfo.lineWidth := FBorderWidth;
  {Send settings to Print Engine}
  if not Cr.FCrpeEngine.PESetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetWidth(' + IntToStr(Value) + ') <PESetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetRight                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeBoxesItem.SetRight (const Value: LongInt);
var
  boxObjectInfo : PEBoxObjectInfo;
begin
  FRight := Value;
  if not StatusIsGo then Exit;

  if not Cr.FCrpeEngine.PEGetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetRight(' + IntToStr(Value) + ') <PEGetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  boxObjectInfo.rightXOffset := FRight;
  {Send settings to Print Engine}
  if not Cr.FCrpeEngine.PESetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetRight(' + IntToStr(Value) + ') <PESetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetBottom                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeBoxesItem.SetBottom (const Value: LongInt);
var
  boxObjectInfo : PEBoxObjectInfo;
begin
  FBottom := Value;
  if not StatusIsGo then Exit;

  if not Cr.FCrpeEngine.PEGetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetBottom(' + IntToStr(Value) + ') <PEGetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if boxObjectInfo.bottomYOffset <> FBottom then
  begin
    boxObjectInfo.bottomYOffset := FBottom;
    {Send settings to Print Engine}
    if not Cr.FCrpeEngine.PESetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetBottom(' + IntToStr(Value) + ') <PESetBoxObjectInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetBorderColor                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeBoxesItem.SetBorderColor (const Value: TColor);
var
  boxObjectInfo : PEBoxObjectInfo;
begin
  FBorderColor := Value;
  if not StatusIsGo then Exit;

  if not Cr.FCrpeEngine.PEGetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetBorderColor <PEGetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if FBorderColor = clNone then
    boxObjectInfo.lineColor := PE_NO_COLOR
  else
    boxObjectInfo.lineColor := ColorToRGB(FBorderColor);
  {Send settings to Print Engine}

  if not Cr.FCrpeEngine.PESetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetBorderColor <PESetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetFillColor                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeBoxesItem.SetFillColor (const Value: TColor);
var
  boxObjectInfo : PEBoxObjectInfo;
begin
  FFillColor := Value;
  if not StatusIsGo then Exit;

  if not Cr.FCrpeEngine.PEGetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetFillColor <PEGetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  if FFillColor = clNone then
    boxObjectInfo.fillColor := PE_NO_COLOR
  else
    boxObjectInfo.fillColor := ColorToRGB(FFillColor);
  {Send settings to Print Engine}
  if not Cr.FCrpeEngine.PESetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetFillColor <PESetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDropShadow                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeBoxesItem.SetDropShadow (const Value: Boolean);
var
  boxObjectInfo : PEBoxObjectInfo;
begin
  FDropShadow := Value;
  if not StatusIsGo then Exit;

  if not Cr.FCrpeEngine.PEGetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetDropShadow(' + BooleanToStr(Value) +
        ') <PEGetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  boxObjectInfo.dropShadow := Smallint(FDropShadow);
  {Send settings to Print Engine}
  if not Cr.FCrpeEngine.PESetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetDropShadow(' + BooleanToStr(Value) +
        ') <PESetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetCloseBorder                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeBoxesItem.SetCloseBorder (const Value: Boolean);
var
  boxObjectInfo : PEBoxObjectInfo;
begin
  FCloseBorder := Value;
  if not StatusIsGo then Exit;

  if not Cr.FCrpeEngine.PEGetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetCloseBorder(' + BooleanToStr(Value) +
        ') <PEGetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  boxObjectInfo.topBottomClose := Smallint(FCloseBorder);
  {Send settings to Print Engine}
  if not Cr.FCrpeEngine.PESetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetCloseBorder(' + BooleanToStr(Value) +
        ') <PESetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetCornerRoundingHeight                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeBoxesItem.SetCornerRoundingHeight (const Value: LongInt);
var
  boxObjectInfo : PEBoxObjectInfo;
begin
  FCornerRoundingHeight := Value;
  if not StatusIsGo then Exit;

  if not Cr.FCrpeEngine.PEGetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetCornerRoundingHeight(' +
        IntToStr(Value) + ') <PEGetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  boxObjectInfo.CornerEllipseHeight := FCornerRoundingHeight;
  {Send settings to Print Engine}
  if not Cr.FCrpeEngine.PESetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetCornerRoundingHeight(' +
        IntToStr(Value) + ') <PESetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetCornerRoundingWidth                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeBoxesItem.SetCornerRoundingWidth (const Value: LongInt);
var
  boxObjectInfo : PEBoxObjectInfo;
begin
  FCornerRoundingWidth := Value;
  if not StatusIsGo then Exit;

  if not Cr.FCrpeEngine.PEGetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetCornerRoundingWidth(' +
        IntToStr(Value) + ') <PEGetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  boxObjectInfo.CornerEllipseWidth := FCornerRoundingWidth;
  {Send settings to Print Engine}
  if not Cr.FCrpeEngine.PESetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetCornerRoundingWidth(' +
        IntToStr(Value) + ') <PESetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetExtend                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeBoxesItem.SetExtend (const Value: Boolean);
var
  boxObjectInfo : PEBoxObjectInfo;
begin
  FExtend := Value;
  if not StatusIsGo then Exit;

  if not Cr.FCrpeEngine.PEGetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetExtend(' +
        BooleanToStr(Value) + ') <PEGetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  boxObjectInfo.expandToNextSection := Smallint(FExtend);
  {Send settings to Print Engine}
  if not Cr.FCrpeEngine.PESetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetExtend(' +
        BooleanToStr(Value) + ') <PESetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetSuppress                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeBoxesItem.SetSuppress (const Value: Boolean);
var
  valueInfo : PEValueInfo;
begin
  FSuppress := Value;
  if not StatusIsGo then Exit;

  valueInfo.ValueType := PE_VI_BOOLEAN;
  if FSuppress = True then
    valueInfo.viBoolean := Bool(False)
  else
    valueInfo.viBoolean := Bool(True);

  if not Cr.FCrpeEngine.PESetObjectFormat(Cr.FPrintJob, Handle, PE_OFN_VISIBLE, valueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetSuppress(' +
        BooleanToStr(Value) + ') <PESetObjectFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
end;


{******************************************************************************}
{ Class TCrpeBoxes                                                             }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeBoxes.Create;
begin
  inherited Create;
  FItem := TCrpeBoxesItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destroy                                                                      }
{------------------------------------------------------------------------------}
destructor TCrpeBoxes.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeBoxes.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    Handle :=  0;
    FItem.Clear;
  end;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeBoxes.Count : integer;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;
  Result := Cr.GetNObjects(otBox, oftNone);
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeBoxes.SetIndex (nIndex: integer);
var
  boxObjectInfo : PEboxObjectInfo;
  valueInfo     : PEValueInfo;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    Clear;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;

  Handle := Cr.GetObjectHandle(nIndex, otBox, oftNone);
  if Handle = 0 then
  begin
    case Cr.GetErrorMsg(0,errNoOption,errVCL,ECRPE_SUBSCRIPT,
      Cr.BuildErrorString(Self)) of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  
  if not Cr.FCrpeEngine.PEGetBoxObjectInfo(Cr.FPrintJob, Handle, boxObjectInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Boxes.SetIndex <PEGetBoxObjectInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateHandle(Handle);
  PropagateIndex(nIndex);
  FItem.FSectionStart := Cr.SectionCodeToStringEx(boxObjectInfo.topLeftSectionCode, False);
  FItem.FSectionEnd   := Cr.SectionCodeToStringEx(boxObjectInfo.bottomRightSectionCode, False);

  FItem.FTop := boxObjectInfo.topYOffset;
  FItem.FBottom := boxObjectInfo.bottomYOffset;
  FItem.FLeft := boxObjectInfo.leftXOffset;
  FItem.FRight := boxObjectInfo.rightXOffset;

  FItem.FBorderStyle := lsNone;
  if (boxObjectInfo.lineStyle >= Ord(Low(FItem.FBorderStyle))) and
     (boxObjectInfo.lineStyle <= Ord(High(FItem.FBorderStyle))) then
    FItem.FBorderStyle := TCrLineStyle(boxObjectInfo.lineStyle);
  FItem.FBorderWidth := boxObjectInfo.lineWidth;
  if boxObjectInfo.lineColor = PE_NO_COLOR then
    FItem.FBorderColor := clNone
  else
    FItem.FBorderColor := TColor(boxObjectInfo.lineColor);

  FItem.FDropShadow := False;
  if boxObjectInfo.dropShadow > 0 then
    FItem.FDropShadow := True;

  if boxObjectInfo.fillColor = PE_NO_COLOR then
    FItem.FFillColor := clNone
  else
    FItem.FFillColor := TColor(boxObjectInfo.fillColor);

  if boxObjectInfo.topBottomClose < 1 then
    FItem.FCloseBorder := False
  else
    FItem.FCloseBorder := True;

  if boxObjectInfo.expandToNextSection > 0 then
    FItem.FExtend := True
  else
    FItem.FExtend := False;

  FItem.FCornerRoundingHeight := boxObjectInfo.CornerEllipseHeight;
  FItem.FCornerRoundingWidth := boxObjectInfo.CornerEllipseWidth;

  
  if not Cr.FCrpeEngine.PEGetObjectFormat(Cr.FPrintJob, Handle, PE_OFN_VISIBLE, valueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' + IntToStr(nIndex) +
        ') <PEGetObjectFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FItem.FSuppress := False;
  if valueInfo.viBoolean = False then
    FItem.FSuppress := True;
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeBoxes.GetItem(nIndex: integer) : TCrpeBoxesItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeOleObjectsItem                                                    }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeOleObjectsItem.Create;
begin
  inherited Create;
  {Ole specific}
  FOleType           := ootStatic;
  FUpdateType        := AutoUpdate;
  FLinkSource        := '';
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeOleObjectsItem.Clear;
begin
  inherited Clear;
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) or (Handle = 0) then
  begin
    FIndex      := -1;
    Handle      :=  0;
    FOleType    := ootStatic;
    FUpdateType := AutoUpdate;
    FLinkSource := '';
  end;
end;
{------------------------------------------------------------------------------}
{ SetOleType                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeOleObjectsItem.SetOleType (const Value: TCrOleObjectType);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetUpdateType                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeOleObjectsItem.SetUpdateType (const Value: TCrOleUpdateType);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetLinkSource                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeOleObjectsItem.SetLinkSource (const Value: string);
begin
  {Read only}
end;


{******************************************************************************}
{ Class TCrpeOleObjects                                                        }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeOleObjects.Create;
begin
  inherited Create;
  {Set inherited ObjectInfo properties}
  FObjectType      := otOle;
  FFieldObjectType := oftNone;
  FItem        := TCrpeOleObjectsItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeOleObjects.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeOleObjects.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) or (Handle = 0) then
  begin
    FIndex := -1;
    Handle :=  0;
    FItem.Clear;
  end;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeOleObjects.SetIndex (nIndex: integer);
var
  OleObjectInfo : PEOleObjectInfo;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    Clear;
    Exit;
  end;
  inherited SetIndex(nIndex);
  if Handle = 0 then Exit;
  if not Cr.OpenPrintJob then Exit;

  PropagateHandle(Handle);
  {other Ole object specific values...}
  if not Cr.FCrpeEngine.PEGetOleObjectInfo(Cr.FPrintJob, Handle, OleObjectInfo) then
  begin
  end;
  case OleObjectInfo.oleObjectType of
    PE_OOI_LINKEDOBJECT   : Item.FOleType := ootLinked;
    PE_OOI_EMBEDDEDOBJECT : Item.FOleType := ootEmbedded;
    PE_OOI_STATICOBJECT   : Item.FOleType := ootStatic;
  end;
  case OleObjectInfo.updateType of
    PE_OOI_AUTOUPDATE   : Item.FUpdateType := AutoUpdate;
    PE_OOI_MANUALUPDATE : Item.FUpdateType := ManualUpdate;
  end;
  Item.FLinkSource := String(OleObjectInfo.linkSource);
end;
{------------------------------------------------------------------------------}
{ GetItems                                                                     }
{------------------------------------------------------------------------------}
function TCrpeOleObjects.GetItems(nIndex: integer) : TCrpeOleObjectsItem;
begin
  SetIndex(nIndex);
  Result := TCrpeOleObjectsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeOleObjects.GetItem : TCrpeOleObjectsItem;
begin
  Result := TCrpeOleObjectsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ SetItem                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeOleObjects.SetItem (const nItem: TCrpeOleObjectsItem);
begin
  FItem.Assign(nItem);
end;


{******************************************************************************}
{ Class TCrpeCrossTabSummariesItem                                             }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeCrossTabSummariesItem.Create;
begin
  inherited Create;
  FSummarizedField  := '';
  FFieldType        := fvUnknown;
  FFieldLength      := 0;
  {SummaryType properties}
  FSummaryType      := stCount;
  FSummaryTypeN     := -1; {Only applies to certain SummaryTypes, ie. stPercentage}
  FSummaryTypeField := ''; {Only applies to certain SummaryTypes, ie. stCorrelation}
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabSummariesItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeCrossTabSummariesItem then
  begin
    SummarizedField  := TCrpeCrossTabSummariesItem(Source).SummarizedField;
    FieldType        := TCrpeCrossTabSummariesItem(Source).FieldType;
    FieldLength      := TCrpeCrossTabSummariesItem(Source).FieldLength;
    SummaryType      := TCrpeCrossTabSummariesItem(Source).SummaryType;
    SummaryTypeN     := TCrpeCrossTabSummariesItem(Source).SummaryTypeN;
    SummaryTypeField := TCrpeCrossTabSummariesItem(Source).SummaryTypeField;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabSummariesItem.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex            := -1;
    Handle            :=  0;
    FSummarizedField  := '';
    FFieldType        := fvUnknown;
    FFieldLength      := 0;
    {SummaryType properties}
    FSummaryType      := stCount;
    FSummaryTypeN     := -1; {Only applies to certain SummaryTypes, ie. stPercentage}
    FSummaryTypeField := ''; {Only applies to certain SummaryTypes, ie. stCorrelation}
  end;
end;
{------------------------------------------------------------------------------}
{ StatusIsGo                                                                   }
{------------------------------------------------------------------------------}
function TCrpeCrossTabSummariesItem.StatusIsGo (nIndex: integer) : Boolean;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if (csLoading in Cr.ComponentState) then Exit;
  if nIndex < 0 then
  begin
    FIndex := -1;
    Handle := 0;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;
  {Check Handle}
  if Handle = 0 then
    Handle := Cr.GetObjectHandle(FIndex, otCrossTab, oftNone);
  if Handle = 0 then
  begin
    Handle := 0;
    Exit;
  end;
  Result := True;
end;
{------------------------------------------------------------------------------}
{ SetSummarizedField                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabSummariesItem.SetSummarizedField(const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetFieldType                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabSummariesItem.SetFieldType(const Value: TCrFieldValueType);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetFieldLength                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabSummariesItem.SetFieldLength(const Value: Word);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetSummaryType                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabSummariesItem.SetSummaryType(const Value: TCrSummaryType);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetSummaryTypeN                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabSummariesItem.SetSummaryTypeN(const Value: Smallint);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetSummaryTypeField                                                          }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabSummariesItem.SetSummaryTypeField(const Value: string);
begin
  {Read only}
end;


{******************************************************************************}
{ Class TCrpeCrossTabSummaries                                                 }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeCrossTabSummaries.Create;
begin
  inherited Create;
  FItem := TCrpeCrossTabSummariesItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeCrossTabSummaries.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabSummaries.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    Handle :=  0;
    FItem.Clear;
  end;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeCrossTabSummaries.Count : integer;
var
  nSummaries : Smallint;
begin
  Result := 0;
  if Handle = 0 then Exit;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get number of Summaries}
  
  nSummaries := Cr.FCrpeEngine.PEGetNSummariesInCrossTabObject(Cr.FPrintJob, Handle);
  if nSummaries = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'Count <PEGetNSummariesInCrossTabObject>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := nSummaries;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabSummaries.SetIndex (nIndex: integer);
var
  summaryInfo : PECrossTabSummaryFieldInfo;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Clear;
    Exit;
  end;
  if Handle = 0 then Exit;
  if not Cr.OpenPrintJob then Exit;

  
  if not Cr.FCrpeEngine.PEGetNthSummaryInfoInCrossTabObject(Cr.FPrintJob,
    Handle, nIndex, summaryInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetNthSummaryInfoInCrossTabObject>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);
  FItem.FSummarizedField := String(summaryInfo.summarizedFieldName);
  if summaryInfo.valueType = PE_FVT_UNKNOWNFIELD then
    FItem.FFieldType := fvUnknown
  else
    FItem.FFieldType := TCrFieldValueType(summaryInfo.valueType);
  FItem.FFieldLength := summaryInfo.nBytes;
  {SummaryType properties}
  FItem.FSummaryType := TCrSummaryType(summaryInfo.summaryType);
  FItem.FSummaryTypeN := summaryInfo.summaryParameter;
  FItem.FSummaryTypeField := String(summaryInfo.secondSummarizedFieldName);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeCrossTabSummaries.GetItem(nIndex: integer) : TCrpeCrossTabSummariesItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeCrossTabGroupsItem                                                }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeCrossTabGroupsItem.Create;
begin
  inherited Create;
  FRowCol           := gpRow;
  FCondition        := AnyChange;
  FDirection        := gdAscending;
  FFieldName        := '';
  FBackgroundColor  := clNone;
  FSuppressSubtotal := False;
  FSuppressLabel    := False;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabGroupsItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeCrossTabGroupsItem then
  begin
    Condition        := TCrpeCrossTabGroupsItem(Source).Condition;
    Direction        := TCrpeCrossTabGroupsItem(Source).Direction;
    FieldName        := TCrpeCrossTabGroupsItem(Source).FieldName;
    BackgroundColor  := TCrpeCrossTabGroupsItem(Source).BackgroundColor;
    SuppressSubtotal := TCrpeCrossTabGroupsItem(Source).SuppressSubtotal;
    SuppressLabel    := TCrpeCrossTabGroupsItem(Source).SuppressLabel;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabGroupsItem.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex            := -1;
    Handle            :=  0;
    FCondition        := AnyChange;
    FDirection        := gdAscending;
    FFieldName        := '';
    FBackgroundColor  := clNone;
    FSuppressSubtotal := False;
    FSuppressLabel    := False;
  end;
end;
{------------------------------------------------------------------------------}
{ StatusIsGo                                                                   }
{------------------------------------------------------------------------------}
function TCrpeCrossTabGroupsItem.StatusIsGo (nIndex: integer) : Boolean;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    FIndex := -1;
    Handle := 0;
    Exit;
  end;
  if not Cr.OpenPrintJob then Exit;
  {Check Handle}
  if Handle = 0 then
    Handle := Cr.GetObjectHandle(FIndex, otCrossTab, oftNone);
  if Handle = 0 then
  begin
    Handle := 0;
    Exit;
  end;
  Result := True;
end;
{------------------------------------------------------------------------------}
{ SetFieldName                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabGroupsItem.SetFieldName(const Value: string);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetCondition                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabGroupsItem.SetCondition(const Value: TCrGroupCondition);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetDirection                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabGroupsItem.SetDirection(const Value: TCrGroupDirection);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetBackgroundColor                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabGroupsItem.SetBackgroundColor(const Value: TColor);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetSuppressSubtotal                                                          }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabGroupsItem.SetSuppressSubtotal(const Value: Boolean);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetSuppressLabel                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabGroupsItem.SetSuppressLabel(const Value: Boolean);
begin
  {Read only}
end;


{******************************************************************************}
{ Class TCrpeCrossTabGroups                                                    }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeCrossTabGroups.Create;
begin
  inherited Create;
  FItem := TCrpeCrossTabGroupsItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeCrossTabGroups.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabGroups.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    Handle :=  0;
    FItem.Clear;
  end;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeCrossTabGroups.Count : integer;
var
  nGroups : Smallint;
begin
  Result := 0;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  {Get number of Summaries}
  
  nGroups := Cr.FCrpeEngine.PEGetNGroupsInCrossTabObject(Cr.FPrintJob, Handle,
    Ord(FItem.FRowCol));
  if nGroups = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'Count <PEGetNGroupsInCrossTabObject>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {The Print Engine can't handle more than 25 groups!}
  if nGroups > 25 then
    nGroups := 25;
  Result := nGroups;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabGroups.SetIndex (nIndex: integer);
var
  GroupOptions : PECrossTabGroupOptions;
  int1, int2   : Smallint;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    Handle := 0;
    Clear;
    Exit;
  end;
  if Handle = 0 then Exit;
  if not Cr.OpenPrintJob then Exit;

  PropagateHandle(Handle);
  
  if not Cr.FCrpeEngine.PEGetNthCrossTabGroupOptions(Cr.FPrintJob, Handle,
    Ord(FItem.FRowCol), nIndex, GroupOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetNthCrossTabGroupOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
       errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);

  {Condition with Type Mask; This obtains the Type of
   Group Condition Field from the Condition variable}
  int1 := GroupOptions.condition and PE_GC_TYPEMASK;  //$0F00
  case int1 of
    {"Others" have no conditions}
    PE_GC_TYPEOTHER : FItem.FCondition := AnyChange;
    PE_GC_TYPEDATE  : //$0200;
    begin
      {Condition with Condition Mask; This obtains the
       condition of the group from the Condition variable}
      int2 := GroupOptions.condition and PE_GC_CONDITIONMASK;  //$00FF
      case int2 of
        PE_GC_DAILY        : FItem.FCondition := dateDaily;
        PE_GC_WEEKLY       : FItem.FCondition := dateWeekly;
        PE_GC_BIWEEKLY     : FItem.FCondition := dateBiWeekly;
        PE_GC_SEMIMONTHLY  : FItem.FCondition := dateSemiMonthly;
        PE_GC_MONTHLY      : FItem.FCondition := dateMonthly;
        PE_GC_QUARTERLY    : FItem.FCondition := dateQuarterly;
        PE_GC_SEMIANNUALLY : FItem.FCondition := dateSemiAnnually;
        PE_GC_ANNUALLY     : FItem.FCondition := dateAnnually;
        else
          FItem.FCondition := AnyChange;
      end;
    end;
    PE_GC_TYPEBOOLEAN:  //$0400:
    begin
      int2 := GroupOptions.condition and PE_GC_CONDITIONMASK;  //$00FF
      case int2 of
        PE_GC_TOYES     : FItem.FCondition := boolToYes;
        PE_GC_TONO      : FItem.FCondition := boolToNo;
        PE_GC_EVERYYES  : FItem.FCondition := boolEveryYes;
        PE_GC_EVERYNO   : FItem.FCondition := boolEveryNo;
        PE_GC_NEXTISYES : FItem.FCondition := boolNextIsYes;
        PE_GC_NEXTISNO  : FItem.FCondition := boolNextIsNo;
        else
          FItem.FCondition := AnyChange;
      end;
    end;
    PE_GC_TYPETIME:  //$0800:
    begin
      int2 := GroupOptions.condition and PE_GC_CONDITIONMASK;  //$00FF
      case int2 of
        PE_GC_BYSECOND : FItem.FCondition := timeBySecond;
        PE_GC_BYMINUTE : FItem.FCondition := timeByMinute;
        PE_GC_BYHOUR   : FItem.FCondition := timeByHour;
        PE_GC_BYAMPM   : FItem.FCondition := timeByAMPM;
        else
          FItem.FCondition := AnyChange;
      end;
    end;
    {DateTime type added for CR 9.x}
    PE_GC_TYPEDATETIME :  // $A00
    begin
      int2 := GroupOptions.condition and PE_GC_CONDITIONMASK;  //$00FF
      case int2 of
        PE_GC_DAILY        : FItem.FCondition := dateDaily;
        PE_GC_WEEKLY       : FItem.FCondition := dateWeekly;
        PE_GC_BIWEEKLY     : FItem.FCondition := dateBiWeekly;
        PE_GC_SEMIMONTHLY  : FItem.FCondition := dateSemiMonthly;
        PE_GC_MONTHLY      : FItem.FCondition := dateMonthly;
        PE_GC_QUARTERLY    : FItem.FCondition := dateQuarterly;
        PE_GC_SEMIANNUALLY : FItem.FCondition := dateSemiAnnually;
        PE_GC_ANNUALLY     : FItem.FCondition := dateAnnually;
        {Time }
        PE_GC_BYSECOND     : FItem.FCondition := timeBySecond;
        PE_GC_BYMINUTE     : FItem.FCondition := timeByMinute;
        PE_GC_BYHOUR       : FItem.FCondition := timeByHour;
        PE_GC_BYAMPM       : FItem.FCondition := timeByAMPM;
        else
          FItem.FCondition := AnyChange;
      end;
    end;
  end;
  {Direction}
  if GroupOptions.sortDirection in [0..4] then
    FItem.FDirection := TCrGroupDirection(GroupOptions.sortDirection);
  {BackgroundColor}
  if GroupOptions.backColor = PE_NO_COLOR then
    FItem.FBackgroundColor := clNone
  else
    FItem.FBackgroundColor := TColor(GroupOptions.backColor);
  {FieldName}
  FItem.FFieldName := String(GroupOptions.fieldName);
  {SuppressSubtotal}
  if GroupOptions.suppressSubtotal < 1 then
    FItem.FSuppressSubtotal := False
  else
    FItem.FSuppressSubtotal := True;
  {SuppressLabel}
  if GroupOptions.suppressLabel < 1 then
    FItem.FSuppressLabel := False
  else
    FItem.FSuppressLabel := True;
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeCrossTabGroups.GetItem(nIndex: integer) : TCrpeCrossTabGroupsItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeCrossTabsItem                                                     }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeCrossTabsItem.Create;
begin
  inherited Create;
  {CrossTab specific properties}
  FShowCellMargins            := True;
  FSuppressEmptyRows          := False;
  FSuppressEmptyColumns       := False;
  FKeepColumnsTogether        := True;
  FRepeatRowLabels            := False;
  FSuppressRowGrandTotals     := False;
  FSuppressColumnGrandTotals  := False;
  FColorRowGrandTotals        := clNone;
  FColorColumnGrandTotals     := clNone;
  FShowGridLines              := True;
  FSummaries                  := TCrpeCrossTabSummaries.Create;
  FRowGroups                  := TCrpeCrossTabGroups.Create;
  FRowGroups.FItem.FRowCol    := gpRow;
  FColumnGroups               := TCrpeCrossTabGroups.Create;
  FColumnGroups.FItem.FRowCol := gpCol;
  FSubClassList.Add(FSummaries);
  FSubClassList.Add(FRowGroups);
  FSubClassList.Add(FColumnGroups);
end;
{------------------------------------------------------------------------------}
{ Destroy                                                                      }
{------------------------------------------------------------------------------}
destructor TCrpeCrossTabsItem.Destroy;
begin
  FSummaries.Free;
  FRowGroups.Free;
  FColumnGroups.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabsItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeCrossTabsItem then
  begin
    ShowCellMargins           := TCrpeCrossTabsItem(Source).ShowCellMargins;
    SuppressEmptyRows         := TCrpeCrossTabsItem(Source).SuppressEmptyRows;
    SuppressEmptyColumns      := TCrpeCrossTabsItem(Source).SuppressEmptyColumns;
    KeepColumnsTogether       := TCrpeCrossTabsItem(Source).KeepColumnsTogether;
    RepeatRowLabels           := TCrpeCrossTabsItem(Source).RepeatRowLabels;
    SuppressRowGrandTotals    := TCrpeCrossTabsItem(Source).SuppressRowGrandTotals;
    SuppressColumnGrandTotals := TCrpeCrossTabsItem(Source).SuppressColumnGrandTotals;
    ColorRowGrandTotals       := TCrpeCrossTabsItem(Source).ColorRowGrandTotals;
    ColorColumnGrandTotals    := TCrpeCrossTabsItem(Source).ColorColumnGrandTotals;
    ShowGridLines             := TCrpeCrossTabsItem(Source).ShowGridLines;
    Summaries.Assign(TCrpeCrossTabsItem(Source).Summaries);
    RowGroups.Assign(TCrpeCrossTabsItem(Source).RowGroups);
    ColumnGroups.Assign(TCrpeCrossTabsItem(Source).ColumnGroups);
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabsItem.Clear;
begin
  inherited Clear;
  FSummaries.Clear;
  FRowGroups.Clear;
  FColumnGroups.Clear;
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) or (Handle = 0) then
  begin
    FIndex                     := -1;
    Handle                     :=  0;
    FShowCellMargins           := True;
    FSuppressEmptyRows         := False;
    FSuppressEmptyColumns      := False;
    FKeepColumnsTogether       := True;
    FRepeatRowLabels           := False;
    FSuppressRowGrandTotals    := False;
    FSuppressColumnGrandTotals := False;
    FColorRowGrandTotals       := clNone;
    FColorColumnGrandTotals    := clNone;
    FShowGridLines                  := True;
  end;
end;
{------------------------------------------------------------------------------}
{ SetShowCellMargins                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabsItem.SetShowCellMargins (const Value: Boolean);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetSuppressEmptyRows                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabsItem.SetSuppressEmptyRows (const Value: Boolean);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetSuppressEmptyColumns                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabsItem.SetSuppressEmptyColumns (const Value: Boolean);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetKeepColumnsTogether                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabsItem.SetKeepColumnsTogether (const Value: Boolean);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetRepeatRowLabels                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabsItem.SetRepeatRowLabels (const Value: Boolean);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetSuppressRowGrandTotals                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabsItem.SetSuppressRowGrandTotals (const Value: Boolean);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetSuppressColumnGrandTotals                                                 }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabsItem.SetSuppressColumnGrandTotals (const Value: Boolean);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetColorRowGrandTotals                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabsItem.SetColorRowGrandTotals (const Value: TColor);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetColorColumnGrandTotals                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabsItem.SetColorColumnGrandTotals (const Value: TColor);
begin
  {Read only}
end;
{------------------------------------------------------------------------------}
{ SetShowGridLines                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabsItem.SetShowGridLines (const Value: Boolean);
begin
  {Read only}
end;


{******************************************************************************}
{ Class TCrpeCrossTabs                                                         }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeCrossTabs.Create;
begin
  inherited Create;
  {Set inherited ObjectInfo properties}
  FObjectType := otCrossTab;
  FFieldObjectType := oftNone;
  FItem := TCrpeCrossTabsItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destroy                                                                      }
{------------------------------------------------------------------------------}
destructor TCrpeCrossTabs.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabs.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) or (Handle = 0) then
  begin
    FIndex := -1;
    Handle :=  0;
    FItem.Clear;
  end;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabs.SetIndex (nIndex: integer);
var
  CrossTabOptions : PECrossTabOptions;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    Clear;
    Exit;
  end;
  inherited SetIndex(nIndex);
  PropagateHandle(Handle);
  if Handle = 0 then Exit;
  if not Cr.OpenPrintJob then Exit;

  
  if not Cr.FCrpeEngine.PEGetCrossTabOptions(Cr.FPrintJob, Handle, CrossTabOptions) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'CrossTabs.SetIndex(' + IntToStr(nIndex) + ') <PEGetCrossTabOptions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);
  Item.FRowGroups.FIndex := nIndex;
  Item.FColumnGroups.FIndex := nIndex;
  Item.FSummaries.FIndex := nIndex;
  if CrossTabOptions.showCellMargins > 0 then
    Item.FShowCellMargins := True
  else
    Item.FShowCellMargins := False;
  if CrossTabOptions.suppressEmptyRows < 1 then
    Item.FSuppressEmptyRows := False
  else
    Item.FSuppressEmptyRows := True;
  if CrossTabOptions.suppressEmptyCols < 1 then
    Item.FSuppressEmptyColumns := False
  else
    Item.FSuppressEmptyColumns := True;
  if CrossTabOptions.keepColsTogether > 0 then
    Item.FKeepColumnsTogether := True
  else
    Item.FKeepColumnsTogether := False;
  if CrossTabOptions.repeatRowLabels < 1 then
    Item.FRepeatRowLabels := False
  else
    Item.FRepeatRowLabels := True;
  if CrossTabOptions.suppressRowGrandTotals < 1 then
    Item.FSuppressRowGrandTotals := False
  else
    Item.FSuppressRowGrandTotals := True;
  if CrossTabOptions.suppressColGrandTotals < 1 then
    Item.FSuppressColumnGrandTotals := False
  else
    Item.FSuppressColumnGrandTotals := True;
  if CrossTabOptions.colorRowGrandTotals = PE_NO_COLOR then
    Item.FColorRowGrandTotals := clNone
  else
    Item.FColorRowGrandTotals := TColor(CrossTabOptions.colorRowGrandTotals);
  if CrossTabOptions.colorColGrandTotals = PE_NO_COLOR then
    Item.FColorColumnGrandTotals := clNone
  else
    Item.FColorColumnGrandTotals := TColor(CrossTabOptions.colorColGrandTotals);
  if CrossTabOptions.showGrid > 0 then
    Item.FShowGridLines := True
  else
    Item.FShowGridLines := False;
end;
{------------------------------------------------------------------------------}
{ GetItems                                                                     }
{------------------------------------------------------------------------------}
function TCrpeCrossTabs.GetItems(nIndex: integer) : TCrpeCrossTabsItem;
begin
  SetIndex(nIndex);
  Result := TCrpeCrossTabsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeCrossTabs.GetItem : TCrpeCrossTabsItem;
begin
  Result := TCrpeCrossTabsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ SetItem                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeCrossTabs.SetItem (const nItem: TCrpeCrossTabsItem);
begin
  FItem.Assign(nItem);
end;


{******************************************************************************}
{ Class TCrpePicturesItem                                                      }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpePicturesItem.Create;
begin
  inherited Create;
  FCropLeft      := -1;
  FCropRight     := -1;
  FCropTop       := -1;
  FCropBottom    := -1;
  FScalingWidth  := 0;
  FScalingHeight := 0;
  FCanGrow       := False;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpePicturesItem.Assign(Source: TPersistent);
begin
  if Source is TCrpePicturesItem then
  begin
    CropLeft      := TCrpePicturesItem(Source).CropLeft;
    CropRight     := TCrpePicturesItem(Source).CropRight;
    CropTop       := TCrpePicturesItem(Source).CropTop;
    CropBottom    := TCrpePicturesItem(Source).CropBottom;
    ScalingWidth  := TCrpePicturesItem(Source).ScalingWidth;
    ScalingHeight := TCrpePicturesItem(Source).ScalingHeight;
    CanGrow       := TCrpePicturesItem(Source).CanGrow;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpePicturesItem.Clear;
begin
  inherited Clear;
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex         := -1;
    Handle         :=  0;
    FCropLeft      := -1;
    FCropRight     := -1;
    FCropTop       := -1;
    FCropBottom    := -1;
    FScalingWidth  := 0;
    FScalingHeight := 0;
    FCanGrow       := False;
  end;
end;
{------------------------------------------------------------------------------}
{ SetCropLeft                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpePicturesItem.SetCropLeft (const Value: LongInt);
var
  pictureFormatInfo : PEPictureFormatInfo;
begin
  FCropLeft := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetPictureFormatInfo(Cr.FPrintJob, Handle, pictureFormatInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Pictures.SetCropLeft <PEGetPictureFormatInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {PictureFormat Info}
  if pictureFormatInfo.leftCropping <> FCropLeft then
  begin
    pictureFormatInfo.leftCropping := FCropLeft;
    {Send to Print Engine}
    
    if not Cr.FCrpeEngine.PESetPictureFormatInfo(Cr.FPrintJob, Handle, pictureFormatInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Pictures.SetCropLeft <PESetPictureFormatInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetCropRight                                                                 }
{------------------------------------------------------------------------------}
procedure TCrpePicturesItem.SetCropRight (const Value: LongInt);
var
  pictureFormatInfo : PEPictureFormatInfo;
begin
  FCropRight := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetPictureFormatInfo(Cr.FPrintJob, Handle, pictureFormatInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Pictures.SetCropRight <PEGetPictureFormatInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {PictureFormat Info}
  if pictureFormatInfo.rightCropping <> FCropRight then
  begin
    pictureFormatInfo.rightCropping := FCropRight;
    {Send to Print Engine}
    
    if not Cr.FCrpeEngine.PESetPictureFormatInfo(Cr.FPrintJob, Handle, pictureFormatInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Pictures.SetCropRight <PESetPictureFormatInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetCropTop                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpePicturesItem.SetCropTop (const Value: LongInt);
var
  pictureFormatInfo : PEPictureFormatInfo;
begin
  FCropTop := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetPictureFormatInfo(Cr.FPrintJob, Handle, pictureFormatInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Pictures.SetCropTop <PEGetPictureFormatInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {PictureFormat Info}
  if pictureFormatInfo.topCropping <> FCropTop then
  begin
    pictureFormatInfo.topCropping := FCropTop;
    {Send to Print Engine}
    
    if not Cr.FCrpeEngine.PESetPictureFormatInfo(Cr.FPrintJob, Handle, pictureFormatInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Pictures.SetCropTop <PESetPictureFormatInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetCropBottom                                                                }
{------------------------------------------------------------------------------}
procedure TCrpePicturesItem.SetCropBottom (const Value: LongInt);
var
  pictureFormatInfo : PEPictureFormatInfo;
begin
  FCropBottom := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetPictureFormatInfo(Cr.FPrintJob, Handle, pictureFormatInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Pictures.SetCropBottom <PEGetPictureFormatInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {PictureFormat Info}
  if pictureFormatInfo.bottomCropping <> FCropBottom then
  begin
    pictureFormatInfo.bottomCropping := FCropBottom;
    {Send to Print Engine}
    
    if not Cr.FCrpeEngine.PESetPictureFormatInfo(Cr.FPrintJob, Handle, pictureFormatInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Pictures.SetCropBottom <PESetPictureFormatInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetScalingWidth                                                              }
{------------------------------------------------------------------------------}
procedure TCrpePicturesItem.SetScalingWidth (const Value: Double);
var
  pictureFormatInfo : PEPictureFormatInfo;
begin
  FScalingWidth := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetPictureFormatInfo(Cr.FPrintJob, Handle, pictureFormatInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Pictures.SetScalingWidth <PEGetPictureFormatInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {PictureFormat Info}
  if pictureFormatInfo.xScaling <> (FScalingWidth / 100) then
  begin
    pictureFormatInfo.xScaling := (FScalingWidth / 100);
    {Send to Print Engine}
    
    if not Cr.FCrpeEngine.PESetPictureFormatInfo(Cr.FPrintJob, Handle, pictureFormatInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Pictures.SetScalingWidth <PESetPictureFormatInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetScalingHeight                                                             }
{------------------------------------------------------------------------------}
procedure TCrpePicturesItem.SetScalingHeight (const Value: Double);
var
  pictureFormatInfo : PEPictureFormatInfo;
begin
  FScalingHeight := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetPictureFormatInfo(Cr.FPrintJob, Handle, pictureFormatInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Pictures.SetScalingHeight <PEGetPictureFormatInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;

  {PictureFormat Info}
  if pictureFormatInfo.yScaling <> (FScalingHeight / 100) then
  begin
    pictureFormatInfo.yScaling := (FScalingHeight / 100);
    {Send to Print Engine}
    
    if not Cr.FCrpeEngine.PESetPictureFormatInfo(Cr.FPrintJob, Handle, pictureFormatInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          'Pictures.SetScalingHeight <PESetPictureFormatInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ GetCanGrow                                                                   }
{------------------------------------------------------------------------------}
function TCrpePicturesItem.GetCanGrow : Boolean;
var
  valueInfo : PEValueInfo;
begin
  Result := FCanGrow;
  if not StatusIsGo(FIndex) then Exit;
  {CanGrow}
  
  if not Cr.FCrpeEngine.PEGetObjectFormat(Cr.FPrintJob, Handle, PE_OFN_EXPAND, valueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'GetCanGrow <PEGetObjectFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FCanGrow := True;
  if valueInfo.viBoolean = False then
    FCanGrow := False;
  Result := FCanGrow;
end;
{------------------------------------------------------------------------------}
{ SetCanGrow                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpePicturesItem.SetCanGrow (const Value: Boolean);
var
  valueInfo : PEValueInfo;
begin
  FCanGrow := Value;
  if not StatusIsGo(FIndex) then Exit;
  
  if not Cr.FCrpeEngine.PEGetObjectFormat(Cr.FPrintJob, Handle, PE_OFN_EXPAND, valueInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetCanGrow <PEGetObjectFormat>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare}
  if valueInfo.viBoolean <> Bool(FCanGrow) then
  begin
    valueInfo.viBoolean := Bool(FCanGrow);
    
    if not Cr.FCrpeEngine.PESetObjectFormat(Cr.FPrintJob, Handle, PE_OFN_EXPAND, valueInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetCanGrow <PESetObjectFormat>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ Class TCrpePictures                                                          }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpePictures.Create;
begin
  inherited Create;
  {Set inherited ObjectInfo properties}
  FObjectType      := otBlob;
  FFieldObjectType := oftNone;
  FItem            := TCrpePicturesItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpePictures.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpePictures.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    Handle :=  0;
    FItem.Clear;
  end;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpePictures.SetIndex (nIndex: integer);
var
  pictureFormatInfo : PEPictureFormatInfo;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    Clear;
    Exit;
  end;
  inherited SetIndex(nIndex);
  PropagateHandle(Handle);
  if Handle = 0 then Exit;
  if not Cr.OpenPrintJob then Exit;

  
  if not Cr.FCrpeEngine.PEGetPictureFormatInfo(Cr.FPrintJob, Handle, pictureFormatInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        'Pictures.SetIndex <PEGetPictureFormatInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);
  Item.FCropLeft      := pictureFormatInfo.leftCropping;
  Item.FCropRight     := pictureFormatInfo.rightCropping;
  Item.FCropTop       := pictureFormatInfo.topCropping;
  Item.FCropBottom    := pictureFormatInfo.bottomCropping;
  Item.FScalingWidth  := pictureFormatInfo.xScaling * 100;
  Item.FScalingHeight := pictureFormatInfo.yScaling * 100;
end;
{------------------------------------------------------------------------------}
{ GetItems                                                                     }
{------------------------------------------------------------------------------}
function TCrpePictures.GetItems(nIndex: integer) : TCrpePicturesItem;
begin
  SetIndex(nIndex);
  Result := TCrpePicturesItem(FItem);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpePictures.GetItem : TCrpePicturesItem;
begin
  Result := TCrpePicturesItem(FItem);
end;
{------------------------------------------------------------------------------}
{ SetItem                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpePictures.SetItem (const nItem: TCrpePicturesItem);
begin
  FItem.Assign(nItem);
end;


{******************************************************************************}
{ Class TCrpeMapSummaryFieldsItem                                              }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeMapSummaryFieldsItem.Create;
begin
  inherited Create;
  FFieldName := '';
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeMapSummaryFieldsItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeMapSummaryFieldsItem then
  begin
    FieldName := TCrpeMapSummaryFieldsItem(Source).FieldName;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeMapSummaryFieldsItem.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) or (Handle = 0) then
  begin
    FIndex := -1;
    Handle :=  0;
    FFieldName := '';
  end;
end;
{------------------------------------------------------------------------------}
{ SetField                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeMapSummaryFieldsItem.SetFieldName (const Value: string);
var
  hSum : HWnd;
  iSum : Smallint;
  pSum : PChar;
  sSum : string;

begin
  FFieldName := Value;
  if Handle = 0 then Exit;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {This part obtains the Map SummaryField information from a Report}
  
  if not Cr.FCrpeEngine.PEGetNthMapSummaryField (Cr.FPrintJob, Handle,
    FIndex, hSum, iSum) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetFieldName <PEGetNthMapSummaryField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Get SummaryField string}
  pSum := StrAlloc(iSum);
  if not Cr.FCrpeEngine.PEGetHandleString(hSum, pSum, iSum) then
  begin
    StrDispose(pSum);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetFieldName <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sSum := String(pSum);
  StrDispose(pSum);

  {Compare}
  if CompareStr(sSum, FFieldName) <> 0 then
  begin
    
    if not Cr.FCrpeEngine.PESetNthMapSummaryField(Cr.FPrintJob, Handle,
      FIndex, PChar(FFieldName)) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetFieldName <PESetNthMapSummaryField>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ Class TCrpeMapSummaryFields                                                  }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeMapSummaryFields.Create;
begin
  inherited Create;
  FItem := TCrpeMapSummaryFieldsItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeMapSummaryFields.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeMapSummaryFields.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) or (Handle = 0) then
  begin
    FIndex := -1;
    Handle :=  0;
    FItem.Clear;
  end;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeMapSummaryFields.Count : integer;
var
  nFields : Smallint;
begin
  Result := 0;
  if Handle = 0 then Exit;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  
  nFields := Cr.FCrpeEngine.PEGetNMapSummaryFields(Cr.FPrintJob, Handle);
  if nFields = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'Count <PEGetNMapSummaryFields>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := nFields;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeMapSummaryFields.SetIndex (nIndex: integer);
var
  hSum : HWnd;
  iSum : Smallint;
  pSum : PChar;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    Clear;
    Exit;
  end;
  if Handle = 0 then Exit;
  if not Cr.OpenPrintJob then Exit;

  {This part obtains the Map SummaryField information from a Report}
  
  if not Cr.FCrpeEngine.PEGetNthMapSummaryField (Cr.FPrintJob, Handle,
    nIndex, hSum, iSum) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetIndex(' +
         IntToStr(nIndex) + ') <PEGetNthMapSummaryField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);
  {Get SummaryField string}
  pSum := StrAlloc(iSum);
  if not Cr.FCrpeEngine.PEGetHandleString(hSum, pSum, iSum) then
  begin
    StrDispose(pSum);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetIndex(' +
         IntToStr(nIndex) + ') <PEGetHandleString - FieldName>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FItem.FFieldName := String(pSum);
  StrDispose(pSum);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeMapSummaryFields.GetItem(nIndex: integer) : TCrpeMapSummaryFieldsItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeMapConditionFieldsItem                                            }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeMapConditionFieldsItem.Create;
begin
  inherited Create;
  FFieldName := '';
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeMapConditionFieldsItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeMapConditionFieldsItem then
  begin
    FieldName := TCrpeMapConditionFieldsItem(Source).FieldName;
    Exit;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeMapConditionFieldsItem.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) or (Handle = 0) then
  begin
    FIndex     := -1;
    Handle     :=  0;
    FFieldName := '';
  end;
end;
{------------------------------------------------------------------------------}
{ SetField                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeMapConditionFieldsItem.SetFieldName (const Value: string);
var
  hCon : HWnd;
  iCon : Smallint;
  pCon : PChar;
  sCon : string;

begin
  FFieldName := Value;
  if (Handle = 0) then Exit;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {This part obtains the Map ConditionField information from a Report}
  
  if not Cr.FCrpeEngine.PEGetNthMapConditionField (Cr.FPrintJob, Handle,
    FIndex, hCon, iCon) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetFieldName <PEGetNthMapConditionField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Get ConditionField string}
  pCon := StrAlloc(iCon);
  if not Cr.FCrpeEngine.PEGetHandleString(hCon, pCon, iCon) then
  begin
    StrDispose(pCon);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetFieldName <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sCon := String(pCon);
  StrDispose(pCon);

  {Compare}
  if CompareStr(sCon, FFieldName) <> 0 then
  begin
    
    if not Cr.FCrpeEngine.PESetNthMapConditionField(Cr.FPrintJob, Handle,
      FIndex, PChar(FFieldName)) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetFieldName <PESetNthMapConditionField>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ Class TCrpeMapConditionFields                                                }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeMapConditionFields.Create;
begin
  inherited Create;
  FItem := TCrpeMapConditionFieldsItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destructor Destroy                                                           }
{------------------------------------------------------------------------------}
destructor TCrpeMapConditionFields.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeMapConditionFields.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) or (Handle = 0) then
  begin
    FIndex := -1;
    Handle :=  0;
    FItem.Clear;
  end;
end;
{------------------------------------------------------------------------------}
{ Count                                                                        }
{------------------------------------------------------------------------------}
function TCrpeMapConditionFields.Count : integer;
var
  nFields : Smallint;
begin
  Result := 0;
  if (Handle = 0) then Exit;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(0) then Exit;

  
  nFields := Cr.FCrpeEngine.PEGetNMapConditionFields(Cr.FPrintJob, Handle);
  if nFields = -1 then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'Maps[' + IntToStr(FIndex) +
         '].ConditionFields.Count <PEGetNMapConditionFields>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Result := nFields;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeMapConditionFields.SetIndex (nIndex: integer);
var
  hCon : HWnd;
  iCon : Smallint;
  pCon : PChar;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    Clear;
    Exit;
  end;
  if Handle = 0 then Exit;
  if not Cr.OpenPrintJob then Exit;

  {This part obtains the Map ConditionField information from a Report}
  
  if not Cr.FCrpeEngine.PEGetNthMapConditionField (Cr.FPrintJob, Handle, FIndex, hCon, iCon) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetIndex(' +
         IntToStr(nIndex) + ') <PEGetNthMapConditionField>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);
  {Get ConditionField string}
  pCon := StrAlloc(iCon);
  if not Cr.FCrpeEngine.PEGetHandleString(hCon, pCon, iCon) then
  begin
    StrDispose(pCon);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetIndex(' +
         IntToStr(nIndex) + ') <PEGetHandleString - FieldName>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  FItem.FFieldName := String(pCon);
  StrDispose(pCon);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeMapConditionFields.GetItem(nIndex: integer) : TCrpeMapConditionFieldsItem;
begin
  SetIndex(nIndex);
  Result := FItem;
end;


{******************************************************************************}
{ Class TCrpeMapsItem                                                          }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeMapsItem.Create;
begin
  inherited Create;
  {Map-specific properties}
  FLayout               := mlGroup;
  FDontSummarizeValues  := False;
  FMapType            := mttRanged;
  FNumberOfIntervals    := 5;
  FDotSize              := 0;
  FPieSize              := 0;
  FBarSize              := 0;
  FAllowEmptyIntervals  := True;
  FPieProportional        := True;
  FDistributionMethod   := mdmEqualCount;
  FColorLowestInterval  := clBlack;
  FColorHighestInterval := clWhite;
  FLegend               := mlFull;
  FLegendTitleType      := mltAuto;
  FTitle                := '';
  FLegendTitle          := '';
  FLegendSubTitle       := '';
  FOrientation          := moRowsOnly;
  FGroupSelected        := True;
  FSummaryFields        := TCrpeMapSummaryFields.Create;
  FConditionFields      := TCrpeMapConditionFields.Create;
  FSubClassList.Add(FSummaryFields);
  FSubClassList.Add(FConditionFields);
end;
{------------------------------------------------------------------------------}
{ Destroy                                                                      }
{------------------------------------------------------------------------------}
destructor TCrpeMapsItem.Destroy;
begin
  FSummaryFields.Free;
  FConditionFields.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeMapsItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeMapsItem then
  begin
    Layout               := TCrpeMapsItem(Source).Layout;
    DontSummarizeValues  := TCrpeMapsItem(Source).DontSummarizeValues;
    MapType              := TCrpeMapsItem(Source).MapType;
    NumberOfIntervals    := TCrpeMapsItem(Source).NumberOfIntervals;
    DotSize              := TCrpeMapsItem(Source).DotSize;
    PieSize              := TCrpeMapsItem(Source).PieSize;
    BarSize              := TCrpeMapsItem(Source).BarSize;
    AllowEmptyIntervals  := TCrpeMapsItem(Source).AllowEmptyIntervals;
    PieProportional      := TCrpeMapsItem(Source).PieProportional;
    DistributionMethod   := TCrpeMapsItem(Source).DistributionMethod;
    ColorLowestInterval  := TCrpeMapsItem(Source).ColorLowestInterval;
    ColorHighestInterval := TCrpeMapsItem(Source).ColorHighestInterval;
    Legend               := TCrpeMapsItem(Source).Legend;
    LegendTitleType      := TCrpeMapsItem(Source).LegendTitleType;
    Title                := TCrpeMapsItem(Source).Title;
    LegendTitle          := TCrpeMapsItem(Source).LegendTitle;
    LegendSubTitle       := TCrpeMapsItem(Source).LegendSubTitle;
    Orientation          := TCrpeMapsItem(Source).Orientation;
    GroupSelected        := TCrpeMapsItem(Source).GroupSelected;
    SummaryFields.Assign(TCrpeMapsItem(Source).SummaryFields);
    ConditionFields.Assign(TCrpeMapsItem(Source).ConditionFields);
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeMapsItem.Clear;
begin
  inherited Clear;
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex                := -1;
    Handle                :=  0;
    FLayout               := mlGroup;
    FDontSummarizeValues  := False;
    FMapType            := mttRanged;
    FNumberOfIntervals    := 5;
    FDotSize              := 0;
    FPieSize              := 0;
    FBarSize              := 0;
    FAllowEmptyIntervals  := True;
    FPieProportional        := True;
    FDistributionMethod   := mdmEqualCount;
    FColorLowestInterval  := clBlack;
    FColorHighestInterval := clWhite;
    FLegend               := mlFull;
    FLegendTitleType      := mltAuto;
    FTitle                := '';
    FLegendTitle          := '';
    FLegendSubTitle       := '';
    FOrientation          := moRowsOnly;
    FGroupSelected        := True;
  end;
  FSummaryFields.Clear;
  FConditionFields.Clear;
end;
{------------------------------------------------------------------------------}
{ SetLayout                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeMapsItem.SetLayout (const Value: TCrMapLayout);
var
  MapInfo : PEMapDataInfo;
begin
  FLayout := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetMapDataInfo(Cr.FPrintJob, Handle, MapInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetLayout <PEGetMapDataInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare}
  if MapInfo.layout <> Ord(FLayout) then
  begin
    MapInfo.layout := Ord(FLayout);
    
    if not Cr.FCrpeEngine.PESetMapDataInfo(Cr.FPrintJob, Handle, MapInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetLayout <PESetMapDataInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDontSummarizeValues                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeMapsItem.SetDontSummarizeValues (const Value: Boolean);
var
  MapInfo : PEMapDataInfo;
begin
  FDontSummarizeValues := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetMapDataInfo(Cr.FPrintJob, Handle, MapInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errCRPEBugs,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetDontSummarizeValues <PEGetMapDataInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare}
  if MapInfo.dontSummarizeValues <> Ord(FDontSummarizeValues) then
  begin
    MapInfo.dontSummarizeValues := Ord(FDontSummarizeValues);
    
    if not Cr.FCrpeEngine.PESetMapDataInfo(Cr.FPrintJob, Handle, MapInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errCRPEBugs,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetDontSummarizeValues <PESetMapDataInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetMapType                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeMapsItem.SetMapType (const Value: TCrMapType);
var
  MapStyle : PEMapStyle;
  iTheme    : Smallint;
begin
  FMapType := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetMapType <PEGetMapStyle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare}
  iTheme := PE_MAP_TT_RANGED;
  case FMapType of
    mttRanged          : iTheme := PE_MAP_TT_RANGED;
    mttBarChart        : iTheme := PE_MAP_TT_BARCHART;
    mttPieChart        : iTheme := PE_MAP_TT_PIECHART;
    mttGraduated       : iTheme := PE_MAP_TT_GRADUATED;
    mttDotDensity      : iTheme := PE_MAP_TT_DOTDENSITY;
    mttIndividualValue : iTheme := PE_MAP_TT_INDIVIDUALVALUE;
  end;
  if MapStyle.themeType <> iTheme then
  begin
    MapStyle.themeType := iTheme;
    
    if not Cr.FCrpeEngine.PESetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetMapType <PESetMapStyle>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetNumberOfIntervals                                                         }
{------------------------------------------------------------------------------}
procedure TCrpeMapsItem.SetNumberOfIntervals (const Value: Smallint);
var
  MapStyle : PEMapStyle;
begin
  FNumberOfIntervals := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetNumberOfIntervals <PEGetMapStyle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare}
  if MapStyle.themeSize <> FNumberOfIntervals then
  begin
    MapStyle.themeSize := FNumberOfIntervals;
    
    if not Cr.FCrpeEngine.PESetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetNumberOfIntervals <PESetMapStyle>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDotSize                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeMapsItem.SetDotSize (const Value: Smallint);
var
  MapStyle : PEMapStyle;
begin
  FDotSize := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetDotSize <PEGetMapStyle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare}
  if MapStyle.themeSize <> FDotSize then
  begin
    MapStyle.themeSize := FDotSize;
    
    if not Cr.FCrpeEngine.PESetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetDotSize <PESetMapStyle>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetPieSize                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeMapsItem.SetPieSize (const Value: Smallint);
var
  MapStyle : PEMapStyle;
begin
  FPieSize := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetPieSize <PEGetMapStyle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare}
  if MapStyle.themeSize <> FPieSize then
  begin
    MapStyle.themeSize := FPieSize;
    
    if not Cr.FCrpeEngine.PESetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetPieSize <PESetMapStyle>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetPieProportional                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeMapsItem.SetPieProportional (const Value: Boolean);
var
  MapStyle : PEMapStyle;
begin
  FPieProportional := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetPieProportional <PEGetMapStyle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare}
  if MapStyle.themeStyle <> Ord(FPieProportional) then
  begin
    MapStyle.themeStyle := 0;
    
    if not Cr.FCrpeEngine.PESetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetPieProportional <PESetMapStyle>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetBarSize                                                                   }
{------------------------------------------------------------------------------}
procedure TCrpeMapsItem.SetBarSize (const Value: Smallint);
var
  MapStyle : PEMapStyle;
begin
  FBarSize := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetBarSize <PEGetMapStyle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare}
  if MapStyle.themeSize <> FBarSize then
  begin
    MapStyle.themeSize := FBarSize;
    
    if not Cr.FCrpeEngine.PESetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetBarSize <PESetMapStyle>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetAllowEmptyIntervals                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeMapsItem.SetAllowEmptyIntervals (const Value: Boolean);
var
  MapStyle : PEMapStyle;
begin
  FAllowEmptyIntervals := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetAllowEmptyIntervals <PEGetMapStyle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare}
  if MapStyle.themeStyle <> Ord(FAllowEmptyIntervals) then
  begin
    MapStyle.themeStyle := Ord(FAllowEmptyIntervals);
    
    if not Cr.FCrpeEngine.PESetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetAllowEmptyIntervals <PESetMapStyle>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetDistributionMethod                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeMapsItem.SetDistributionMethod (const Value: TCrMapDistributionMethod);
var
  MapStyle : PEMapStyle;
begin
  FDistributionMethod := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetDistributionMethod <PEGetMapStyle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare}
  if MapStyle.distributionMethod <> Ord(FDistributionMethod) then
  begin
    MapStyle.distributionMethod := Ord(FDistributionMethod);
    
    if not Cr.FCrpeEngine.PESetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetDistributionMethod <PESetMapStyle>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetColorLowestInterval                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeMapsItem.SetColorLowestInterval (const Value: TColor);
var
  MapStyle : PEMapStyle;
  xColor   : TColor;
begin
  FColorLowestInterval := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetColorLowestInterval <PEGetMapStyle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  if MapStyle.colorLowestInterval = PE_NO_COLOR then
    xColor := clNone
  else
    xColor := TColor(MapStyle.colorLowestInterval);
  {Compare}
  if xColor <> FColorLowestInterval then
  begin
    if FColorLowestInterval = clNone then
      MapStyle.colorLowestInterval := PE_NO_COLOR
    else
      MapStyle.colorLowestInterval := ColorToRGB(FColorLowestInterval);
    if FColorHighestInterval = clNone then
      MapStyle.colorHighestInterval := PE_NO_COLOR
    else
      MapStyle.colorHighestInterval := ColorToRGB(FColorHighestInterval);
    
    if not Cr.FCrpeEngine.PESetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetColorLowestInterval <PESetMapStyle>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetColorHighestInterval                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeMapsItem.SetColorHighestInterval (const Value: TColor);
var
  MapStyle : PEMapStyle;
  xColor   : TColor;
begin
  FColorHighestInterval := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetColorHighestInterval <PEGetMapStyle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  if MapStyle.colorHighestInterval = PE_NO_COLOR then
    xColor := clNone
  else
    xColor := TColor(MapStyle.colorHighestInterval);
  {Compare}
  if xColor <> FColorHighestInterval then
  begin
    if FColorHighestInterval = clNone then
      MapStyle.colorHighestInterval := PE_NO_COLOR
    else
      MapStyle.colorHighestInterval := ColorToRGB(FColorHighestInterval);
    if FColorLowestInterval = clNone then
      MapStyle.colorLowestInterval := PE_NO_COLOR
    else
      MapStyle.colorLowestInterval := ColorToRGB(FColorLowestInterval);
    
    if not Cr.FCrpeEngine.PESetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetColorHighestInterval <PESetMapStyle>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetLegend                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeMapsItem.SetLegend (const Value: TCrMapLegend);
var
  MapStyle : PEMapStyle;
begin
  FLegend := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetLegend <PEGetMapStyle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare}
  if MapStyle.legendType <> Ord(FLegend) then
  begin
    MapStyle.legendType := Ord(FLegend);
    
    if not Cr.FCrpeEngine.PESetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetLegend <PESetMapStyle>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetLegendTitleType                                                           }
{------------------------------------------------------------------------------}
procedure TCrpeMapsItem.SetLegendTitleType (const Value: TCrMapLegendTitle);
var
  MapStyle : PEMapStyle;
begin
  FLegendTitleType := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetLegendTitleType <PEGetMapStyle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare}
  if MapStyle.legendTitleType <> Ord(FLegendTitleType) then
  begin
    MapStyle.legendTitleType := Ord(FLegendTitleType);
    
    if not Cr.FCrpeEngine.PESetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetLegendTitleType <PESetMapStyle>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetTitle                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeMapsItem.SetTitle (const Value: string);
var
  hTitle : HWnd;
  iTitle : Smallint;
  pTitle : PChar;
  sTitle : string;
begin
  FTitle := Value;
  if not StatusIsGo(FIndex) then Exit;

  {Map Title}
  
  if not Cr.FCrpeEngine.PEGetMapTitle(Cr.FPrintJob, Handle, hTitle, iTitle) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetTitle <PEGetMapTitle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  pTitle := StrAlloc(iTitle);
  if not Cr.FCrpeEngine.PEGetHandleString(hTitle, pTitle, iTitle) then
  begin
    StrDispose(pTitle);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetTitle <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sTitle := String(pTitle);
  StrDispose(pTitle);

  {Compare}
  if CompareStr(sTitle, FTitle) <> 0 then
  begin
    
    if not Cr.FCrpeEngine.PESetMapTitle(Cr.FPrintJob, Handle, PChar(FTitle)) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetTitle <PESetMapTitle>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetLegendTitle                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeMapsItem.SetLegendTitle (const Value: string);
var
  hTitle : HWnd;
  iTitle : Smallint;
  pTitle : PChar;
  sTitle : string;

begin
  FLegendTitle := Value;
  if not StatusIsGo(FIndex) then Exit;

  {Map Legend Title}
  
  if not Cr.FCrpeEngine.PEGetMapLegendTitle(Cr.FPrintJob, Handle, hTitle, iTitle) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetLegendTitle <PEGetMapLegendTitle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  pTitle := StrAlloc(iTitle);
  if not Cr.FCrpeEngine.PEGetHandleString(hTitle, pTitle, iTitle) then
  begin
    StrDispose(pTitle);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetLegendTitle <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sTitle := String(pTitle);
  StrDispose(pTitle);

  {Compare}
  if CompareStr(sTitle, FTitle) <> 0 then
  begin
    
    if not Cr.FCrpeEngine.PESetMapLegendTitle(Cr.FPrintJob, Handle, PChar(FLegendTitle)) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetLegendTitle <PESetMapLegendTitle>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetLegendSubTitle                                                            }
{------------------------------------------------------------------------------}
procedure TCrpeMapsItem.SetLegendSubTitle (const Value: string);
var
  hTitle : HWnd;
  iTitle : Smallint;
  pTitle : PChar;
  sTitle : string;
begin
  FLegendSubTitle := Value;
  if not StatusIsGo(FIndex) then Exit;

  {Map Legend SubTitle}
  
  if not Cr.FCrpeEngine.PEGetMapLegendSubtitle(Cr.FPrintJob, Handle, hTitle, iTitle) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetLegendSubTitle <PEGetMapLegendSubtitle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  pTitle := StrAlloc(iTitle);
  if not Cr.FCrpeEngine.PEGetHandleString(hTitle, pTitle, iTitle) then
  begin
    StrDispose(pTitle);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetLegendSubTitle <PEGetHandleString>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  sTitle := String(pTitle);
  StrDispose(pTitle);

  {Compare}
  if CompareStr(sTitle, FLegendSubTitle) <> 0 then
  begin
    
    if not Cr.FCrpeEngine.PESetMapLegendSubTitle(Cr.FPrintJob, Handle, PChar(FLegendSubTitle)) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetLegendSubTitle <PESetMapLegendSubTitle>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetOrientation                                                               }
{------------------------------------------------------------------------------}
procedure TCrpeMapsItem.SetOrientation (const Value: TCrMapOrientation);
var
  MapCondition : PEMapCondition;
begin
  FOrientation := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetMapConditions(Cr.FPrintJob, Handle, MapCondition) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetOrientation <PEGetMapConditions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare}
  if MapCondition.orientation <> Ord(FOrientation) then
  begin
    MapCondition.orientation := Ord(FOrientation);
    
    if not Cr.FCrpeEngine.PESetMapConditions(Cr.FPrintJob, Handle, MapCondition) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetOrientation <PESetMapConditions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;
{------------------------------------------------------------------------------}
{ SetGroupSelected                                                             }
{------------------------------------------------------------------------------}
procedure TCrpeMapsItem.SetGroupSelected (const Value: Boolean);
var
  MapCondition : PEMapCondition;
begin
  FGroupSelected := Value;
  if not StatusIsGo(FIndex) then Exit;

  
  if not Cr.FCrpeEngine.PEGetMapConditions(Cr.FPrintJob, Handle, MapCondition) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'SetGroupSelected <PEGetMapConditions>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare}
  if MapCondition.groupSelected <> Ord(FGroupSelected) then
  begin
    MapCondition.groupSelected := Ord(FGroupSelected);
    
    if not Cr.FCrpeEngine.PESetMapConditions(Cr.FPrintJob, Handle, MapCondition) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetGroupSelected <PESetMapConditions>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end;
end;


{******************************************************************************}
{ Class TCrpeMaps                                                              }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeMaps.Create;
begin
  inherited Create;
  {Set inherited ObjectInfo properties}
  FObjectType := otMap;
  FFieldObjectType := oftNone;
  FItem := TCrpeMapsItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destroy                                                                      }
{------------------------------------------------------------------------------}
destructor TCrpeMaps.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeMaps.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    Handle :=  0;
    Item.Clear;
  end;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeMaps.SetIndex (nIndex: integer);
var
  MapInfo      : PEMapDataInfo;
  MapStyle     : PEMapStyle;
  MapCondition : PEMapCondition;
  hTitle       : HWnd;
  iTitle       : Smallint;
  pTitle       : PChar;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    Clear;
    Exit;
  end;
  inherited SetIndex(nIndex);
  PropagateHandle(Handle);
  if Handle = 0 then Exit;
  if not Cr.OpenPrintJob then Exit;

  {MapInfo}
  
  if not Cr.FCrpeEngine.PEGetMapDataInfo(Cr.FPrintJob, Handle, MapInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetMapDataInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Layout}
  case MapInfo.layout of
    PE_MAP_LAYOUT_DETAIL   : Item.FLayout := mlDetail;
    PE_MAP_LAYOUT_GROUP    : Item.FLayout := mlGroup;
    PE_MAP_LAYOUT_CROSSTAB : Item.FLayout := mlCrossTab;
    PE_MAP_LAYOUT_OLAP     : Item.FLayout := mlOlap;
    else
      Item.FLayout := mlGroup;
  end;
  {DontSummarizeValues}
  if MapInfo.dontSummarizeValues < 1 then
    Item.FDontSummarizeValues := False
  else
    Item.FDontSummarizeValues := True;

  {Map Conditions - only applies to CrossTab or Olap maps}
  if (MapInfo.layout = PE_MAP_LAYOUT_CROSSTAB) or
     (MapInfo.layout = PE_MAP_LAYOUT_OLAP) then
  begin
    
    if not Cr.FCrpeEngine.PEGetMapConditions(Cr.FPrintJob, Handle, MapCondition) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetIndex(' +
          IntToStr(nIndex) + ') <PEGetMapConditions>') of
        errIgnore : ;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
    {Orientation}
    case MapCondition.orientation of
      PE_MAP_ORIENT_ROWSONLY    : Item.FOrientation := moRowsOnly;
      PE_MAP_ORIENT_COLSONLY    : Item.FOrientation := moColsOnly;
      PE_MAP_ORIENT_MIXEDROWCOL : Item.FOrientation := moMixedRowCol;
      PE_MAP_ORIENT_MIXEDCOLROW : Item.FOrientation := moMixedColRow;
      else
        Item.FOrientation := moRowsOnly;
    end;
    {GroupSelected}
    if MapCondition.groupSelected > 0 then
      Item.FGroupSelected := True
    else
      Item.FGroupSelected := False;
  end;

  {Map Style}
  
  if not Cr.FCrpeEngine.PEGetMapStyle(Cr.FPrintJob, Handle, MapStyle) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetMapStyle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Map Type}
  case MapStyle.themeType of
    PE_MAP_TT_RANGED     : Item.FMapType := mttRanged;
    PE_MAP_TT_BARCHART   : Item.FMapType := mttBarChart;
    PE_MAP_TT_PIECHART   : Item.FMapType := mttPieChart;
    PE_MAP_TT_GRADUATED  : Item.FMapType := mttGraduated;
    PE_MAP_TT_DOTDENSITY : Item.FMapType := mttDotDensity;
    PE_MAP_TT_INDIVIDUALVALUE : Item.FMapType := mttIndividualValue;
    else
      Item.FMapType := mttRanged;
  end;
  {ThemeSize, and ThemeStyle}
    {Ranged}
  Item.FNumberOfIntervals := MapStyle.themeSize;
  case MapStyle.themeStyle of
    0 : Item.FAllowEmptyIntervals := False;
    1 : Item.FAllowEmptyIntervals := True;
    else
      Item.FAllowEmptyIntervals := True;
  end;
    {Bar}
  Item.FBarSize := MapStyle.themeSize;
    {Pie}
  Item.FPieSize := MapStyle.themeSize;
  case MapStyle.themeStyle of
    0 : Item.FPieProportional := False;
    1 : Item.FPieProportional := True;
    else
    Item.FPieProportional := True;
  end;
    {DotDensity}
  Item.FDotSize := MapStyle.themeSize;

  {DistributionMethod}
  case MapStyle.distributionMethod of
  {Changed for CR 9.x}
    PE_MAP_DM_EQUALCOUNT   : Item.FDistributionMethod := mdmEqualCount;
    PE_MAP_DM_EQUALRANGES  : Item.FDistributionMethod := mdmEqualRanges;
    PE_MAP_DM_NATURALBREAK : Item.FDistributionMethod := mdmNaturalBreak;
    PE_MAP_DM_STDDEV       : Item.FDistributionMethod := mdmStdDev;
    else
      Item.FDistributionMethod := mdmEqualCount;
  end;

{ShowMessage: bug in CRPE, had to swap Highest/Lowest on read}
  {ColorLowestInterval}
  if MapStyle.colorLowestInterval = PE_NO_COLOR then
    Item.FColorLowestInterval := clNone
  else
    Item.FColorLowestInterval := TColor(MapStyle.colorHighestInterval);
  {ColorHighestInterval}
  if MapStyle.colorHighestInterval = PE_NO_COLOR then
    Item.FColorHighestInterval := clNone
  else
    Item.FColorHighestInterval := TColor(MapStyle.colorLowestInterval);

  {Legend}
  case MapStyle.legendType of
    PE_MAP_LEGENDTYPE_FULL    : Item.FLegend := mlFull;
    PE_MAP_LEGENDTYPE_COMPACT : Item.FLegend := mlCompact;
    PE_MAP_LEGENDTYPE_NONE    : Item.FLegend := mlNone;
    else
      Item.FLegend := mlFull;
  end;
  {LegendTitleType}
  case MapStyle.legendTitleType of
    PE_MAP_LTT_AUTO     : Item.FLegendTitleType := mltAuto;
    PE_MAP_LTT_SPECIFIC : Item.FLegendTitleType := mltSpecific;
    else
      Item.FLegendTitleType := mltAuto;
  end;

  {Map Title}
  
  if not Cr.FCrpeEngine.PEGetMapTitle(Cr.FPrintJob, Handle, hTitle, iTitle) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetMapTitle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  pTitle := StrAlloc(iTitle);
  if not Cr.FCrpeEngine.PEGetHandleString(hTitle, pTitle, iTitle) then
  begin
    StrDispose(pTitle);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetHandleString - Title>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FTitle := String(pTitle);
  StrDispose(pTitle);

  {Map Legend Title}
  
  if not Cr.FCrpeEngine.PEGetMapLegendTitle(Cr.FPrintJob, Handle, hTitle, iTitle) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetMapLegendTitle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  pTitle := StrAlloc(iTitle);
  if not Cr.FCrpeEngine.PEGetHandleString(hTitle, pTitle, iTitle) then
  begin
    StrDispose(pTitle);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetHandleString - LegendTitle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FLegendTitle := String(pTitle);
  StrDispose(pTitle);

  {Map Legend SubTitle}
  
  if not Cr.FCrpeEngine.PEGetMapLegendSubtitle(Cr.FPrintJob, Handle, hTitle, iTitle) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetMapLegendSubtitle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  pTitle := StrAlloc(iTitle);
  if not Cr.FCrpeEngine.PEGetHandleString(hTitle, pTitle, iTitle) then
  begin
    StrDispose(pTitle);
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
        Cr.BuildErrorString(Self) + 'SetIndex(' +
        IntToStr(nIndex) + ') <PEGetHandleString - LegendSubTitle>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  Item.FLegendSubTitle := String(pTitle);
  StrDispose(pTitle);
end;
{------------------------------------------------------------------------------}
{ GetItems                                                                     }
{------------------------------------------------------------------------------}
function TCrpeMaps.GetItems(nIndex: integer) : TCrpeMapsItem;
begin
  SetIndex(nIndex);
  Result := TCrpeMapsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeMaps.GetItem : TCrpeMapsItem;
begin
  Result := TCrpeMapsItem(FItem);
end;
{------------------------------------------------------------------------------}
{ SetItem                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeMaps.SetItem (const nItem: TCrpeMapsItem);
begin
  FItem.Assign(nItem);
end;


{******************************************************************************}
{ Class TCrpeOLAPCubesItem                                                     }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Constructor Create                                                           }
{------------------------------------------------------------------------------}
constructor TCrpeOLAPCubesItem.Create;
begin
  inherited Create;
  FServerName       := '';
  FUserID           := '';
  FPassword         := '';
  FDatabaseName     := '';
  FCubeName         := '';
  FConnectionString := '';
end;
{------------------------------------------------------------------------------}
{ Assign                                                                       }
{------------------------------------------------------------------------------}
procedure TCrpeOLAPCubesItem.Assign(Source: TPersistent);
begin
  if Source is TCrpeOLAPCubesItem then
  begin
    ServerName       := TCrpeOLAPCubesItem(Source).ServerName;
    UserID           := TCrpeOLAPCubesItem(Source).UserID;
    Password         := TCrpeOLAPCubesItem(Source).Password;
    DatabaseName     := TCrpeOLAPCubesItem(Source).DatabaseName;
    CubeName         := TCrpeOLAPCubesItem(Source).CubeName;
    ConnectionString := TCrpeOLAPCubesItem(Source).ConnectionString;
  end;
  inherited Assign(Source);
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeOLAPCubesItem.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex            := -1;
    FServerName       := '';
    FUserID           := '';
    FPassword         := '';
    FDatabaseName     := '';
    FCubeName         := '';
    FConnectionString := '';
  end
  else
  begin
    SetServerName('');
    SetUserID('');
    SetPassword('');
    SetDatabaseName('');
    SetCubeName('');
    SetConnectionString('');
  end;
end;
{------------------------------------------------------------------------------}
{ Test                                                                         }
{------------------------------------------------------------------------------}
function TCrpeOLAPCubesItem.Test : Boolean;
begin
  Result := False;
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Test Connectivity}
  
  Result := Cr.FCrpeEngine.PETestNthOlapCubeConnectivity(Cr.FPrintJob, FIndex);
  {If if failed, store the resulting error}
  if Result = False then
    Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
      Cr.BuildErrorString(Self) + 'Test <PETestNthOlapCubeConnectivity>');
end;
{------------------------------------------------------------------------------}
{ SetServerName                                                                }
{------------------------------------------------------------------------------}
procedure TCrpeOLAPCubesItem.SetServerName(const Value: string);
var
  LogInfo : PEOLAPLogOnInfo;
begin
  FServerName := Value;
  {Check Length}
  if Length(FServerName) > PE_SERVERNAME_LEN then
    FServerName := Copy(FServerName, 1, PE_SERVERNAME_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the OLAP LogOnInfo from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthOLAPCubeLogOnInfo(Cr.FPrintJob, FIndex, LogInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetServerName <PEGetNthOLAPCubeLogOnInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {ServerName}
  if CompareStr(LogInfo.ServerName, PChar(FServerName)) <> 0 then
  begin
    StrCopy(LogInfo.ServerName, PChar(FServerName));
    {Send the LogOnInfo to the Report}
    
    if not Cr.FCrpeEngine.PESetNthOLAPCubeLogOnInfo(Cr.FPrintJob, FIndex, LogInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetServerName <PESetNthOLAPCubeLogOnInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end; { if }
end;
{------------------------------------------------------------------------------}
{ SetDatabaseName                                                              }
{------------------------------------------------------------------------------}
procedure TCrpeOLAPCubesItem.SetDatabaseName(const Value: string);
var
  LogInfo : PEOLAPLogOnInfo;
begin
  FDatabaseName := Value;
  {Check Length}
  if Length(FDatabaseName) > PE_DATABASENAME_LEN then
    FDatabaseName := Copy(FDatabaseName, 1, PE_DATABASENAME_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the OLAP LogOnInfo from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthOLAPCubeLogOnInfo(Cr.FPrintJob, FIndex, LogInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetDatabaseName <PEGetNthOLAPCubeLogOnInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare DatabaseName}
  if CompareStr(LogInfo.DatabaseName, PChar(FDatabaseName)) <> 0 then
  begin
    StrCopy(LogInfo.DatabaseName, PChar(FDatabaseName));
    {Send the LogOnInfo to the Report}
    
    if not Cr.FCrpeEngine.PESetNthOLAPCubeLogOnInfo(Cr.FPrintJob, FIndex, LogInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetDatabaseName <PESetNthOLAPCubeLogOnInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end; { if }
end;
{------------------------------------------------------------------------------}
{ SetConnectionString                                                          }
{------------------------------------------------------------------------------}
procedure TCrpeOLAPCubesItem.SetConnectionString(const Value: string);
var
  LogInfo : PEOLAPLogOnInfo;
begin
  FConnectionString := Value;
  {Check Length}
  if Length(FConnectionString) > PE_OLAP_CONNECTION_STRING_LEN then
    FConnectionString := Copy(FConnectionString, 1, PE_OLAP_CONNECTION_STRING_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the OLAP LogOnInfo from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthOLAPCubeLogOnInfo(Cr.FPrintJob, FIndex, LogInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetConnectionString <PEGetNthOLAPCubeLogOnInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare ConnectionString}
  if CompareStr(LogInfo.ConnectionString, PChar(FConnectionString)) <> 0 then
  begin
    StrCopy(LogInfo.ConnectionString, PChar(FConnectionString));
    {Send the LogOnInfo to the Report}
    
    if not Cr.FCrpeEngine.PESetNthOLAPCubeLogOnInfo(Cr.FPrintJob, FIndex, LogInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetConnectionString <PESetNthOLAPCubeLogOnInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end; { if }
end;
{------------------------------------------------------------------------------}
{ SetCubeName                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeOLAPCubesItem.SetCubeName(const Value: string);
var
  LogInfo : PEOLAPLogOnInfo;
begin
  FCubeName := Value;
  {Check Length}
  if Length(FCubeName) > PE_OLAP_CUBENAME_LEN then
    FCubeName := Copy(FCubeName, 1, PE_OLAP_CUBENAME_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the OLAP LogOnInfo from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthOLAPCubeLogOnInfo(Cr.FPrintJob, FIndex, LogInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetCubeName <PEGetNthOLAPCubeLogOnInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare CubeName}
  if CompareStr(LogInfo.CubeName, PChar(FCubeName)) <> 0 then
  begin
    StrCopy(LogInfo.CubeName, PChar(FCubeName));
    {Send the LogOnInfo to the Report}
    
    if not Cr.FCrpeEngine.PESetNthOLAPCubeLogOnInfo(Cr.FPrintJob, FIndex, LogInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetCubeName <PESetNthOLAPCubeLogOnInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end; { if }
end;
{------------------------------------------------------------------------------}
{ SetUserID                                                                    }
{------------------------------------------------------------------------------}
procedure TCrpeOLAPCubesItem.SetUserID(const Value: string);
var
  LogInfo : PEOLAPLogOnInfo;
begin
  FUserID := Value;
  {Check Length}
  if Length(FUserID) > PE_USERID_LEN then
    FUserID := Copy(FUserID, 1, PE_USERID_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the OLAP LogOnInfo from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthOLAPCubeLogOnInfo(Cr.FPrintJob, FIndex, LogInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetUserID <PEGetNthOLAPCubeLogOnInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare UserID}
  if CompareStr(LogInfo.UserID, PChar(FUserID)) <> 0 then
  begin
    StrCopy(LogInfo.UserID, PChar(FUserID));
    {Send the LogOnInfo to the Report}
    
    if not Cr.FCrpeEngine.PESetNthOLAPCubeLogOnInfo(Cr.FPrintJob, FIndex, LogInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetUserID <PESetNthOLAPCubeLogOnInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end; { if }
end;
{------------------------------------------------------------------------------}
{ SetPassword                                                                  }
{------------------------------------------------------------------------------}
procedure TCrpeOLAPCubesItem.SetPassword(const Value: string);
var
  LogInfo : PEOLAPLogOnInfo;
begin
  FPassword := Value;
  {Check Length}
  if Length(FPassword) > PE_PASSWORD_LEN then
    FPassword := Copy(FPassword, 1, PE_PASSWORD_LEN);
  if (Cr = nil) then Exit;
  if not Cr.StatusIsGo(FIndex) then Exit;

  {Get the OLAP LogOnInfo from the Report}
  
  if not Cr.FCrpeEngine.PEGetNthOLAPCubeLogOnInfo(Cr.FPrintJob, FIndex, LogInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         Cr.BuildErrorString(Self) + 'SetPassword <PEGetNthOLAPCubeLogOnInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  {Compare Password}
  if CompareStr(LogInfo.Password, PChar(FPassword)) <> 0 then
  begin
    StrCopy(LogInfo.Password, PChar(FPassword));
    {Send the LogOnInfo to the Report}
    
    if not Cr.FCrpeEngine.PESetNthOLAPCubeLogOnInfo(Cr.FPrintJob, FIndex, LogInfo) then
    begin
      case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
          Cr.BuildErrorString(Self) + 'SetPassword <PESetNthOLAPCubeLogOnInfo>') of
        errIgnore : Exit;
        errAbort  : Abort;
        errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
      end;
    end;
  end; { if }
end;


{******************************************************************************}
{ Class TCrpeOLAPCubes                                                         }
{******************************************************************************}
{------------------------------------------------------------------------------}
{ Create                                                                       }
{------------------------------------------------------------------------------}
constructor TCrpeOLAPCubes.Create;
begin
  inherited Create;
  {Set inherited ObjectInfo properties}
  FObjectType      := otOLAPCube;
  FFieldObjectType := oftNone;
  FItem            := TCrpeOLAPCubesItem.Create;
  FSubClassList.Add(FItem);
end;
{------------------------------------------------------------------------------}
{ Destroy                                                                      }
{------------------------------------------------------------------------------}
destructor TCrpeOLAPCubes.Destroy;
begin
  FItem.Free;
  inherited Destroy;
end;
{------------------------------------------------------------------------------}
{ Clear                                                                        }
{------------------------------------------------------------------------------}
procedure TCrpeOLAPCubes.Clear;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or
     (not FileExists(Cr.FReportName)) or
     (FIndex < 0) then
  begin
    FIndex := -1;
    Handle :=  0;
    FItem.Clear;
  end;
end;
{------------------------------------------------------------------------------}
{ SetIndex                                                                     }
{------------------------------------------------------------------------------}
procedure TCrpeOLAPCubes.SetIndex (nIndex: integer);
var
  LogInfo : PEOLAPLogOnInfo;
begin
  if (Cr = nil) then Exit;
  if IsStrEmpty(Cr.FReportName) or (not FileExists(Cr.FReportName)) then Exit;
  if csLoading in Cr.ComponentState then Exit;
  if nIndex < 0 then
  begin
    PropagateIndex(-1);
    PropagateHandle(0);
    Clear;
    Exit;
  end;
  inherited SetIndex(nIndex);
  PropagateHandle(Handle);
  if Handle = 0 then Exit;
  if not Cr.OpenPrintJob then Exit;

  if not Cr.FCrpeEngine.PEGetNthOLAPCubeLogOnInfo(Cr.FPrintJob, nIndex, LogInfo) then
  begin
    case Cr.GetErrorMsg(Cr.FPrintJob,errNoOption,errEngine,'',
         'OLAPCubes.SetIndex(' + IntToStr(nIndex) + ') <PEGetNthOLAPCubeLogOnInfo>') of
      errIgnore : Exit;
      errAbort  : Abort;
      errRaise  : raise ECrpeError.Create(Cr.FLastErrorNumber, Cr.FLastErrorString);
    end;
  end;
  PropagateIndex(nIndex);
  Item.FServerName := LogInfo.ServerName;
  Item.FUserID := LogInfo.UserID;
  Item.FPassword := LogInfo.Password;
  Item.FDatabaseName := LogInfo.DatabaseName;
  Item.FCubeName := LogInfo.CubeName;
  Item.FConnectionString := LogInfo.ConnectionString;
end;
{------------------------------------------------------------------------------}
{ GetItems                                                                     }
{------------------------------------------------------------------------------}
function TCrpeOLAPCubes.GetItems(nIndex: integer) : TCrpeOLAPCubesItem;
begin
  SetIndex(nIndex);
  Result := TCrpeOLAPCubesItem(FItem);
end;
{------------------------------------------------------------------------------}
{ GetItem                                                                      }
{------------------------------------------------------------------------------}
function TCrpeOLAPCubes.GetItem : TCrpeOLAPCubesItem;
begin
  Result := TCrpeOLAPCubesItem(FItem);
end;
{------------------------------------------------------------------------------}
{ SetItem                                                                      }
{------------------------------------------------------------------------------}
procedure TCrpeOLAPCubes.SetItem (const nItem: TCrpeOLAPCubesItem);
begin
  FItem.Assign(nItem);
end;


{******************************************************************************}
{ ECrpeEngine Class Definition                                                 }
{******************************************************************************}
constructor ECrpeError.Create(const nNo: Integer; const sMsg: string);
var
  s, sNo : string;
begin
  Str(nNo, sNo);
  s := 'Error:' + sNo + ' ' + sMsg;
  inherited Create(s);
  ErrorNo := nNo;
end; {ECrpeError}



end.

















